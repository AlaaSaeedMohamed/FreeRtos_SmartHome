
Free_Rtos_Smart_Home.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000048ec  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000178  00800060  000048ec  00004980  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000065f  008001d8  008001d8  00004af8  2**0
                  ALLOC
  3 .stab         00008958  00000000  00000000  00004af8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000051cb  00000000  00000000  0000d450  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000160  00000000  00000000  0001261b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001b4  00000000  00000000  0001277b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f0e  00000000  00000000  0001292f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000010c3  00000000  00000000  0001483d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001032  00000000  00000000  00015900  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  00016934  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002e3  00000000  00000000  00016ab4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000956  00000000  00000000  00016d97  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000176ed  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 da 0c 	jmp	0x19b4	; 0x19b4 <__vector_1>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 8d 0f 	jmp	0x1f1a	; 0x1f1a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ee       	ldi	r30, 0xEC	; 236
      68:	f8 e4       	ldi	r31, 0x48	; 72
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 3d       	cpi	r26, 0xD8	; 216
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a8 ed       	ldi	r26, 0xD8	; 216
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a7 33       	cpi	r26, 0x37	; 55
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 1f 0e 	call	0x1c3e	; 0x1c3e <main>
      8a:	0c 94 74 24 	jmp	0x48e8	; 0x48e8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 c5 03 	call	0x78a	; 0x78a <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 53 04 	call	0x8a6	; 0x8a6 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 53 04 	call	0x8a6	; 0x8a6 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 2d 24 	jmp	0x485a	; 0x485a <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	ac ec       	ldi	r26, 0xCC	; 204
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 49 24 	jmp	0x4892	; 0x4892 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 39 24 	jmp	0x4872	; 0x4872 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 f6 04 	call	0x9ec	; 0x9ec <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 55 24 	jmp	0x48aa	; 0x48aa <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 39 24 	jmp	0x4872	; 0x4872 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 f6 04 	call	0x9ec	; 0x9ec <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 55 24 	jmp	0x48aa	; 0x48aa <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 2d 24 	jmp	0x485a	; 0x485a <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	8c ec       	ldi	r24, 0xCC	; 204
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 f6 04 	call	0x9ec	; 0x9ec <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 49 24 	jmp	0x4892	; 0x4892 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 35 24 	jmp	0x486a	; 0x486a <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	6c ec       	ldi	r22, 0xCC	; 204
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 f6 04 	call	0x9ec	; 0x9ec <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 51 24 	jmp	0x48a2	; 0x48a2 <__epilogue_restores__+0x10>

0000078a <__gesf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 39 24 	jmp	0x4872	; 0x4872 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gesf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gesf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 43 06 	call	0xc86	; 0xc86 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gesf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 55 24 	jmp	0x48aa	; 0x48aa <__epilogue_restores__+0x18>

000007ea <__floatsisf>:
     7ea:	a8 e0       	ldi	r26, 0x08	; 8
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 36 24 	jmp	0x486c	; 0x486c <__prologue_saves__+0x12>
     7f6:	9b 01       	movw	r18, r22
     7f8:	ac 01       	movw	r20, r24
     7fa:	83 e0       	ldi	r24, 0x03	; 3
     7fc:	89 83       	std	Y+1, r24	; 0x01
     7fe:	da 01       	movw	r26, r20
     800:	c9 01       	movw	r24, r18
     802:	88 27       	eor	r24, r24
     804:	b7 fd       	sbrc	r27, 7
     806:	83 95       	inc	r24
     808:	99 27       	eor	r25, r25
     80a:	aa 27       	eor	r26, r26
     80c:	bb 27       	eor	r27, r27
     80e:	b8 2e       	mov	r11, r24
     810:	21 15       	cp	r18, r1
     812:	31 05       	cpc	r19, r1
     814:	41 05       	cpc	r20, r1
     816:	51 05       	cpc	r21, r1
     818:	19 f4       	brne	.+6      	; 0x820 <__floatsisf+0x36>
     81a:	82 e0       	ldi	r24, 0x02	; 2
     81c:	89 83       	std	Y+1, r24	; 0x01
     81e:	3a c0       	rjmp	.+116    	; 0x894 <__stack+0x35>
     820:	88 23       	and	r24, r24
     822:	a9 f0       	breq	.+42     	; 0x84e <__floatsisf+0x64>
     824:	20 30       	cpi	r18, 0x00	; 0
     826:	80 e0       	ldi	r24, 0x00	; 0
     828:	38 07       	cpc	r19, r24
     82a:	80 e0       	ldi	r24, 0x00	; 0
     82c:	48 07       	cpc	r20, r24
     82e:	80 e8       	ldi	r24, 0x80	; 128
     830:	58 07       	cpc	r21, r24
     832:	29 f4       	brne	.+10     	; 0x83e <__floatsisf+0x54>
     834:	60 e0       	ldi	r22, 0x00	; 0
     836:	70 e0       	ldi	r23, 0x00	; 0
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	9f ec       	ldi	r25, 0xCF	; 207
     83c:	30 c0       	rjmp	.+96     	; 0x89e <__stack+0x3f>
     83e:	ee 24       	eor	r14, r14
     840:	ff 24       	eor	r15, r15
     842:	87 01       	movw	r16, r14
     844:	e2 1a       	sub	r14, r18
     846:	f3 0a       	sbc	r15, r19
     848:	04 0b       	sbc	r16, r20
     84a:	15 0b       	sbc	r17, r21
     84c:	02 c0       	rjmp	.+4      	; 0x852 <__floatsisf+0x68>
     84e:	79 01       	movw	r14, r18
     850:	8a 01       	movw	r16, r20
     852:	8e e1       	ldi	r24, 0x1E	; 30
     854:	c8 2e       	mov	r12, r24
     856:	d1 2c       	mov	r13, r1
     858:	dc 82       	std	Y+4, r13	; 0x04
     85a:	cb 82       	std	Y+3, r12	; 0x03
     85c:	ed 82       	std	Y+5, r14	; 0x05
     85e:	fe 82       	std	Y+6, r15	; 0x06
     860:	0f 83       	std	Y+7, r16	; 0x07
     862:	18 87       	std	Y+8, r17	; 0x08
     864:	c8 01       	movw	r24, r16
     866:	b7 01       	movw	r22, r14
     868:	0e 94 a7 04 	call	0x94e	; 0x94e <__clzsi2>
     86c:	01 97       	sbiw	r24, 0x01	; 1
     86e:	18 16       	cp	r1, r24
     870:	19 06       	cpc	r1, r25
     872:	84 f4       	brge	.+32     	; 0x894 <__stack+0x35>
     874:	08 2e       	mov	r0, r24
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	ee 0c       	add	r14, r14
     87a:	ff 1c       	adc	r15, r15
     87c:	00 1f       	adc	r16, r16
     87e:	11 1f       	adc	r17, r17
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	ed 82       	std	Y+5, r14	; 0x05
     886:	fe 82       	std	Y+6, r15	; 0x06
     888:	0f 83       	std	Y+7, r16	; 0x07
     88a:	18 87       	std	Y+8, r17	; 0x08
     88c:	c8 1a       	sub	r12, r24
     88e:	d9 0a       	sbc	r13, r25
     890:	dc 82       	std	Y+4, r13	; 0x04
     892:	cb 82       	std	Y+3, r12	; 0x03
     894:	ba 82       	std	Y+2, r11	; 0x02
     896:	ce 01       	movw	r24, r28
     898:	01 96       	adiw	r24, 0x01	; 1
     89a:	0e 94 f6 04 	call	0x9ec	; 0x9ec <__pack_f>
     89e:	28 96       	adiw	r28, 0x08	; 8
     8a0:	e9 e0       	ldi	r30, 0x09	; 9
     8a2:	0c 94 52 24 	jmp	0x48a4	; 0x48a4 <__epilogue_restores__+0x12>

000008a6 <__fixsfsi>:
     8a6:	ac e0       	ldi	r26, 0x0C	; 12
     8a8:	b0 e0       	ldi	r27, 0x00	; 0
     8aa:	e9 e5       	ldi	r30, 0x59	; 89
     8ac:	f4 e0       	ldi	r31, 0x04	; 4
     8ae:	0c 94 3d 24 	jmp	0x487a	; 0x487a <__prologue_saves__+0x20>
     8b2:	69 83       	std	Y+1, r22	; 0x01
     8b4:	7a 83       	std	Y+2, r23	; 0x02
     8b6:	8b 83       	std	Y+3, r24	; 0x03
     8b8:	9c 83       	std	Y+4, r25	; 0x04
     8ba:	ce 01       	movw	r24, r28
     8bc:	01 96       	adiw	r24, 0x01	; 1
     8be:	be 01       	movw	r22, r28
     8c0:	6b 5f       	subi	r22, 0xFB	; 251
     8c2:	7f 4f       	sbci	r23, 0xFF	; 255
     8c4:	0e 94 cb 05 	call	0xb96	; 0xb96 <__unpack_f>
     8c8:	8d 81       	ldd	r24, Y+5	; 0x05
     8ca:	82 30       	cpi	r24, 0x02	; 2
     8cc:	61 f1       	breq	.+88     	; 0x926 <__fixsfsi+0x80>
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	50 f1       	brcs	.+84     	; 0x926 <__fixsfsi+0x80>
     8d2:	84 30       	cpi	r24, 0x04	; 4
     8d4:	21 f4       	brne	.+8      	; 0x8de <__fixsfsi+0x38>
     8d6:	8e 81       	ldd	r24, Y+6	; 0x06
     8d8:	88 23       	and	r24, r24
     8da:	51 f1       	breq	.+84     	; 0x930 <__fixsfsi+0x8a>
     8dc:	2e c0       	rjmp	.+92     	; 0x93a <__fixsfsi+0x94>
     8de:	2f 81       	ldd	r18, Y+7	; 0x07
     8e0:	38 85       	ldd	r19, Y+8	; 0x08
     8e2:	37 fd       	sbrc	r19, 7
     8e4:	20 c0       	rjmp	.+64     	; 0x926 <__fixsfsi+0x80>
     8e6:	6e 81       	ldd	r22, Y+6	; 0x06
     8e8:	2f 31       	cpi	r18, 0x1F	; 31
     8ea:	31 05       	cpc	r19, r1
     8ec:	1c f0       	brlt	.+6      	; 0x8f4 <__fixsfsi+0x4e>
     8ee:	66 23       	and	r22, r22
     8f0:	f9 f0       	breq	.+62     	; 0x930 <__fixsfsi+0x8a>
     8f2:	23 c0       	rjmp	.+70     	; 0x93a <__fixsfsi+0x94>
     8f4:	8e e1       	ldi	r24, 0x1E	; 30
     8f6:	90 e0       	ldi	r25, 0x00	; 0
     8f8:	82 1b       	sub	r24, r18
     8fa:	93 0b       	sbc	r25, r19
     8fc:	29 85       	ldd	r18, Y+9	; 0x09
     8fe:	3a 85       	ldd	r19, Y+10	; 0x0a
     900:	4b 85       	ldd	r20, Y+11	; 0x0b
     902:	5c 85       	ldd	r21, Y+12	; 0x0c
     904:	04 c0       	rjmp	.+8      	; 0x90e <__fixsfsi+0x68>
     906:	56 95       	lsr	r21
     908:	47 95       	ror	r20
     90a:	37 95       	ror	r19
     90c:	27 95       	ror	r18
     90e:	8a 95       	dec	r24
     910:	d2 f7       	brpl	.-12     	; 0x906 <__fixsfsi+0x60>
     912:	66 23       	and	r22, r22
     914:	b1 f0       	breq	.+44     	; 0x942 <__fixsfsi+0x9c>
     916:	50 95       	com	r21
     918:	40 95       	com	r20
     91a:	30 95       	com	r19
     91c:	21 95       	neg	r18
     91e:	3f 4f       	sbci	r19, 0xFF	; 255
     920:	4f 4f       	sbci	r20, 0xFF	; 255
     922:	5f 4f       	sbci	r21, 0xFF	; 255
     924:	0e c0       	rjmp	.+28     	; 0x942 <__fixsfsi+0x9c>
     926:	20 e0       	ldi	r18, 0x00	; 0
     928:	30 e0       	ldi	r19, 0x00	; 0
     92a:	40 e0       	ldi	r20, 0x00	; 0
     92c:	50 e0       	ldi	r21, 0x00	; 0
     92e:	09 c0       	rjmp	.+18     	; 0x942 <__fixsfsi+0x9c>
     930:	2f ef       	ldi	r18, 0xFF	; 255
     932:	3f ef       	ldi	r19, 0xFF	; 255
     934:	4f ef       	ldi	r20, 0xFF	; 255
     936:	5f e7       	ldi	r21, 0x7F	; 127
     938:	04 c0       	rjmp	.+8      	; 0x942 <__fixsfsi+0x9c>
     93a:	20 e0       	ldi	r18, 0x00	; 0
     93c:	30 e0       	ldi	r19, 0x00	; 0
     93e:	40 e0       	ldi	r20, 0x00	; 0
     940:	50 e8       	ldi	r21, 0x80	; 128
     942:	b9 01       	movw	r22, r18
     944:	ca 01       	movw	r24, r20
     946:	2c 96       	adiw	r28, 0x0c	; 12
     948:	e2 e0       	ldi	r30, 0x02	; 2
     94a:	0c 94 59 24 	jmp	0x48b2	; 0x48b2 <__epilogue_restores__+0x20>

0000094e <__clzsi2>:
     94e:	ef 92       	push	r14
     950:	ff 92       	push	r15
     952:	0f 93       	push	r16
     954:	1f 93       	push	r17
     956:	7b 01       	movw	r14, r22
     958:	8c 01       	movw	r16, r24
     95a:	80 e0       	ldi	r24, 0x00	; 0
     95c:	e8 16       	cp	r14, r24
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	f8 06       	cpc	r15, r24
     962:	81 e0       	ldi	r24, 0x01	; 1
     964:	08 07       	cpc	r16, r24
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	18 07       	cpc	r17, r24
     96a:	88 f4       	brcc	.+34     	; 0x98e <__clzsi2+0x40>
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	e8 16       	cp	r14, r24
     970:	f1 04       	cpc	r15, r1
     972:	01 05       	cpc	r16, r1
     974:	11 05       	cpc	r17, r1
     976:	31 f0       	breq	.+12     	; 0x984 <__clzsi2+0x36>
     978:	28 f0       	brcs	.+10     	; 0x984 <__clzsi2+0x36>
     97a:	88 e0       	ldi	r24, 0x08	; 8
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	a0 e0       	ldi	r26, 0x00	; 0
     980:	b0 e0       	ldi	r27, 0x00	; 0
     982:	17 c0       	rjmp	.+46     	; 0x9b2 <__clzsi2+0x64>
     984:	80 e0       	ldi	r24, 0x00	; 0
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	a0 e0       	ldi	r26, 0x00	; 0
     98a:	b0 e0       	ldi	r27, 0x00	; 0
     98c:	12 c0       	rjmp	.+36     	; 0x9b2 <__clzsi2+0x64>
     98e:	80 e0       	ldi	r24, 0x00	; 0
     990:	e8 16       	cp	r14, r24
     992:	80 e0       	ldi	r24, 0x00	; 0
     994:	f8 06       	cpc	r15, r24
     996:	80 e0       	ldi	r24, 0x00	; 0
     998:	08 07       	cpc	r16, r24
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	18 07       	cpc	r17, r24
     99e:	28 f0       	brcs	.+10     	; 0x9aa <__clzsi2+0x5c>
     9a0:	88 e1       	ldi	r24, 0x18	; 24
     9a2:	90 e0       	ldi	r25, 0x00	; 0
     9a4:	a0 e0       	ldi	r26, 0x00	; 0
     9a6:	b0 e0       	ldi	r27, 0x00	; 0
     9a8:	04 c0       	rjmp	.+8      	; 0x9b2 <__clzsi2+0x64>
     9aa:	80 e1       	ldi	r24, 0x10	; 16
     9ac:	90 e0       	ldi	r25, 0x00	; 0
     9ae:	a0 e0       	ldi	r26, 0x00	; 0
     9b0:	b0 e0       	ldi	r27, 0x00	; 0
     9b2:	20 e2       	ldi	r18, 0x20	; 32
     9b4:	30 e0       	ldi	r19, 0x00	; 0
     9b6:	40 e0       	ldi	r20, 0x00	; 0
     9b8:	50 e0       	ldi	r21, 0x00	; 0
     9ba:	28 1b       	sub	r18, r24
     9bc:	39 0b       	sbc	r19, r25
     9be:	4a 0b       	sbc	r20, r26
     9c0:	5b 0b       	sbc	r21, r27
     9c2:	04 c0       	rjmp	.+8      	; 0x9cc <__clzsi2+0x7e>
     9c4:	16 95       	lsr	r17
     9c6:	07 95       	ror	r16
     9c8:	f7 94       	ror	r15
     9ca:	e7 94       	ror	r14
     9cc:	8a 95       	dec	r24
     9ce:	d2 f7       	brpl	.-12     	; 0x9c4 <__clzsi2+0x76>
     9d0:	f7 01       	movw	r30, r14
     9d2:	ec 52       	subi	r30, 0x2C	; 44
     9d4:	ff 4f       	sbci	r31, 0xFF	; 255
     9d6:	80 81       	ld	r24, Z
     9d8:	28 1b       	sub	r18, r24
     9da:	31 09       	sbc	r19, r1
     9dc:	41 09       	sbc	r20, r1
     9de:	51 09       	sbc	r21, r1
     9e0:	c9 01       	movw	r24, r18
     9e2:	1f 91       	pop	r17
     9e4:	0f 91       	pop	r16
     9e6:	ff 90       	pop	r15
     9e8:	ef 90       	pop	r14
     9ea:	08 95       	ret

000009ec <__pack_f>:
     9ec:	df 92       	push	r13
     9ee:	ef 92       	push	r14
     9f0:	ff 92       	push	r15
     9f2:	0f 93       	push	r16
     9f4:	1f 93       	push	r17
     9f6:	fc 01       	movw	r30, r24
     9f8:	e4 80       	ldd	r14, Z+4	; 0x04
     9fa:	f5 80       	ldd	r15, Z+5	; 0x05
     9fc:	06 81       	ldd	r16, Z+6	; 0x06
     9fe:	17 81       	ldd	r17, Z+7	; 0x07
     a00:	d1 80       	ldd	r13, Z+1	; 0x01
     a02:	80 81       	ld	r24, Z
     a04:	82 30       	cpi	r24, 0x02	; 2
     a06:	48 f4       	brcc	.+18     	; 0xa1a <__pack_f+0x2e>
     a08:	80 e0       	ldi	r24, 0x00	; 0
     a0a:	90 e0       	ldi	r25, 0x00	; 0
     a0c:	a0 e1       	ldi	r26, 0x10	; 16
     a0e:	b0 e0       	ldi	r27, 0x00	; 0
     a10:	e8 2a       	or	r14, r24
     a12:	f9 2a       	or	r15, r25
     a14:	0a 2b       	or	r16, r26
     a16:	1b 2b       	or	r17, r27
     a18:	a5 c0       	rjmp	.+330    	; 0xb64 <__pack_f+0x178>
     a1a:	84 30       	cpi	r24, 0x04	; 4
     a1c:	09 f4       	brne	.+2      	; 0xa20 <__pack_f+0x34>
     a1e:	9f c0       	rjmp	.+318    	; 0xb5e <__pack_f+0x172>
     a20:	82 30       	cpi	r24, 0x02	; 2
     a22:	21 f4       	brne	.+8      	; 0xa2c <__pack_f+0x40>
     a24:	ee 24       	eor	r14, r14
     a26:	ff 24       	eor	r15, r15
     a28:	87 01       	movw	r16, r14
     a2a:	05 c0       	rjmp	.+10     	; 0xa36 <__pack_f+0x4a>
     a2c:	e1 14       	cp	r14, r1
     a2e:	f1 04       	cpc	r15, r1
     a30:	01 05       	cpc	r16, r1
     a32:	11 05       	cpc	r17, r1
     a34:	19 f4       	brne	.+6      	; 0xa3c <__pack_f+0x50>
     a36:	e0 e0       	ldi	r30, 0x00	; 0
     a38:	f0 e0       	ldi	r31, 0x00	; 0
     a3a:	96 c0       	rjmp	.+300    	; 0xb68 <__pack_f+0x17c>
     a3c:	62 81       	ldd	r22, Z+2	; 0x02
     a3e:	73 81       	ldd	r23, Z+3	; 0x03
     a40:	9f ef       	ldi	r25, 0xFF	; 255
     a42:	62 38       	cpi	r22, 0x82	; 130
     a44:	79 07       	cpc	r23, r25
     a46:	0c f0       	brlt	.+2      	; 0xa4a <__pack_f+0x5e>
     a48:	5b c0       	rjmp	.+182    	; 0xb00 <__pack_f+0x114>
     a4a:	22 e8       	ldi	r18, 0x82	; 130
     a4c:	3f ef       	ldi	r19, 0xFF	; 255
     a4e:	26 1b       	sub	r18, r22
     a50:	37 0b       	sbc	r19, r23
     a52:	2a 31       	cpi	r18, 0x1A	; 26
     a54:	31 05       	cpc	r19, r1
     a56:	2c f0       	brlt	.+10     	; 0xa62 <__pack_f+0x76>
     a58:	20 e0       	ldi	r18, 0x00	; 0
     a5a:	30 e0       	ldi	r19, 0x00	; 0
     a5c:	40 e0       	ldi	r20, 0x00	; 0
     a5e:	50 e0       	ldi	r21, 0x00	; 0
     a60:	2a c0       	rjmp	.+84     	; 0xab6 <__pack_f+0xca>
     a62:	b8 01       	movw	r22, r16
     a64:	a7 01       	movw	r20, r14
     a66:	02 2e       	mov	r0, r18
     a68:	04 c0       	rjmp	.+8      	; 0xa72 <__pack_f+0x86>
     a6a:	76 95       	lsr	r23
     a6c:	67 95       	ror	r22
     a6e:	57 95       	ror	r21
     a70:	47 95       	ror	r20
     a72:	0a 94       	dec	r0
     a74:	d2 f7       	brpl	.-12     	; 0xa6a <__pack_f+0x7e>
     a76:	81 e0       	ldi	r24, 0x01	; 1
     a78:	90 e0       	ldi	r25, 0x00	; 0
     a7a:	a0 e0       	ldi	r26, 0x00	; 0
     a7c:	b0 e0       	ldi	r27, 0x00	; 0
     a7e:	04 c0       	rjmp	.+8      	; 0xa88 <__pack_f+0x9c>
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	aa 1f       	adc	r26, r26
     a86:	bb 1f       	adc	r27, r27
     a88:	2a 95       	dec	r18
     a8a:	d2 f7       	brpl	.-12     	; 0xa80 <__pack_f+0x94>
     a8c:	01 97       	sbiw	r24, 0x01	; 1
     a8e:	a1 09       	sbc	r26, r1
     a90:	b1 09       	sbc	r27, r1
     a92:	8e 21       	and	r24, r14
     a94:	9f 21       	and	r25, r15
     a96:	a0 23       	and	r26, r16
     a98:	b1 23       	and	r27, r17
     a9a:	00 97       	sbiw	r24, 0x00	; 0
     a9c:	a1 05       	cpc	r26, r1
     a9e:	b1 05       	cpc	r27, r1
     aa0:	21 f0       	breq	.+8      	; 0xaaa <__pack_f+0xbe>
     aa2:	81 e0       	ldi	r24, 0x01	; 1
     aa4:	90 e0       	ldi	r25, 0x00	; 0
     aa6:	a0 e0       	ldi	r26, 0x00	; 0
     aa8:	b0 e0       	ldi	r27, 0x00	; 0
     aaa:	9a 01       	movw	r18, r20
     aac:	ab 01       	movw	r20, r22
     aae:	28 2b       	or	r18, r24
     ab0:	39 2b       	or	r19, r25
     ab2:	4a 2b       	or	r20, r26
     ab4:	5b 2b       	or	r21, r27
     ab6:	da 01       	movw	r26, r20
     ab8:	c9 01       	movw	r24, r18
     aba:	8f 77       	andi	r24, 0x7F	; 127
     abc:	90 70       	andi	r25, 0x00	; 0
     abe:	a0 70       	andi	r26, 0x00	; 0
     ac0:	b0 70       	andi	r27, 0x00	; 0
     ac2:	80 34       	cpi	r24, 0x40	; 64
     ac4:	91 05       	cpc	r25, r1
     ac6:	a1 05       	cpc	r26, r1
     ac8:	b1 05       	cpc	r27, r1
     aca:	39 f4       	brne	.+14     	; 0xada <__pack_f+0xee>
     acc:	27 ff       	sbrs	r18, 7
     ace:	09 c0       	rjmp	.+18     	; 0xae2 <__pack_f+0xf6>
     ad0:	20 5c       	subi	r18, 0xC0	; 192
     ad2:	3f 4f       	sbci	r19, 0xFF	; 255
     ad4:	4f 4f       	sbci	r20, 0xFF	; 255
     ad6:	5f 4f       	sbci	r21, 0xFF	; 255
     ad8:	04 c0       	rjmp	.+8      	; 0xae2 <__pack_f+0xf6>
     ada:	21 5c       	subi	r18, 0xC1	; 193
     adc:	3f 4f       	sbci	r19, 0xFF	; 255
     ade:	4f 4f       	sbci	r20, 0xFF	; 255
     ae0:	5f 4f       	sbci	r21, 0xFF	; 255
     ae2:	e0 e0       	ldi	r30, 0x00	; 0
     ae4:	f0 e0       	ldi	r31, 0x00	; 0
     ae6:	20 30       	cpi	r18, 0x00	; 0
     ae8:	a0 e0       	ldi	r26, 0x00	; 0
     aea:	3a 07       	cpc	r19, r26
     aec:	a0 e0       	ldi	r26, 0x00	; 0
     aee:	4a 07       	cpc	r20, r26
     af0:	a0 e4       	ldi	r26, 0x40	; 64
     af2:	5a 07       	cpc	r21, r26
     af4:	10 f0       	brcs	.+4      	; 0xafa <__pack_f+0x10e>
     af6:	e1 e0       	ldi	r30, 0x01	; 1
     af8:	f0 e0       	ldi	r31, 0x00	; 0
     afa:	79 01       	movw	r14, r18
     afc:	8a 01       	movw	r16, r20
     afe:	27 c0       	rjmp	.+78     	; 0xb4e <__pack_f+0x162>
     b00:	60 38       	cpi	r22, 0x80	; 128
     b02:	71 05       	cpc	r23, r1
     b04:	64 f5       	brge	.+88     	; 0xb5e <__pack_f+0x172>
     b06:	fb 01       	movw	r30, r22
     b08:	e1 58       	subi	r30, 0x81	; 129
     b0a:	ff 4f       	sbci	r31, 0xFF	; 255
     b0c:	d8 01       	movw	r26, r16
     b0e:	c7 01       	movw	r24, r14
     b10:	8f 77       	andi	r24, 0x7F	; 127
     b12:	90 70       	andi	r25, 0x00	; 0
     b14:	a0 70       	andi	r26, 0x00	; 0
     b16:	b0 70       	andi	r27, 0x00	; 0
     b18:	80 34       	cpi	r24, 0x40	; 64
     b1a:	91 05       	cpc	r25, r1
     b1c:	a1 05       	cpc	r26, r1
     b1e:	b1 05       	cpc	r27, r1
     b20:	39 f4       	brne	.+14     	; 0xb30 <__pack_f+0x144>
     b22:	e7 fe       	sbrs	r14, 7
     b24:	0d c0       	rjmp	.+26     	; 0xb40 <__pack_f+0x154>
     b26:	80 e4       	ldi	r24, 0x40	; 64
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	a0 e0       	ldi	r26, 0x00	; 0
     b2c:	b0 e0       	ldi	r27, 0x00	; 0
     b2e:	04 c0       	rjmp	.+8      	; 0xb38 <__pack_f+0x14c>
     b30:	8f e3       	ldi	r24, 0x3F	; 63
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	a0 e0       	ldi	r26, 0x00	; 0
     b36:	b0 e0       	ldi	r27, 0x00	; 0
     b38:	e8 0e       	add	r14, r24
     b3a:	f9 1e       	adc	r15, r25
     b3c:	0a 1f       	adc	r16, r26
     b3e:	1b 1f       	adc	r17, r27
     b40:	17 ff       	sbrs	r17, 7
     b42:	05 c0       	rjmp	.+10     	; 0xb4e <__pack_f+0x162>
     b44:	16 95       	lsr	r17
     b46:	07 95       	ror	r16
     b48:	f7 94       	ror	r15
     b4a:	e7 94       	ror	r14
     b4c:	31 96       	adiw	r30, 0x01	; 1
     b4e:	87 e0       	ldi	r24, 0x07	; 7
     b50:	16 95       	lsr	r17
     b52:	07 95       	ror	r16
     b54:	f7 94       	ror	r15
     b56:	e7 94       	ror	r14
     b58:	8a 95       	dec	r24
     b5a:	d1 f7       	brne	.-12     	; 0xb50 <__pack_f+0x164>
     b5c:	05 c0       	rjmp	.+10     	; 0xb68 <__pack_f+0x17c>
     b5e:	ee 24       	eor	r14, r14
     b60:	ff 24       	eor	r15, r15
     b62:	87 01       	movw	r16, r14
     b64:	ef ef       	ldi	r30, 0xFF	; 255
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	6e 2f       	mov	r22, r30
     b6a:	67 95       	ror	r22
     b6c:	66 27       	eor	r22, r22
     b6e:	67 95       	ror	r22
     b70:	90 2f       	mov	r25, r16
     b72:	9f 77       	andi	r25, 0x7F	; 127
     b74:	d7 94       	ror	r13
     b76:	dd 24       	eor	r13, r13
     b78:	d7 94       	ror	r13
     b7a:	8e 2f       	mov	r24, r30
     b7c:	86 95       	lsr	r24
     b7e:	49 2f       	mov	r20, r25
     b80:	46 2b       	or	r20, r22
     b82:	58 2f       	mov	r21, r24
     b84:	5d 29       	or	r21, r13
     b86:	b7 01       	movw	r22, r14
     b88:	ca 01       	movw	r24, r20
     b8a:	1f 91       	pop	r17
     b8c:	0f 91       	pop	r16
     b8e:	ff 90       	pop	r15
     b90:	ef 90       	pop	r14
     b92:	df 90       	pop	r13
     b94:	08 95       	ret

00000b96 <__unpack_f>:
     b96:	fc 01       	movw	r30, r24
     b98:	db 01       	movw	r26, r22
     b9a:	40 81       	ld	r20, Z
     b9c:	51 81       	ldd	r21, Z+1	; 0x01
     b9e:	22 81       	ldd	r18, Z+2	; 0x02
     ba0:	62 2f       	mov	r22, r18
     ba2:	6f 77       	andi	r22, 0x7F	; 127
     ba4:	70 e0       	ldi	r23, 0x00	; 0
     ba6:	22 1f       	adc	r18, r18
     ba8:	22 27       	eor	r18, r18
     baa:	22 1f       	adc	r18, r18
     bac:	93 81       	ldd	r25, Z+3	; 0x03
     bae:	89 2f       	mov	r24, r25
     bb0:	88 0f       	add	r24, r24
     bb2:	82 2b       	or	r24, r18
     bb4:	28 2f       	mov	r18, r24
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	99 1f       	adc	r25, r25
     bba:	99 27       	eor	r25, r25
     bbc:	99 1f       	adc	r25, r25
     bbe:	11 96       	adiw	r26, 0x01	; 1
     bc0:	9c 93       	st	X, r25
     bc2:	11 97       	sbiw	r26, 0x01	; 1
     bc4:	21 15       	cp	r18, r1
     bc6:	31 05       	cpc	r19, r1
     bc8:	a9 f5       	brne	.+106    	; 0xc34 <__unpack_f+0x9e>
     bca:	41 15       	cp	r20, r1
     bcc:	51 05       	cpc	r21, r1
     bce:	61 05       	cpc	r22, r1
     bd0:	71 05       	cpc	r23, r1
     bd2:	11 f4       	brne	.+4      	; 0xbd8 <__unpack_f+0x42>
     bd4:	82 e0       	ldi	r24, 0x02	; 2
     bd6:	37 c0       	rjmp	.+110    	; 0xc46 <__unpack_f+0xb0>
     bd8:	82 e8       	ldi	r24, 0x82	; 130
     bda:	9f ef       	ldi	r25, 0xFF	; 255
     bdc:	13 96       	adiw	r26, 0x03	; 3
     bde:	9c 93       	st	X, r25
     be0:	8e 93       	st	-X, r24
     be2:	12 97       	sbiw	r26, 0x02	; 2
     be4:	9a 01       	movw	r18, r20
     be6:	ab 01       	movw	r20, r22
     be8:	67 e0       	ldi	r22, 0x07	; 7
     bea:	22 0f       	add	r18, r18
     bec:	33 1f       	adc	r19, r19
     bee:	44 1f       	adc	r20, r20
     bf0:	55 1f       	adc	r21, r21
     bf2:	6a 95       	dec	r22
     bf4:	d1 f7       	brne	.-12     	; 0xbea <__unpack_f+0x54>
     bf6:	83 e0       	ldi	r24, 0x03	; 3
     bf8:	8c 93       	st	X, r24
     bfa:	0d c0       	rjmp	.+26     	; 0xc16 <__unpack_f+0x80>
     bfc:	22 0f       	add	r18, r18
     bfe:	33 1f       	adc	r19, r19
     c00:	44 1f       	adc	r20, r20
     c02:	55 1f       	adc	r21, r21
     c04:	12 96       	adiw	r26, 0x02	; 2
     c06:	8d 91       	ld	r24, X+
     c08:	9c 91       	ld	r25, X
     c0a:	13 97       	sbiw	r26, 0x03	; 3
     c0c:	01 97       	sbiw	r24, 0x01	; 1
     c0e:	13 96       	adiw	r26, 0x03	; 3
     c10:	9c 93       	st	X, r25
     c12:	8e 93       	st	-X, r24
     c14:	12 97       	sbiw	r26, 0x02	; 2
     c16:	20 30       	cpi	r18, 0x00	; 0
     c18:	80 e0       	ldi	r24, 0x00	; 0
     c1a:	38 07       	cpc	r19, r24
     c1c:	80 e0       	ldi	r24, 0x00	; 0
     c1e:	48 07       	cpc	r20, r24
     c20:	80 e4       	ldi	r24, 0x40	; 64
     c22:	58 07       	cpc	r21, r24
     c24:	58 f3       	brcs	.-42     	; 0xbfc <__unpack_f+0x66>
     c26:	14 96       	adiw	r26, 0x04	; 4
     c28:	2d 93       	st	X+, r18
     c2a:	3d 93       	st	X+, r19
     c2c:	4d 93       	st	X+, r20
     c2e:	5c 93       	st	X, r21
     c30:	17 97       	sbiw	r26, 0x07	; 7
     c32:	08 95       	ret
     c34:	2f 3f       	cpi	r18, 0xFF	; 255
     c36:	31 05       	cpc	r19, r1
     c38:	79 f4       	brne	.+30     	; 0xc58 <__unpack_f+0xc2>
     c3a:	41 15       	cp	r20, r1
     c3c:	51 05       	cpc	r21, r1
     c3e:	61 05       	cpc	r22, r1
     c40:	71 05       	cpc	r23, r1
     c42:	19 f4       	brne	.+6      	; 0xc4a <__unpack_f+0xb4>
     c44:	84 e0       	ldi	r24, 0x04	; 4
     c46:	8c 93       	st	X, r24
     c48:	08 95       	ret
     c4a:	64 ff       	sbrs	r22, 4
     c4c:	03 c0       	rjmp	.+6      	; 0xc54 <__unpack_f+0xbe>
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	8c 93       	st	X, r24
     c52:	12 c0       	rjmp	.+36     	; 0xc78 <__unpack_f+0xe2>
     c54:	1c 92       	st	X, r1
     c56:	10 c0       	rjmp	.+32     	; 0xc78 <__unpack_f+0xe2>
     c58:	2f 57       	subi	r18, 0x7F	; 127
     c5a:	30 40       	sbci	r19, 0x00	; 0
     c5c:	13 96       	adiw	r26, 0x03	; 3
     c5e:	3c 93       	st	X, r19
     c60:	2e 93       	st	-X, r18
     c62:	12 97       	sbiw	r26, 0x02	; 2
     c64:	83 e0       	ldi	r24, 0x03	; 3
     c66:	8c 93       	st	X, r24
     c68:	87 e0       	ldi	r24, 0x07	; 7
     c6a:	44 0f       	add	r20, r20
     c6c:	55 1f       	adc	r21, r21
     c6e:	66 1f       	adc	r22, r22
     c70:	77 1f       	adc	r23, r23
     c72:	8a 95       	dec	r24
     c74:	d1 f7       	brne	.-12     	; 0xc6a <__unpack_f+0xd4>
     c76:	70 64       	ori	r23, 0x40	; 64
     c78:	14 96       	adiw	r26, 0x04	; 4
     c7a:	4d 93       	st	X+, r20
     c7c:	5d 93       	st	X+, r21
     c7e:	6d 93       	st	X+, r22
     c80:	7c 93       	st	X, r23
     c82:	17 97       	sbiw	r26, 0x07	; 7
     c84:	08 95       	ret

00000c86 <__fpcmp_parts_f>:
     c86:	1f 93       	push	r17
     c88:	dc 01       	movw	r26, r24
     c8a:	fb 01       	movw	r30, r22
     c8c:	9c 91       	ld	r25, X
     c8e:	92 30       	cpi	r25, 0x02	; 2
     c90:	08 f4       	brcc	.+2      	; 0xc94 <__fpcmp_parts_f+0xe>
     c92:	47 c0       	rjmp	.+142    	; 0xd22 <__fpcmp_parts_f+0x9c>
     c94:	80 81       	ld	r24, Z
     c96:	82 30       	cpi	r24, 0x02	; 2
     c98:	08 f4       	brcc	.+2      	; 0xc9c <__fpcmp_parts_f+0x16>
     c9a:	43 c0       	rjmp	.+134    	; 0xd22 <__fpcmp_parts_f+0x9c>
     c9c:	94 30       	cpi	r25, 0x04	; 4
     c9e:	51 f4       	brne	.+20     	; 0xcb4 <__fpcmp_parts_f+0x2e>
     ca0:	11 96       	adiw	r26, 0x01	; 1
     ca2:	1c 91       	ld	r17, X
     ca4:	84 30       	cpi	r24, 0x04	; 4
     ca6:	99 f5       	brne	.+102    	; 0xd0e <__fpcmp_parts_f+0x88>
     ca8:	81 81       	ldd	r24, Z+1	; 0x01
     caa:	68 2f       	mov	r22, r24
     cac:	70 e0       	ldi	r23, 0x00	; 0
     cae:	61 1b       	sub	r22, r17
     cb0:	71 09       	sbc	r23, r1
     cb2:	3f c0       	rjmp	.+126    	; 0xd32 <__fpcmp_parts_f+0xac>
     cb4:	84 30       	cpi	r24, 0x04	; 4
     cb6:	21 f0       	breq	.+8      	; 0xcc0 <__fpcmp_parts_f+0x3a>
     cb8:	92 30       	cpi	r25, 0x02	; 2
     cba:	31 f4       	brne	.+12     	; 0xcc8 <__fpcmp_parts_f+0x42>
     cbc:	82 30       	cpi	r24, 0x02	; 2
     cbe:	b9 f1       	breq	.+110    	; 0xd2e <__fpcmp_parts_f+0xa8>
     cc0:	81 81       	ldd	r24, Z+1	; 0x01
     cc2:	88 23       	and	r24, r24
     cc4:	89 f1       	breq	.+98     	; 0xd28 <__fpcmp_parts_f+0xa2>
     cc6:	2d c0       	rjmp	.+90     	; 0xd22 <__fpcmp_parts_f+0x9c>
     cc8:	11 96       	adiw	r26, 0x01	; 1
     cca:	1c 91       	ld	r17, X
     ccc:	11 97       	sbiw	r26, 0x01	; 1
     cce:	82 30       	cpi	r24, 0x02	; 2
     cd0:	f1 f0       	breq	.+60     	; 0xd0e <__fpcmp_parts_f+0x88>
     cd2:	81 81       	ldd	r24, Z+1	; 0x01
     cd4:	18 17       	cp	r17, r24
     cd6:	d9 f4       	brne	.+54     	; 0xd0e <__fpcmp_parts_f+0x88>
     cd8:	12 96       	adiw	r26, 0x02	; 2
     cda:	2d 91       	ld	r18, X+
     cdc:	3c 91       	ld	r19, X
     cde:	13 97       	sbiw	r26, 0x03	; 3
     ce0:	82 81       	ldd	r24, Z+2	; 0x02
     ce2:	93 81       	ldd	r25, Z+3	; 0x03
     ce4:	82 17       	cp	r24, r18
     ce6:	93 07       	cpc	r25, r19
     ce8:	94 f0       	brlt	.+36     	; 0xd0e <__fpcmp_parts_f+0x88>
     cea:	28 17       	cp	r18, r24
     cec:	39 07       	cpc	r19, r25
     cee:	bc f0       	brlt	.+46     	; 0xd1e <__fpcmp_parts_f+0x98>
     cf0:	14 96       	adiw	r26, 0x04	; 4
     cf2:	8d 91       	ld	r24, X+
     cf4:	9d 91       	ld	r25, X+
     cf6:	0d 90       	ld	r0, X+
     cf8:	bc 91       	ld	r27, X
     cfa:	a0 2d       	mov	r26, r0
     cfc:	24 81       	ldd	r18, Z+4	; 0x04
     cfe:	35 81       	ldd	r19, Z+5	; 0x05
     d00:	46 81       	ldd	r20, Z+6	; 0x06
     d02:	57 81       	ldd	r21, Z+7	; 0x07
     d04:	28 17       	cp	r18, r24
     d06:	39 07       	cpc	r19, r25
     d08:	4a 07       	cpc	r20, r26
     d0a:	5b 07       	cpc	r21, r27
     d0c:	18 f4       	brcc	.+6      	; 0xd14 <__fpcmp_parts_f+0x8e>
     d0e:	11 23       	and	r17, r17
     d10:	41 f0       	breq	.+16     	; 0xd22 <__fpcmp_parts_f+0x9c>
     d12:	0a c0       	rjmp	.+20     	; 0xd28 <__fpcmp_parts_f+0xa2>
     d14:	82 17       	cp	r24, r18
     d16:	93 07       	cpc	r25, r19
     d18:	a4 07       	cpc	r26, r20
     d1a:	b5 07       	cpc	r27, r21
     d1c:	40 f4       	brcc	.+16     	; 0xd2e <__fpcmp_parts_f+0xa8>
     d1e:	11 23       	and	r17, r17
     d20:	19 f0       	breq	.+6      	; 0xd28 <__fpcmp_parts_f+0xa2>
     d22:	61 e0       	ldi	r22, 0x01	; 1
     d24:	70 e0       	ldi	r23, 0x00	; 0
     d26:	05 c0       	rjmp	.+10     	; 0xd32 <__fpcmp_parts_f+0xac>
     d28:	6f ef       	ldi	r22, 0xFF	; 255
     d2a:	7f ef       	ldi	r23, 0xFF	; 255
     d2c:	02 c0       	rjmp	.+4      	; 0xd32 <__fpcmp_parts_f+0xac>
     d2e:	60 e0       	ldi	r22, 0x00	; 0
     d30:	70 e0       	ldi	r23, 0x00	; 0
     d32:	cb 01       	movw	r24, r22
     d34:	1f 91       	pop	r17
     d36:	08 95       	ret

00000d38 <ADC_Vid_Init>:



void ADC_Vid_Init(){

	CLR_BIT(ADMUX, ADMUX_REFS0);
     d38:	3e 98       	cbi	0x07, 6	; 7
	CLR_BIT(ADMUX, ADMUX_REFS1);
     d3a:	3f 98       	cbi	0x07, 7	; 7
	/* for right adj */
	CLR_BIT(ADMUX, ADMUX_ADLAR);
     d3c:	3d 98       	cbi	0x07, 5	; 7

	ADCSRA &= 0b11111000;
     d3e:	86 b1       	in	r24, 0x06	; 6
     d40:	88 7f       	andi	r24, 0xF8	; 248
     d42:	86 b9       	out	0x06, r24	; 6
	ADCSRA |= PRESCALER_VALUE;
     d44:	86 b1       	in	r24, 0x06	; 6
     d46:	87 60       	ori	r24, 0x07	; 7
     d48:	86 b9       	out	0x06, r24	; 6

	SET_BIT(ADCSRA, ADCSRA_ADEN);
     d4a:	37 9a       	sbi	0x06, 7	; 6
	Set(ADCSRA, ADCSRA_ADPS0);
	Set(ADCSRA, ADCSRA_ADPS1);
	Set(ADCSRA, ADCSRA_ADPS2);
	*/

}
     d4c:	08 95       	ret

00000d4e <ADC_vid_getADCValue_Sync>:


u16 ADC_vid_getADCValue_Sync(u8 Copy_u8Channel){

	ADMUX &= 0b11100000;
     d4e:	97 b1       	in	r25, 0x07	; 7
     d50:	90 7e       	andi	r25, 0xE0	; 224
     d52:	97 b9       	out	0x07, r25	; 7
	ADMUX |= Copy_u8Channel;
     d54:	97 b1       	in	r25, 0x07	; 7
     d56:	98 2b       	or	r25, r24
     d58:	97 b9       	out	0x07, r25	; 7

	/*Start Conversion*/

	SET_BIT(ADCSRA, ADCSRA_ADSC);
     d5a:	36 9a       	sbi	0x06, 6	; 6
	/*Check that the conversion completed*/
	while(GET_BIT(ADCSRA,ADCSRA_ADIF) == 0);
     d5c:	34 9b       	sbis	0x06, 4	; 6
     d5e:	fe cf       	rjmp	.-4      	; 0xd5c <ADC_vid_getADCValue_Sync+0xe>

	SET_BIT(ADCSRA,ADCSRA_ADIF);
     d60:	34 9a       	sbi	0x06, 4	; 6

	return ADCL;
     d62:	24 b1       	in	r18, 0x04	; 4
     d64:	35 b1       	in	r19, 0x05	; 5
}
     d66:	c9 01       	movw	r24, r18
     d68:	08 95       	ret

00000d6a <Temp_ADC_read>:


signed int Temp_ADC_read(void)     //Read Analog Value of Temp Sensor
{
	ADMUX=0;                        //use ADC0
     d6a:	17 b8       	out	0x07, r1	; 7
	SET_BIT(ADCSRA,4);               // clear flag
     d6c:	34 9a       	sbi	0x06, 4	; 6
	SET_BIT(ADCSRA,6);               //start conversion bit register
     d6e:	36 9a       	sbi	0x06, 6	; 6
	while(GET_BIT(ADCSRA,4)==0){ }; //wait for conversion till flag became one
     d70:	34 9b       	sbis	0x06, 4	; 6
     d72:	fe cf       	rjmp	.-4      	; 0xd70 <Temp_ADC_read+0x6>
    return ADCL;
     d74:	24 b1       	in	r18, 0x04	; 4
     d76:	35 b1       	in	r19, 0x05	; 5
}
     d78:	c9 01       	movw	r24, r18
     d7a:	08 95       	ret

00000d7c <DIO_Vid_SetPinDirection>:


/*Setting pin Direction*/
void DIO_Vid_SetPinDirection(u8 Copy_u8Port, u8 Copy_u8Pin, u8 Copy_u8Direction){
	
	if(Copy_u8Direction == input){
     d7c:	44 23       	and	r20, r20
     d7e:	d1 f5       	brne	.+116    	; 0xdf4 <DIO_Vid_SetPinDirection+0x78>
		switch (Copy_u8Port){
     d80:	81 30       	cpi	r24, 0x01	; 1
     d82:	a1 f0       	breq	.+40     	; 0xdac <DIO_Vid_SetPinDirection+0x30>
     d84:	81 30       	cpi	r24, 0x01	; 1
     d86:	30 f0       	brcs	.+12     	; 0xd94 <DIO_Vid_SetPinDirection+0x18>
     d88:	82 30       	cpi	r24, 0x02	; 2
     d8a:	e1 f0       	breq	.+56     	; 0xdc4 <DIO_Vid_SetPinDirection+0x48>
     d8c:	83 30       	cpi	r24, 0x03	; 3
     d8e:	09 f0       	breq	.+2      	; 0xd92 <DIO_Vid_SetPinDirection+0x16>
     d90:	67 c0       	rjmp	.+206    	; 0xe60 <DIO_Vid_SetPinDirection+0xe4>
     d92:	24 c0       	rjmp	.+72     	; 0xddc <DIO_Vid_SetPinDirection+0x60>
			case Port_A : CLR_BIT(DDRA , Copy_u8Pin); break;
     d94:	2a b3       	in	r18, 0x1a	; 26
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	02 c0       	rjmp	.+4      	; 0xda0 <DIO_Vid_SetPinDirection+0x24>
     d9c:	88 0f       	add	r24, r24
     d9e:	99 1f       	adc	r25, r25
     da0:	6a 95       	dec	r22
     da2:	e2 f7       	brpl	.-8      	; 0xd9c <DIO_Vid_SetPinDirection+0x20>
     da4:	80 95       	com	r24
     da6:	82 23       	and	r24, r18
     da8:	8a bb       	out	0x1a, r24	; 26
     daa:	08 95       	ret
			case Port_B : CLR_BIT(DDRB , Copy_u8Pin); break;
     dac:	27 b3       	in	r18, 0x17	; 23
     dae:	81 e0       	ldi	r24, 0x01	; 1
     db0:	90 e0       	ldi	r25, 0x00	; 0
     db2:	02 c0       	rjmp	.+4      	; 0xdb8 <DIO_Vid_SetPinDirection+0x3c>
     db4:	88 0f       	add	r24, r24
     db6:	99 1f       	adc	r25, r25
     db8:	6a 95       	dec	r22
     dba:	e2 f7       	brpl	.-8      	; 0xdb4 <DIO_Vid_SetPinDirection+0x38>
     dbc:	80 95       	com	r24
     dbe:	82 23       	and	r24, r18
     dc0:	87 bb       	out	0x17, r24	; 23
     dc2:	08 95       	ret
			case Port_C : CLR_BIT(DDRC , Copy_u8Pin); break;
     dc4:	24 b3       	in	r18, 0x14	; 20
     dc6:	81 e0       	ldi	r24, 0x01	; 1
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	02 c0       	rjmp	.+4      	; 0xdd0 <DIO_Vid_SetPinDirection+0x54>
     dcc:	88 0f       	add	r24, r24
     dce:	99 1f       	adc	r25, r25
     dd0:	6a 95       	dec	r22
     dd2:	e2 f7       	brpl	.-8      	; 0xdcc <DIO_Vid_SetPinDirection+0x50>
     dd4:	80 95       	com	r24
     dd6:	82 23       	and	r24, r18
     dd8:	84 bb       	out	0x14, r24	; 20
     dda:	08 95       	ret
			case Port_D : CLR_BIT(DDRD , Copy_u8Pin); break;
     ddc:	21 b3       	in	r18, 0x11	; 17
     dde:	81 e0       	ldi	r24, 0x01	; 1
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	02 c0       	rjmp	.+4      	; 0xde8 <DIO_Vid_SetPinDirection+0x6c>
     de4:	88 0f       	add	r24, r24
     de6:	99 1f       	adc	r25, r25
     de8:	6a 95       	dec	r22
     dea:	e2 f7       	brpl	.-8      	; 0xde4 <DIO_Vid_SetPinDirection+0x68>
     dec:	80 95       	com	r24
     dee:	82 23       	and	r24, r18
     df0:	81 bb       	out	0x11, r24	; 17
     df2:	08 95       	ret

		}
	}
	else if(Copy_u8Direction == output){
     df4:	41 30       	cpi	r20, 0x01	; 1
     df6:	a1 f5       	brne	.+104    	; 0xe60 <DIO_Vid_SetPinDirection+0xe4>
		switch (Copy_u8Port){
     df8:	81 30       	cpi	r24, 0x01	; 1
     dfa:	91 f0       	breq	.+36     	; 0xe20 <DIO_Vid_SetPinDirection+0xa4>
     dfc:	81 30       	cpi	r24, 0x01	; 1
     dfe:	28 f0       	brcs	.+10     	; 0xe0a <DIO_Vid_SetPinDirection+0x8e>
     e00:	82 30       	cpi	r24, 0x02	; 2
     e02:	c9 f0       	breq	.+50     	; 0xe36 <DIO_Vid_SetPinDirection+0xba>
     e04:	83 30       	cpi	r24, 0x03	; 3
     e06:	61 f5       	brne	.+88     	; 0xe60 <DIO_Vid_SetPinDirection+0xe4>
     e08:	21 c0       	rjmp	.+66     	; 0xe4c <DIO_Vid_SetPinDirection+0xd0>
			case Port_A : SET_BIT(DDRA , Copy_u8Pin); break;
     e0a:	2a b3       	in	r18, 0x1a	; 26
     e0c:	81 e0       	ldi	r24, 0x01	; 1
     e0e:	90 e0       	ldi	r25, 0x00	; 0
     e10:	02 c0       	rjmp	.+4      	; 0xe16 <DIO_Vid_SetPinDirection+0x9a>
     e12:	88 0f       	add	r24, r24
     e14:	99 1f       	adc	r25, r25
     e16:	6a 95       	dec	r22
     e18:	e2 f7       	brpl	.-8      	; 0xe12 <DIO_Vid_SetPinDirection+0x96>
     e1a:	28 2b       	or	r18, r24
     e1c:	2a bb       	out	0x1a, r18	; 26
     e1e:	08 95       	ret
			case Port_B : SET_BIT(DDRB , Copy_u8Pin); break;
     e20:	27 b3       	in	r18, 0x17	; 23
     e22:	81 e0       	ldi	r24, 0x01	; 1
     e24:	90 e0       	ldi	r25, 0x00	; 0
     e26:	02 c0       	rjmp	.+4      	; 0xe2c <DIO_Vid_SetPinDirection+0xb0>
     e28:	88 0f       	add	r24, r24
     e2a:	99 1f       	adc	r25, r25
     e2c:	6a 95       	dec	r22
     e2e:	e2 f7       	brpl	.-8      	; 0xe28 <DIO_Vid_SetPinDirection+0xac>
     e30:	28 2b       	or	r18, r24
     e32:	27 bb       	out	0x17, r18	; 23
     e34:	08 95       	ret
			case Port_C : SET_BIT(DDRC , Copy_u8Pin); break;
     e36:	24 b3       	in	r18, 0x14	; 20
     e38:	81 e0       	ldi	r24, 0x01	; 1
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	02 c0       	rjmp	.+4      	; 0xe42 <DIO_Vid_SetPinDirection+0xc6>
     e3e:	88 0f       	add	r24, r24
     e40:	99 1f       	adc	r25, r25
     e42:	6a 95       	dec	r22
     e44:	e2 f7       	brpl	.-8      	; 0xe3e <DIO_Vid_SetPinDirection+0xc2>
     e46:	28 2b       	or	r18, r24
     e48:	24 bb       	out	0x14, r18	; 20
     e4a:	08 95       	ret
			case Port_D : SET_BIT(DDRD , Copy_u8Pin); break;
     e4c:	21 b3       	in	r18, 0x11	; 17
     e4e:	81 e0       	ldi	r24, 0x01	; 1
     e50:	90 e0       	ldi	r25, 0x00	; 0
     e52:	02 c0       	rjmp	.+4      	; 0xe58 <DIO_Vid_SetPinDirection+0xdc>
     e54:	88 0f       	add	r24, r24
     e56:	99 1f       	adc	r25, r25
     e58:	6a 95       	dec	r22
     e5a:	e2 f7       	brpl	.-8      	; 0xe54 <DIO_Vid_SetPinDirection+0xd8>
     e5c:	28 2b       	or	r18, r24
     e5e:	21 bb       	out	0x11, r18	; 17
     e60:	08 95       	ret

00000e62 <DIO_Vid_SetPinValue>:
}

/*Setting pin Value*/
void DIO_Vid_SetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8 Copy_u8Value){
	
	if(Copy_u8Value == PinLow){
     e62:	44 23       	and	r20, r20
     e64:	d1 f5       	brne	.+116    	; 0xeda <DIO_Vid_SetPinValue+0x78>
		switch (Copy_u8Port){
     e66:	81 30       	cpi	r24, 0x01	; 1
     e68:	a1 f0       	breq	.+40     	; 0xe92 <DIO_Vid_SetPinValue+0x30>
     e6a:	81 30       	cpi	r24, 0x01	; 1
     e6c:	30 f0       	brcs	.+12     	; 0xe7a <DIO_Vid_SetPinValue+0x18>
     e6e:	82 30       	cpi	r24, 0x02	; 2
     e70:	e1 f0       	breq	.+56     	; 0xeaa <DIO_Vid_SetPinValue+0x48>
     e72:	83 30       	cpi	r24, 0x03	; 3
     e74:	09 f0       	breq	.+2      	; 0xe78 <DIO_Vid_SetPinValue+0x16>
     e76:	67 c0       	rjmp	.+206    	; 0xf46 <DIO_Vid_SetPinValue+0xe4>
     e78:	24 c0       	rjmp	.+72     	; 0xec2 <DIO_Vid_SetPinValue+0x60>
			case Port_A : CLR_BIT(PORTA , Copy_u8Pin); break;
     e7a:	2b b3       	in	r18, 0x1b	; 27
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	02 c0       	rjmp	.+4      	; 0xe86 <DIO_Vid_SetPinValue+0x24>
     e82:	88 0f       	add	r24, r24
     e84:	99 1f       	adc	r25, r25
     e86:	6a 95       	dec	r22
     e88:	e2 f7       	brpl	.-8      	; 0xe82 <DIO_Vid_SetPinValue+0x20>
     e8a:	80 95       	com	r24
     e8c:	82 23       	and	r24, r18
     e8e:	8b bb       	out	0x1b, r24	; 27
     e90:	08 95       	ret
			case Port_B : CLR_BIT(PORTB , Copy_u8Pin); break;
     e92:	28 b3       	in	r18, 0x18	; 24
     e94:	81 e0       	ldi	r24, 0x01	; 1
     e96:	90 e0       	ldi	r25, 0x00	; 0
     e98:	02 c0       	rjmp	.+4      	; 0xe9e <DIO_Vid_SetPinValue+0x3c>
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	6a 95       	dec	r22
     ea0:	e2 f7       	brpl	.-8      	; 0xe9a <DIO_Vid_SetPinValue+0x38>
     ea2:	80 95       	com	r24
     ea4:	82 23       	and	r24, r18
     ea6:	88 bb       	out	0x18, r24	; 24
     ea8:	08 95       	ret
			case Port_C : CLR_BIT(PORTC , Copy_u8Pin); break;
     eaa:	25 b3       	in	r18, 0x15	; 21
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	90 e0       	ldi	r25, 0x00	; 0
     eb0:	02 c0       	rjmp	.+4      	; 0xeb6 <DIO_Vid_SetPinValue+0x54>
     eb2:	88 0f       	add	r24, r24
     eb4:	99 1f       	adc	r25, r25
     eb6:	6a 95       	dec	r22
     eb8:	e2 f7       	brpl	.-8      	; 0xeb2 <DIO_Vid_SetPinValue+0x50>
     eba:	80 95       	com	r24
     ebc:	82 23       	and	r24, r18
     ebe:	85 bb       	out	0x15, r24	; 21
     ec0:	08 95       	ret
			case Port_D : CLR_BIT(PORTD , Copy_u8Pin); break;
     ec2:	22 b3       	in	r18, 0x12	; 18
     ec4:	81 e0       	ldi	r24, 0x01	; 1
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	02 c0       	rjmp	.+4      	; 0xece <DIO_Vid_SetPinValue+0x6c>
     eca:	88 0f       	add	r24, r24
     ecc:	99 1f       	adc	r25, r25
     ece:	6a 95       	dec	r22
     ed0:	e2 f7       	brpl	.-8      	; 0xeca <DIO_Vid_SetPinValue+0x68>
     ed2:	80 95       	com	r24
     ed4:	82 23       	and	r24, r18
     ed6:	82 bb       	out	0x12, r24	; 18
     ed8:	08 95       	ret

		}
	}
	else if(Copy_u8Value == PinHigh){
     eda:	41 30       	cpi	r20, 0x01	; 1
     edc:	a1 f5       	brne	.+104    	; 0xf46 <DIO_Vid_SetPinValue+0xe4>
		switch (Copy_u8Port){
     ede:	81 30       	cpi	r24, 0x01	; 1
     ee0:	91 f0       	breq	.+36     	; 0xf06 <DIO_Vid_SetPinValue+0xa4>
     ee2:	81 30       	cpi	r24, 0x01	; 1
     ee4:	28 f0       	brcs	.+10     	; 0xef0 <DIO_Vid_SetPinValue+0x8e>
     ee6:	82 30       	cpi	r24, 0x02	; 2
     ee8:	c9 f0       	breq	.+50     	; 0xf1c <DIO_Vid_SetPinValue+0xba>
     eea:	83 30       	cpi	r24, 0x03	; 3
     eec:	61 f5       	brne	.+88     	; 0xf46 <DIO_Vid_SetPinValue+0xe4>
     eee:	21 c0       	rjmp	.+66     	; 0xf32 <DIO_Vid_SetPinValue+0xd0>
			case Port_A : SET_BIT(PORTA , Copy_u8Pin); break;
     ef0:	2b b3       	in	r18, 0x1b	; 27
     ef2:	81 e0       	ldi	r24, 0x01	; 1
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	02 c0       	rjmp	.+4      	; 0xefc <DIO_Vid_SetPinValue+0x9a>
     ef8:	88 0f       	add	r24, r24
     efa:	99 1f       	adc	r25, r25
     efc:	6a 95       	dec	r22
     efe:	e2 f7       	brpl	.-8      	; 0xef8 <DIO_Vid_SetPinValue+0x96>
     f00:	28 2b       	or	r18, r24
     f02:	2b bb       	out	0x1b, r18	; 27
     f04:	08 95       	ret
			case Port_B : SET_BIT(PORTB , Copy_u8Pin); break;
     f06:	28 b3       	in	r18, 0x18	; 24
     f08:	81 e0       	ldi	r24, 0x01	; 1
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	02 c0       	rjmp	.+4      	; 0xf12 <DIO_Vid_SetPinValue+0xb0>
     f0e:	88 0f       	add	r24, r24
     f10:	99 1f       	adc	r25, r25
     f12:	6a 95       	dec	r22
     f14:	e2 f7       	brpl	.-8      	; 0xf0e <DIO_Vid_SetPinValue+0xac>
     f16:	28 2b       	or	r18, r24
     f18:	28 bb       	out	0x18, r18	; 24
     f1a:	08 95       	ret
			case Port_C : SET_BIT(PORTC , Copy_u8Pin); break;
     f1c:	25 b3       	in	r18, 0x15	; 21
     f1e:	81 e0       	ldi	r24, 0x01	; 1
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	02 c0       	rjmp	.+4      	; 0xf28 <DIO_Vid_SetPinValue+0xc6>
     f24:	88 0f       	add	r24, r24
     f26:	99 1f       	adc	r25, r25
     f28:	6a 95       	dec	r22
     f2a:	e2 f7       	brpl	.-8      	; 0xf24 <DIO_Vid_SetPinValue+0xc2>
     f2c:	28 2b       	or	r18, r24
     f2e:	25 bb       	out	0x15, r18	; 21
     f30:	08 95       	ret
			case Port_D : SET_BIT(PORTD , Copy_u8Pin); break;
     f32:	22 b3       	in	r18, 0x12	; 18
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	02 c0       	rjmp	.+4      	; 0xf3e <DIO_Vid_SetPinValue+0xdc>
     f3a:	88 0f       	add	r24, r24
     f3c:	99 1f       	adc	r25, r25
     f3e:	6a 95       	dec	r22
     f40:	e2 f7       	brpl	.-8      	; 0xf3a <DIO_Vid_SetPinValue+0xd8>
     f42:	28 2b       	or	r18, r24
     f44:	22 bb       	out	0x12, r18	; 18
     f46:	08 95       	ret

00000f48 <DIO_Vid_GetPinValue>:
		}
	}
}

/*Getting pin Value*/
void DIO_Vid_GetPinValue(u8 Copy_u8Port, u8 Copy_u8Pin, u8 *pu8Data){
     f48:	fa 01       	movw	r30, r20
	
	switch(Copy_u8Port){
     f4a:	81 30       	cpi	r24, 0x01	; 1
     f4c:	49 f0       	breq	.+18     	; 0xf60 <DIO_Vid_GetPinValue+0x18>
     f4e:	81 30       	cpi	r24, 0x01	; 1
     f50:	28 f0       	brcs	.+10     	; 0xf5c <DIO_Vid_GetPinValue+0x14>
     f52:	82 30       	cpi	r24, 0x02	; 2
     f54:	39 f0       	breq	.+14     	; 0xf64 <DIO_Vid_GetPinValue+0x1c>
     f56:	83 30       	cpi	r24, 0x03	; 3
     f58:	c1 f4       	brne	.+48     	; 0xf8a <DIO_Vid_GetPinValue+0x42>
     f5a:	0e c0       	rjmp	.+28     	; 0xf78 <DIO_Vid_GetPinValue+0x30>
		
		case Port_A : *pu8Data = GET_BIT(PINA , Copy_u8Pin); break;
     f5c:	89 b3       	in	r24, 0x19	; 25
     f5e:	03 c0       	rjmp	.+6      	; 0xf66 <DIO_Vid_GetPinValue+0x1e>
		case Port_B : *pu8Data = GET_BIT(PINB , Copy_u8Pin); break;
     f60:	86 b3       	in	r24, 0x16	; 22
     f62:	01 c0       	rjmp	.+2      	; 0xf66 <DIO_Vid_GetPinValue+0x1e>
		case Port_C : *pu8Data = GET_BIT(PINC , Copy_u8Pin); break;
     f64:	83 b3       	in	r24, 0x13	; 19
     f66:	90 e0       	ldi	r25, 0x00	; 0
     f68:	02 c0       	rjmp	.+4      	; 0xf6e <DIO_Vid_GetPinValue+0x26>
     f6a:	95 95       	asr	r25
     f6c:	87 95       	ror	r24
     f6e:	6a 95       	dec	r22
     f70:	e2 f7       	brpl	.-8      	; 0xf6a <DIO_Vid_GetPinValue+0x22>
     f72:	81 70       	andi	r24, 0x01	; 1
     f74:	80 83       	st	Z, r24
     f76:	08 95       	ret
		case Port_D : *pu8Data = GET_BIT(PIND , Copy_u8Pin); break;
     f78:	80 b3       	in	r24, 0x10	; 16
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <DIO_Vid_GetPinValue+0x3a>
     f7e:	95 95       	asr	r25
     f80:	87 95       	ror	r24
     f82:	6a 95       	dec	r22
     f84:	e2 f7       	brpl	.-8      	; 0xf7e <DIO_Vid_GetPinValue+0x36>
     f86:	81 70       	andi	r24, 0x01	; 1
     f88:	80 83       	st	Z, r24
     f8a:	08 95       	ret

00000f8c <DIO_Vid_SetPortDirection>:


/*Setting port Direction*/
void DIO_Vid_SetPortDirection(u8 Copy_u8Port, u8 Copy_u8Direction){
	
	if(Copy_u8Direction == output){
     f8c:	61 30       	cpi	r22, 0x01	; 1
     f8e:	a9 f4       	brne	.+42     	; 0xfba <DIO_Vid_SetPortDirection+0x2e>
			switch (Copy_u8Port){
     f90:	81 30       	cpi	r24, 0x01	; 1
     f92:	51 f0       	breq	.+20     	; 0xfa8 <DIO_Vid_SetPortDirection+0x1c>
     f94:	81 30       	cpi	r24, 0x01	; 1
     f96:	28 f0       	brcs	.+10     	; 0xfa2 <DIO_Vid_SetPortDirection+0x16>
     f98:	82 30       	cpi	r24, 0x02	; 2
     f9a:	49 f0       	breq	.+18     	; 0xfae <DIO_Vid_SetPortDirection+0x22>
     f9c:	83 30       	cpi	r24, 0x03	; 3
     f9e:	f9 f4       	brne	.+62     	; 0xfde <DIO_Vid_SetPortDirection+0x52>
     fa0:	09 c0       	rjmp	.+18     	; 0xfb4 <DIO_Vid_SetPortDirection+0x28>
				case Port_A : DDRA = 0b11111111; break;
     fa2:	8f ef       	ldi	r24, 0xFF	; 255
     fa4:	8a bb       	out	0x1a, r24	; 26
     fa6:	08 95       	ret
				case Port_B : DDRB = 0b11111111; break;
     fa8:	8f ef       	ldi	r24, 0xFF	; 255
     faa:	87 bb       	out	0x17, r24	; 23
     fac:	08 95       	ret
				case Port_C : DDRC = 0b11111111; break;
     fae:	8f ef       	ldi	r24, 0xFF	; 255
     fb0:	84 bb       	out	0x14, r24	; 20
     fb2:	08 95       	ret
				case Port_D : DDRD = 0b11111111; break;
     fb4:	8f ef       	ldi	r24, 0xFF	; 255
     fb6:	81 bb       	out	0x11, r24	; 17
     fb8:	08 95       	ret

			}
		}
		else if(Copy_u8Direction == input){
     fba:	66 23       	and	r22, r22
     fbc:	81 f4       	brne	.+32     	; 0xfde <DIO_Vid_SetPortDirection+0x52>
			switch (Copy_u8Port){
     fbe:	81 30       	cpi	r24, 0x01	; 1
     fc0:	49 f0       	breq	.+18     	; 0xfd4 <DIO_Vid_SetPortDirection+0x48>
     fc2:	81 30       	cpi	r24, 0x01	; 1
     fc4:	28 f0       	brcs	.+10     	; 0xfd0 <DIO_Vid_SetPortDirection+0x44>
     fc6:	82 30       	cpi	r24, 0x02	; 2
     fc8:	39 f0       	breq	.+14     	; 0xfd8 <DIO_Vid_SetPortDirection+0x4c>
     fca:	83 30       	cpi	r24, 0x03	; 3
     fcc:	41 f4       	brne	.+16     	; 0xfde <DIO_Vid_SetPortDirection+0x52>
     fce:	06 c0       	rjmp	.+12     	; 0xfdc <DIO_Vid_SetPortDirection+0x50>
				case Port_A : DDRA = 0b00000000; break;
     fd0:	1a ba       	out	0x1a, r1	; 26
     fd2:	08 95       	ret
				case Port_B : DDRB = 0b00000000; break;
     fd4:	17 ba       	out	0x17, r1	; 23
     fd6:	08 95       	ret
				case Port_C : DDRC = 0b00000000; break;
     fd8:	14 ba       	out	0x14, r1	; 20
     fda:	08 95       	ret
				case Port_D : DDRD = 0b00000000; break;
     fdc:	11 ba       	out	0x11, r1	; 17
     fde:	08 95       	ret

00000fe0 <DIO_Vid_SetPortValue>:
}


/*Setting port(port register) value*/
void DIO_Vid_SetPortValue(u8 Copy_u8Port, u8 Copy_u8Value){
	switch(Copy_u8Port){
     fe0:	81 30       	cpi	r24, 0x01	; 1
     fe2:	49 f0       	breq	.+18     	; 0xff6 <DIO_Vid_SetPortValue+0x16>
     fe4:	81 30       	cpi	r24, 0x01	; 1
     fe6:	28 f0       	brcs	.+10     	; 0xff2 <DIO_Vid_SetPortValue+0x12>
     fe8:	82 30       	cpi	r24, 0x02	; 2
     fea:	39 f0       	breq	.+14     	; 0xffa <DIO_Vid_SetPortValue+0x1a>
     fec:	83 30       	cpi	r24, 0x03	; 3
     fee:	41 f4       	brne	.+16     	; 0x1000 <DIO_Vid_SetPortValue+0x20>
     ff0:	06 c0       	rjmp	.+12     	; 0xffe <DIO_Vid_SetPortValue+0x1e>

			case Port_A :   PORTA = Copy_u8Value; break;
     ff2:	6b bb       	out	0x1b, r22	; 27
     ff4:	08 95       	ret
			case Port_B :   PORTB = Copy_u8Value; break;
     ff6:	68 bb       	out	0x18, r22	; 24
     ff8:	08 95       	ret
			case Port_C :   PORTC = Copy_u8Value; break;
     ffa:	65 bb       	out	0x15, r22	; 21
     ffc:	08 95       	ret
			case Port_D :   PORTD = Copy_u8Value; break;
     ffe:	62 bb       	out	0x12, r22	; 18
    1000:	08 95       	ret

00001002 <DIO_Vid_GetPportValue>:
			case Port_B : *pu8Data = ; break;
			case Port_C : *pu8Data = ; break;
			case Port_D : *pu8Data = ; break;
		}
	*/
}
    1002:	08 95       	ret

00001004 <EXTI_Vid_Enable>:
void EXTI_Vid_Enable(void){
	#if INT_SRC == INT0

		#if SENSE_CTRL == FALLING

			SET_BIT(EXTI_MCUCR, MCUCR_ISC01);
    1004:	85 b7       	in	r24, 0x35	; 53
    1006:	82 60       	ori	r24, 0x02	; 2
    1008:	85 bf       	out	0x35, r24	; 53
			CLR_BIT(EXTI_MCUCR, MCUCR_ISC00);
    100a:	85 b7       	in	r24, 0x35	; 53
    100c:	8e 7f       	andi	r24, 0xFE	; 254
    100e:	85 bf       	out	0x35, r24	; 53



		#endif

		SET_BIT(EXTI_GICR, GICR_INT0);
    1010:	8b b7       	in	r24, 0x3b	; 59
    1012:	80 64       	ori	r24, 0x40	; 64
    1014:	8b bf       	out	0x3b, r24	; 59



	#endif
}
    1016:	08 95       	ret

00001018 <EXTI_Vid_Disable>:
void EXTI_Vid_Disable(void){
	#if INT_SRC == INT0

		#if SENSE_CTRL == FALLING

			SET_BIT(EXTI_MCUCR, MCUCR_ISC01);
    1018:	85 b7       	in	r24, 0x35	; 53
    101a:	82 60       	ori	r24, 0x02	; 2
    101c:	85 bf       	out	0x35, r24	; 53
			CLR_BIT(EXTI_MCUCR, MCUCR_ISC00);
    101e:	85 b7       	in	r24, 0x35	; 53
    1020:	8e 7f       	andi	r24, 0xFE	; 254
    1022:	85 bf       	out	0x35, r24	; 53



		#endif

		CLR_BIT(EXTI_GICR, GICR_INT0);
    1024:	8b b7       	in	r24, 0x3b	; 59
    1026:	8f 7b       	andi	r24, 0xBF	; 191
    1028:	8b bf       	out	0x3b, r24	; 59



	#endif
}
    102a:	08 95       	ret

0000102c <GIE_voidEnable>:
#include "GIE_register.h"

/*Enable GIE (Global interrupt Enable)*/
void GIE_voidEnable (void)
{
SET_BIT(SREG_REG,SREG_I);
    102c:	8f b7       	in	r24, 0x3f	; 63
    102e:	80 68       	ori	r24, 0x80	; 128
    1030:	8f bf       	out	0x3f, r24	; 63
}
    1032:	08 95       	ret

00001034 <GIE_voidDisable>:

/*Disable GIE (Global interrupt Enable)*/
void GIE_voidDisable (void)
{
CLR_BIT(SREG_REG,SREG_I);
    1034:	8f b7       	in	r24, 0x3f	; 63
    1036:	8f 77       	andi	r24, 0x7F	; 127
    1038:	8f bf       	out	0x3f, r24	; 63
}
    103a:	08 95       	ret

0000103c <LCD2_vid_SendCmd>:
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinLow);

}

void LCD2_vid_SendCmd(uint8 Copy_u8Cmd){
    103c:	1f 93       	push	r17
    103e:	18 2f       	mov	r17, r24

	DIO_Vid_SetPinValue(CONTROL_PORT2, RS_PIN,PinLow);
    1040:	80 e0       	ldi	r24, 0x00	; 0
    1042:	67 e0       	ldi	r22, 0x07	; 7
    1044:	40 e0       	ldi	r20, 0x00	; 0
    1046:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPinValue(CONTROL_PORT2, RW_PIN,PinLow);
    104a:	80 e0       	ldi	r24, 0x00	; 0
    104c:	66 e0       	ldi	r22, 0x06	; 6
    104e:	40 e0       	ldi	r20, 0x00	; 0
    1050:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPortValue(DATA_PORT2, Copy_u8Cmd);
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	61 2f       	mov	r22, r17
    1058:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <DIO_Vid_SetPortValue>
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinHigh);
    105c:	80 e0       	ldi	r24, 0x00	; 0
    105e:	65 e0       	ldi	r22, 0x05	; 5
    1060:	41 e0       	ldi	r20, 0x01	; 1
    1062:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1066:	80 e7       	ldi	r24, 0x70	; 112
    1068:	97 e1       	ldi	r25, 0x17	; 23
    106a:	01 97       	sbiw	r24, 0x01	; 1
    106c:	f1 f7       	brne	.-4      	; 0x106a <LCD2_vid_SendCmd+0x2e>
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinLow);
    106e:	80 e0       	ldi	r24, 0x00	; 0
    1070:	65 e0       	ldi	r22, 0x05	; 5
    1072:	40 e0       	ldi	r20, 0x00	; 0
    1074:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>

}
    1078:	1f 91       	pop	r17
    107a:	08 95       	ret

0000107c <LCD2_vid_GoToX>:
	LCD_vid_SendCmd(Copy_u8Y+0b10000000);
}

void LCD2_vid_GoToX(uint8 Copy_u8X, uint8 Copy_u8Y){

	if(Copy_u8X==1){
    107c:	81 30       	cpi	r24, 0x01	; 1
    107e:	09 f4       	brne	.+2      	; 0x1082 <LCD2_vid_GoToX+0x6>
		Copy_u8Y += 0x40;
    1080:	60 5c       	subi	r22, 0xC0	; 192
	}

	LCD2_vid_SendCmd(Copy_u8Y+0b10000000);
    1082:	86 2f       	mov	r24, r22
    1084:	80 58       	subi	r24, 0x80	; 128
    1086:	0e 94 1e 08 	call	0x103c	; 0x103c <LCD2_vid_SendCmd>
}
    108a:	08 95       	ret

0000108c <LCD2_vid_DisplayClear>:
void LCD_vid_DisplayClear(){
	LCD_vid_SendCmd(1);
}

void LCD2_vid_DisplayClear(){
	LCD2_vid_SendCmd(1);
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	0e 94 1e 08 	call	0x103c	; 0x103c <LCD2_vid_SendCmd>
}
    1092:	08 95       	ret

00001094 <LCD2_Vid_Init>:

	LCD_vid_SendCmd(1);

}

void LCD2_Vid_Init(void){
    1094:	80 e9       	ldi	r24, 0x90	; 144
    1096:	91 e0       	ldi	r25, 0x01	; 1
    1098:	28 ec       	ldi	r18, 0xC8	; 200
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	f9 01       	movw	r30, r18
    109e:	31 97       	sbiw	r30, 0x01	; 1
    10a0:	f1 f7       	brne	.-4      	; 0x109e <LCD2_Vid_Init+0xa>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    10a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    10a4:	d9 f7       	brne	.-10     	; 0x109c <LCD2_Vid_Init+0x8>

	_delay_ms(40);
	LCD2_vid_SendCmd(0b00111100);
    10a6:	8c e3       	ldi	r24, 0x3C	; 60
    10a8:	0e 94 1e 08 	call	0x103c	; 0x103c <LCD2_vid_SendCmd>
    10ac:	80 ed       	ldi	r24, 0xD0	; 208
    10ae:	97 e0       	ldi	r25, 0x07	; 7
    10b0:	01 97       	sbiw	r24, 0x01	; 1
    10b2:	f1 f7       	brne	.-4      	; 0x10b0 <LCD2_Vid_Init+0x1c>
	_delay_ms(1);

	LCD2_vid_SendCmd(0b00001100);
    10b4:	8c e0       	ldi	r24, 0x0C	; 12
    10b6:	0e 94 1e 08 	call	0x103c	; 0x103c <LCD2_vid_SendCmd>

	LCD2_vid_SendCmd(1);
    10ba:	81 e0       	ldi	r24, 0x01	; 1
    10bc:	0e 94 1e 08 	call	0x103c	; 0x103c <LCD2_vid_SendCmd>

}
    10c0:	08 95       	ret

000010c2 <LCD2_vid_SendData>:
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinLow);

}

void LCD2_vid_SendData(uint8 Copy_u8Data){
    10c2:	1f 93       	push	r17
    10c4:	18 2f       	mov	r17, r24

	DIO_Vid_SetPinValue(CONTROL_PORT2, RS_PIN,PinHigh);
    10c6:	80 e0       	ldi	r24, 0x00	; 0
    10c8:	67 e0       	ldi	r22, 0x07	; 7
    10ca:	41 e0       	ldi	r20, 0x01	; 1
    10cc:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPinValue(CONTROL_PORT2, RW_PIN,PinLow);
    10d0:	80 e0       	ldi	r24, 0x00	; 0
    10d2:	66 e0       	ldi	r22, 0x06	; 6
    10d4:	40 e0       	ldi	r20, 0x00	; 0
    10d6:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPortValue(DATA_PORT2, Copy_u8Data);
    10da:	81 e0       	ldi	r24, 0x01	; 1
    10dc:	61 2f       	mov	r22, r17
    10de:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <DIO_Vid_SetPortValue>
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinHigh);
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	65 e0       	ldi	r22, 0x05	; 5
    10e6:	41 e0       	ldi	r20, 0x01	; 1
    10e8:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
    10ec:	80 e7       	ldi	r24, 0x70	; 112
    10ee:	97 e1       	ldi	r25, 0x17	; 23
    10f0:	01 97       	sbiw	r24, 0x01	; 1
    10f2:	f1 f7       	brne	.-4      	; 0x10f0 <LCD2_vid_SendData+0x2e>
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinLow);
    10f4:	80 e0       	ldi	r24, 0x00	; 0
    10f6:	65 e0       	ldi	r22, 0x05	; 5
    10f8:	40 e0       	ldi	r20, 0x00	; 0
    10fa:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>

}
    10fe:	1f 91       	pop	r17
    1100:	08 95       	ret

00001102 <LCD2_vid_SendString>:
		 i++;
	 }
}


void LCD2_vid_SendString(uint8 *str){
    1102:	1f 93       	push	r17
    1104:	cf 93       	push	r28
    1106:	df 93       	push	r29
    1108:	ec 01       	movw	r28, r24
    110a:	10 e0       	ldi	r17, 0x00	; 0
    110c:	03 c0       	rjmp	.+6      	; 0x1114 <LCD2_vid_SendString+0x12>
	uint8 i=0;
	 while(str[i] != '\0'){
		 LCD2_vid_SendData(str[i]);
    110e:	0e 94 61 08 	call	0x10c2	; 0x10c2 <LCD2_vid_SendData>
		 i++;
    1112:	1f 5f       	subi	r17, 0xFF	; 255
}


void LCD2_vid_SendString(uint8 *str){
	uint8 i=0;
	 while(str[i] != '\0'){
    1114:	fe 01       	movw	r30, r28
    1116:	e1 0f       	add	r30, r17
    1118:	f1 1d       	adc	r31, r1
    111a:	80 81       	ld	r24, Z
    111c:	88 23       	and	r24, r24
    111e:	b9 f7       	brne	.-18     	; 0x110e <LCD2_vid_SendString+0xc>
		 LCD2_vid_SendData(str[i]);
		 i++;
	 }
}
    1120:	df 91       	pop	r29
    1122:	cf 91       	pop	r28
    1124:	1f 91       	pop	r17
    1126:	08 95       	ret

00001128 <LCD_vid_SendCmd>:
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinLow);

}

void LCD_vid_SendCmd(uint8 Copy_u8Cmd){
    1128:	1f 93       	push	r17
    112a:	18 2f       	mov	r17, r24

	DIO_Vid_SetPinValue(CONTROL_PORT, RS_PIN,PinLow);
    112c:	83 e0       	ldi	r24, 0x03	; 3
    112e:	67 e0       	ldi	r22, 0x07	; 7
    1130:	40 e0       	ldi	r20, 0x00	; 0
    1132:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPinValue(CONTROL_PORT, RW_PIN,PinLow);
    1136:	83 e0       	ldi	r24, 0x03	; 3
    1138:	66 e0       	ldi	r22, 0x06	; 6
    113a:	40 e0       	ldi	r20, 0x00	; 0
    113c:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPortValue(DATA_PORT, Copy_u8Cmd);
    1140:	82 e0       	ldi	r24, 0x02	; 2
    1142:	61 2f       	mov	r22, r17
    1144:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <DIO_Vid_SetPortValue>
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinHigh);
    1148:	83 e0       	ldi	r24, 0x03	; 3
    114a:	65 e0       	ldi	r22, 0x05	; 5
    114c:	41 e0       	ldi	r20, 0x01	; 1
    114e:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
    1152:	80 e7       	ldi	r24, 0x70	; 112
    1154:	97 e1       	ldi	r25, 0x17	; 23
    1156:	01 97       	sbiw	r24, 0x01	; 1
    1158:	f1 f7       	brne	.-4      	; 0x1156 <LCD_vid_SendCmd+0x2e>
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinLow);
    115a:	83 e0       	ldi	r24, 0x03	; 3
    115c:	65 e0       	ldi	r22, 0x05	; 5
    115e:	40 e0       	ldi	r20, 0x00	; 0
    1160:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>

}
    1164:	1f 91       	pop	r17
    1166:	08 95       	ret

00001168 <LCD_vid_GoToX>:
}


void LCD_vid_GoToX(uint8 Copy_u8X, uint8 Copy_u8Y){

	if(Copy_u8X==1){
    1168:	81 30       	cpi	r24, 0x01	; 1
    116a:	09 f4       	brne	.+2      	; 0x116e <LCD_vid_GoToX+0x6>
		Copy_u8Y += 0x40;
    116c:	60 5c       	subi	r22, 0xC0	; 192
	}

	LCD_vid_SendCmd(Copy_u8Y+0b10000000);
    116e:	86 2f       	mov	r24, r22
    1170:	80 58       	subi	r24, 0x80	; 128
    1172:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>
}
    1176:	08 95       	ret

00001178 <LCD_vid_DisplayClear>:
	LCD2_vid_SendCmd(1);

}

void LCD_vid_DisplayClear(){
	LCD_vid_SendCmd(1);
    1178:	81 e0       	ldi	r24, 0x01	; 1
    117a:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>
}
    117e:	08 95       	ret

00001180 <LCD_Vid_Init>:
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT2, E_PIN,PinLow);

}

void LCD_Vid_Init(void){
    1180:	80 e9       	ldi	r24, 0x90	; 144
    1182:	91 e0       	ldi	r25, 0x01	; 1
    1184:	28 ec       	ldi	r18, 0xC8	; 200
    1186:	30 e0       	ldi	r19, 0x00	; 0
    1188:	f9 01       	movw	r30, r18
    118a:	31 97       	sbiw	r30, 0x01	; 1
    118c:	f1 f7       	brne	.-4      	; 0x118a <LCD_Vid_Init+0xa>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    118e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1190:	d9 f7       	brne	.-10     	; 0x1188 <LCD_Vid_Init+0x8>

	_delay_ms(40);
	LCD_vid_SendCmd(0b00111100);
    1192:	8c e3       	ldi	r24, 0x3C	; 60
    1194:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>
    1198:	80 ed       	ldi	r24, 0xD0	; 208
    119a:	97 e0       	ldi	r25, 0x07	; 7
    119c:	01 97       	sbiw	r24, 0x01	; 1
    119e:	f1 f7       	brne	.-4      	; 0x119c <LCD_Vid_Init+0x1c>
	_delay_ms(1);

	LCD_vid_SendCmd(0b00001100);
    11a0:	8c e0       	ldi	r24, 0x0C	; 12
    11a2:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>

	LCD_vid_SendCmd(1);
    11a6:	81 e0       	ldi	r24, 0x01	; 1
    11a8:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>

}
    11ac:	08 95       	ret

000011ae <LCD_vid_SendData>:
#include <util/delay.h>




void LCD_vid_SendData(uint8 Copy_u8Data){
    11ae:	1f 93       	push	r17
    11b0:	18 2f       	mov	r17, r24

	DIO_Vid_SetPinValue(CONTROL_PORT, RS_PIN,PinHigh);
    11b2:	83 e0       	ldi	r24, 0x03	; 3
    11b4:	67 e0       	ldi	r22, 0x07	; 7
    11b6:	41 e0       	ldi	r20, 0x01	; 1
    11b8:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPinValue(CONTROL_PORT, RW_PIN,PinLow);
    11bc:	83 e0       	ldi	r24, 0x03	; 3
    11be:	66 e0       	ldi	r22, 0x06	; 6
    11c0:	40 e0       	ldi	r20, 0x00	; 0
    11c2:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
	DIO_Vid_SetPortValue(DATA_PORT, Copy_u8Data);
    11c6:	82 e0       	ldi	r24, 0x02	; 2
    11c8:	61 2f       	mov	r22, r17
    11ca:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <DIO_Vid_SetPortValue>
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinHigh);
    11ce:	83 e0       	ldi	r24, 0x03	; 3
    11d0:	65 e0       	ldi	r22, 0x05	; 5
    11d2:	41 e0       	ldi	r20, 0x01	; 1
    11d4:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
    11d8:	80 e7       	ldi	r24, 0x70	; 112
    11da:	97 e1       	ldi	r25, 0x17	; 23
    11dc:	01 97       	sbiw	r24, 0x01	; 1
    11de:	f1 f7       	brne	.-4      	; 0x11dc <LCD_vid_SendData+0x2e>
	_delay_ms(3);
	DIO_Vid_SetPinValue(CONTROL_PORT, E_PIN,PinLow);
    11e0:	83 e0       	ldi	r24, 0x03	; 3
    11e2:	65 e0       	ldi	r22, 0x05	; 5
    11e4:	40 e0       	ldi	r20, 0x00	; 0
    11e6:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>

}
    11ea:	1f 91       	pop	r17
    11ec:	08 95       	ret

000011ee <LCD_vid_SendString>:
		LCD_vid_SendData((Copy_U32Number%10)+'0');
	}

}

void LCD_vid_SendString(uint8 *str){
    11ee:	1f 93       	push	r17
    11f0:	cf 93       	push	r28
    11f2:	df 93       	push	r29
    11f4:	ec 01       	movw	r28, r24
    11f6:	10 e0       	ldi	r17, 0x00	; 0
    11f8:	03 c0       	rjmp	.+6      	; 0x1200 <LCD_vid_SendString+0x12>
	uint8 i=0;
	 while(str[i] != '\0'){
		 LCD_vid_SendData(str[i]);
    11fa:	0e 94 d7 08 	call	0x11ae	; 0x11ae <LCD_vid_SendData>
		 i++;
    11fe:	1f 5f       	subi	r17, 0xFF	; 255

}

void LCD_vid_SendString(uint8 *str){
	uint8 i=0;
	 while(str[i] != '\0'){
    1200:	fe 01       	movw	r30, r28
    1202:	e1 0f       	add	r30, r17
    1204:	f1 1d       	adc	r31, r1
    1206:	80 81       	ld	r24, Z
    1208:	88 23       	and	r24, r24
    120a:	b9 f7       	brne	.-18     	; 0x11fa <LCD_vid_SendString+0xc>
		 LCD_vid_SendData(str[i]);
		 i++;
	 }
}
    120c:	df 91       	pop	r29
    120e:	cf 91       	pop	r28
    1210:	1f 91       	pop	r17
    1212:	08 95       	ret

00001214 <LCD_vid_SendInt>:
	LCD_vid_SendData(Pattern_Num);


}

void LCD_vid_SendInt(uint32 Copy_U32Number){
    1214:	ef 92       	push	r14
    1216:	ff 92       	push	r15
    1218:	0f 93       	push	r16
    121a:	1f 93       	push	r17
    121c:	7b 01       	movw	r14, r22
    121e:	8c 01       	movw	r16, r24
	if(Copy_U32Number != 0){
    1220:	61 15       	cp	r22, r1
    1222:	71 05       	cpc	r23, r1
    1224:	81 05       	cpc	r24, r1
    1226:	91 05       	cpc	r25, r1
    1228:	b1 f0       	breq	.+44     	; 0x1256 <LCD_vid_SendInt+0x42>
		LCD_vid_SendInt(Copy_U32Number/10);
    122a:	2a e0       	ldi	r18, 0x0A	; 10
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	40 e0       	ldi	r20, 0x00	; 0
    1230:	50 e0       	ldi	r21, 0x00	; 0
    1232:	0e 94 0b 24 	call	0x4816	; 0x4816 <__udivmodsi4>
    1236:	ca 01       	movw	r24, r20
    1238:	b9 01       	movw	r22, r18
    123a:	0e 94 0a 09 	call	0x1214	; 0x1214 <LCD_vid_SendInt>
		LCD_vid_SendData((Copy_U32Number%10)+'0');
    123e:	c8 01       	movw	r24, r16
    1240:	b7 01       	movw	r22, r14
    1242:	2a e0       	ldi	r18, 0x0A	; 10
    1244:	30 e0       	ldi	r19, 0x00	; 0
    1246:	40 e0       	ldi	r20, 0x00	; 0
    1248:	50 e0       	ldi	r21, 0x00	; 0
    124a:	0e 94 0b 24 	call	0x4816	; 0x4816 <__udivmodsi4>
    124e:	86 2f       	mov	r24, r22
    1250:	80 5d       	subi	r24, 0xD0	; 208
    1252:	0e 94 d7 08 	call	0x11ae	; 0x11ae <LCD_vid_SendData>
	}

}
    1256:	1f 91       	pop	r17
    1258:	0f 91       	pop	r16
    125a:	ff 90       	pop	r15
    125c:	ef 90       	pop	r14
    125e:	08 95       	ret

00001260 <LCD_vid_SendSpecialChar>:
	}

	LCD2_vid_SendCmd(Copy_u8Y+0b10000000);
}

void LCD_vid_SendSpecialChar(uint8 *pattern, uint8 Pattern_Num, uint8 Copy_u8XPos, uint8 Copy_u8YPos){
    1260:	df 92       	push	r13
    1262:	ef 92       	push	r14
    1264:	ff 92       	push	r15
    1266:	0f 93       	push	r16
    1268:	1f 93       	push	r17
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	8c 01       	movw	r16, r24
    1270:	f6 2e       	mov	r15, r22
    1272:	e4 2e       	mov	r14, r20
    1274:	d2 2e       	mov	r13, r18

	uint8 Local_Address = 8 * Pattern_Num;
	LCD_vid_SendCmd(0b01000000 + Local_Address);
    1276:	86 2f       	mov	r24, r22
    1278:	88 0f       	add	r24, r24
    127a:	88 0f       	add	r24, r24
    127c:	88 0f       	add	r24, r24
    127e:	80 5c       	subi	r24, 0xC0	; 192
    1280:	0e 94 94 08 	call	0x1128	; 0x1128 <LCD_vid_SendCmd>
    1284:	c0 e0       	ldi	r28, 0x00	; 0
    1286:	d0 e0       	ldi	r29, 0x00	; 0

	for(uint8 i=0; i<8; i++){
		LCD_vid_SendData(pattern[i]);
    1288:	f8 01       	movw	r30, r16
    128a:	ec 0f       	add	r30, r28
    128c:	fd 1f       	adc	r31, r29
    128e:	80 81       	ld	r24, Z
    1290:	0e 94 d7 08 	call	0x11ae	; 0x11ae <LCD_vid_SendData>
    1294:	21 96       	adiw	r28, 0x01	; 1
void LCD_vid_SendSpecialChar(uint8 *pattern, uint8 Pattern_Num, uint8 Copy_u8XPos, uint8 Copy_u8YPos){

	uint8 Local_Address = 8 * Pattern_Num;
	LCD_vid_SendCmd(0b01000000 + Local_Address);

	for(uint8 i=0; i<8; i++){
    1296:	c8 30       	cpi	r28, 0x08	; 8
    1298:	d1 05       	cpc	r29, r1
    129a:	b1 f7       	brne	.-20     	; 0x1288 <LCD_vid_SendSpecialChar+0x28>
		LCD_vid_SendData(pattern[i]);
	}

	LCD_vid_GoToX(Copy_u8XPos,Copy_u8YPos);
    129c:	8e 2d       	mov	r24, r14
    129e:	6d 2d       	mov	r22, r13
    12a0:	0e 94 b4 08 	call	0x1168	; 0x1168 <LCD_vid_GoToX>
	LCD_vid_SendData(Pattern_Num);
    12a4:	8f 2d       	mov	r24, r15
    12a6:	0e 94 d7 08 	call	0x11ae	; 0x11ae <LCD_vid_SendData>


}
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	1f 91       	pop	r17
    12b0:	0f 91       	pop	r16
    12b2:	ff 90       	pop	r15
    12b4:	ef 90       	pop	r14
    12b6:	df 90       	pop	r13
    12b8:	08 95       	ret

000012ba <UART_VidInt>:
#include "STD_TYPES.h"
#include "BIT_Math.h"
#include "UART_Private.h"

void UART_VidInt(void){
	UCSRC = (1<<7) | (3<<1);
    12ba:	86 e8       	ldi	r24, 0x86	; 134
    12bc:	80 bd       	out	0x20, r24	; 32
	UBRRL = 51;
    12be:	83 e3       	ldi	r24, 0x33	; 51
    12c0:	89 b9       	out	0x09, r24	; 9
	SET_BIT(UCSRB, TXEN);
    12c2:	53 9a       	sbi	0x0a, 3	; 10
	SET_BIT(UCSRB, RXEN);
    12c4:	54 9a       	sbi	0x0a, 4	; 10
}
    12c6:	08 95       	ret

000012c8 <UART_VidSendData>:

void UART_VidSendData(u8 Copy_u8Data){
	while(GET_BIT(UCSRA, UDRE)!=1);
    12c8:	5d 9b       	sbis	0x0b, 5	; 11
    12ca:	fe cf       	rjmp	.-4      	; 0x12c8 <UART_VidSendData>
	UDR = Copy_u8Data;
    12cc:	8c b9       	out	0x0c, r24	; 12
}
    12ce:	08 95       	ret

000012d0 <UART_u8RecieveData>:

u8 UART_u8RecieveData(void){
	while(GET_BIT(UCSRA, RXC)!=1);
    12d0:	5f 9b       	sbis	0x0b, 7	; 11
    12d2:	fe cf       	rjmp	.-4      	; 0x12d0 <UART_u8RecieveData>
	return UDR;
    12d4:	8c b1       	in	r24, 0x0c	; 12
}
    12d6:	08 95       	ret

000012d8 <UART_Vid_SendString>:


void UART_Vid_SendString(u8 *user)
{
    12d8:	dc 01       	movw	r26, r24
	u8 i = 0;
	UART_VidSendData(user[i]);
    12da:	8c 91       	ld	r24, X
	SET_BIT(UCSRB, TXEN);
	SET_BIT(UCSRB, RXEN);
}

void UART_VidSendData(u8 Copy_u8Data){
	while(GET_BIT(UCSRA, UDRE)!=1);
    12dc:	5d 9b       	sbis	0x0b, 5	; 11
    12de:	fe cf       	rjmp	.-4      	; 0x12dc <UART_Vid_SendString+0x4>
	UDR = Copy_u8Data;
    12e0:	8c b9       	out	0x0c, r24	; 12
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	08 c0       	rjmp	.+16     	; 0x12f6 <UART_Vid_SendString+0x1e>
{
	u8 i = 0;
	UART_VidSendData(user[i]);
	while(user[i] != '\0')
	{
		i++;
    12e6:	9f 5f       	subi	r25, 0xFF	; 255
		UART_VidSendData(user[i]);
    12e8:	fd 01       	movw	r30, r26
    12ea:	e9 0f       	add	r30, r25
    12ec:	f1 1d       	adc	r31, r1
    12ee:	e0 81       	ld	r30, Z
	SET_BIT(UCSRB, TXEN);
	SET_BIT(UCSRB, RXEN);
}

void UART_VidSendData(u8 Copy_u8Data){
	while(GET_BIT(UCSRA, UDRE)!=1);
    12f0:	5d 9b       	sbis	0x0b, 5	; 11
    12f2:	fe cf       	rjmp	.-4      	; 0x12f0 <UART_Vid_SendString+0x18>
	UDR = Copy_u8Data;
    12f4:	ec b9       	out	0x0c, r30	; 12

void UART_Vid_SendString(u8 *user)
{
	u8 i = 0;
	UART_VidSendData(user[i]);
	while(user[i] != '\0')
    12f6:	fd 01       	movw	r30, r26
    12f8:	e9 0f       	add	r30, r25
    12fa:	f1 1d       	adc	r31, r1
    12fc:	80 81       	ld	r24, Z
    12fe:	88 23       	and	r24, r24
    1300:	91 f7       	brne	.-28     	; 0x12e6 <UART_Vid_SendString+0xe>
	{
		i++;
		UART_VidSendData(user[i]);
	}
}
    1302:	08 95       	ret

00001304 <UART_Vid_SendInt>:

void UART_Vid_SendInt(u32 Copy_U32Number){
    1304:	ef 92       	push	r14
    1306:	ff 92       	push	r15
    1308:	0f 93       	push	r16
    130a:	1f 93       	push	r17
    130c:	7b 01       	movw	r14, r22
    130e:	8c 01       	movw	r16, r24

	if(Copy_U32Number != 0){
    1310:	61 15       	cp	r22, r1
    1312:	71 05       	cpc	r23, r1
    1314:	81 05       	cpc	r24, r1
    1316:	91 05       	cpc	r25, r1
    1318:	b1 f0       	breq	.+44     	; 0x1346 <UART_Vid_SendInt+0x42>
		UART_Vid_SendInt(Copy_U32Number/10);
    131a:	2a e0       	ldi	r18, 0x0A	; 10
    131c:	30 e0       	ldi	r19, 0x00	; 0
    131e:	40 e0       	ldi	r20, 0x00	; 0
    1320:	50 e0       	ldi	r21, 0x00	; 0
    1322:	0e 94 0b 24 	call	0x4816	; 0x4816 <__udivmodsi4>
    1326:	ca 01       	movw	r24, r20
    1328:	b9 01       	movw	r22, r18
    132a:	0e 94 82 09 	call	0x1304	; 0x1304 <UART_Vid_SendInt>
	SET_BIT(UCSRB, TXEN);
	SET_BIT(UCSRB, RXEN);
}

void UART_VidSendData(u8 Copy_u8Data){
	while(GET_BIT(UCSRA, UDRE)!=1);
    132e:	5d 9b       	sbis	0x0b, 5	; 11
    1330:	fe cf       	rjmp	.-4      	; 0x132e <UART_Vid_SendInt+0x2a>

void UART_Vid_SendInt(u32 Copy_U32Number){

	if(Copy_U32Number != 0){
		UART_Vid_SendInt(Copy_U32Number/10);
		UART_VidSendData((Copy_U32Number%10)+'0');
    1332:	c8 01       	movw	r24, r16
    1334:	b7 01       	movw	r22, r14
    1336:	2a e0       	ldi	r18, 0x0A	; 10
    1338:	30 e0       	ldi	r19, 0x00	; 0
    133a:	40 e0       	ldi	r20, 0x00	; 0
    133c:	50 e0       	ldi	r21, 0x00	; 0
    133e:	0e 94 0b 24 	call	0x4816	; 0x4816 <__udivmodsi4>
    1342:	60 5d       	subi	r22, 0xD0	; 208
	SET_BIT(UCSRB, RXEN);
}

void UART_VidSendData(u8 Copy_u8Data){
	while(GET_BIT(UCSRA, UDRE)!=1);
	UDR = Copy_u8Data;
    1344:	6c b9       	out	0x0c, r22	; 12
	if(Copy_U32Number != 0){
		UART_Vid_SendInt(Copy_U32Number/10);
		UART_VidSendData((Copy_U32Number%10)+'0');
	}

}
    1346:	1f 91       	pop	r17
    1348:	0f 91       	pop	r16
    134a:	ff 90       	pop	r15
    134c:	ef 90       	pop	r14
    134e:	08 95       	ret

00001350 <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    1350:	fc 01       	movw	r30, r24
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    1352:	0f b6       	in	r0, 0x3f	; 63
    1354:	f8 94       	cli
    1356:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    1358:	20 81       	ld	r18, Z
    135a:	31 81       	ldd	r19, Z+1	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    135c:	60 95       	com	r22
    135e:	70 95       	com	r23
    1360:	62 23       	and	r22, r18
    1362:	73 23       	and	r23, r19
    1364:	71 83       	std	Z+1, r23	; 0x01
    1366:	60 83       	st	Z, r22
    }
    taskEXIT_CRITICAL();
    1368:	0f 90       	pop	r0
    136a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
}
    136c:	c9 01       	movw	r24, r18
    136e:	08 95       	ret

00001370 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    1370:	fc 01       	movw	r30, r24
        uxReturn = pxEventBits->uxEventBits;
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    1372:	80 81       	ld	r24, Z
    1374:	91 81       	ldd	r25, Z+1	; 0x01
    1376:	08 95       	ret

00001378 <vEventGroupClearBitsCallback>:
/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1378:	ba 01       	movw	r22, r20
    137a:	0e 94 a8 09 	call	0x1350	; 0x1350 <xEventGroupClearBits>
}
    137e:	08 95       	ret

00001380 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    1380:	cf 92       	push	r12
    1382:	df 92       	push	r13
    1384:	ef 92       	push	r14
    1386:	ff 92       	push	r15
    1388:	0f 93       	push	r16
    138a:	1f 93       	push	r17
    138c:	cf 93       	push	r28
    138e:	df 93       	push	r29
    1390:	ec 01       	movw	r28, r24
    1392:	8b 01       	movw	r16, r22
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1394:	85 e0       	ldi	r24, 0x05	; 5
    1396:	e8 2e       	mov	r14, r24
    1398:	f1 2c       	mov	r15, r1
    139a:	ec 0e       	add	r14, r28
    139c:	fd 1e       	adc	r15, r29
    vTaskSuspendAll();
    139e:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    13a2:	ef 81       	ldd	r30, Y+7	; 0x07
    13a4:	f8 85       	ldd	r31, Y+8	; 0x08

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    13a6:	88 81       	ld	r24, Y
    13a8:	99 81       	ldd	r25, Y+1	; 0x01
    13aa:	80 2b       	or	r24, r16
    13ac:	91 2b       	or	r25, r17
    13ae:	99 83       	std	Y+1, r25	; 0x01
    13b0:	88 83       	st	Y, r24
    13b2:	00 e0       	ldi	r16, 0x00	; 0
    13b4:	10 e0       	ldi	r17, 0x00	; 0
    13b6:	24 c0       	rjmp	.+72     	; 0x1400 <xEventGroupSetBits+0x80>

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
        {
            pxNext = listGET_NEXT( pxListItem );
    13b8:	d2 80       	ldd	r13, Z+2	; 0x02
    13ba:	c3 80       	ldd	r12, Z+3	; 0x03
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    13bc:	80 81       	ld	r24, Z
    13be:	91 81       	ldd	r25, Z+1	; 0x01
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    13c0:	bc 01       	movw	r22, r24
    13c2:	60 70       	andi	r22, 0x00	; 0
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    13c4:	ac 01       	movw	r20, r24
    13c6:	50 70       	andi	r21, 0x00	; 0
    13c8:	28 81       	ld	r18, Y
    13ca:	39 81       	ldd	r19, Y+1	; 0x01

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    13cc:	92 fd       	sbrc	r25, 2
    13ce:	05 c0       	rjmp	.+10     	; 0x13da <xEventGroupSetBits+0x5a>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    13d0:	24 23       	and	r18, r20
    13d2:	35 23       	and	r19, r21
    13d4:	23 2b       	or	r18, r19
    13d6:	31 f4       	brne	.+12     	; 0x13e4 <xEventGroupSetBits+0x64>
    13d8:	0f c0       	rjmp	.+30     	; 0x13f8 <xEventGroupSetBits+0x78>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    13da:	24 23       	and	r18, r20
    13dc:	35 23       	and	r19, r21
    13de:	24 17       	cp	r18, r20
    13e0:	35 07       	cpc	r19, r21
    13e2:	51 f4       	brne	.+20     	; 0x13f8 <xEventGroupSetBits+0x78>
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    13e4:	70 ff       	sbrs	r23, 0
    13e6:	02 c0       	rjmp	.+4      	; 0x13ec <xEventGroupSetBits+0x6c>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    13e8:	04 2b       	or	r16, r20
    13ea:	15 2b       	or	r17, r21
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    13ec:	68 81       	ld	r22, Y
    13ee:	79 81       	ldd	r23, Y+1	; 0x01
    13f0:	72 60       	ori	r23, 0x02	; 2
    13f2:	cf 01       	movw	r24, r30
    13f4:	0e 94 41 1b 	call	0x3682	; 0x3682 <vTaskRemoveFromUnorderedEventList>
    13f8:	8d 2d       	mov	r24, r13
    13fa:	9c 2d       	mov	r25, r12
    13fc:	9c 01       	movw	r18, r24
    13fe:	f9 01       	movw	r30, r18

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    1400:	ee 15       	cp	r30, r14
    1402:	ff 05       	cpc	r31, r15
    1404:	c9 f6       	brne	.-78     	; 0x13b8 <xEventGroupSetBits+0x38>
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    1406:	00 95       	com	r16
    1408:	10 95       	com	r17
    140a:	88 81       	ld	r24, Y
    140c:	99 81       	ldd	r25, Y+1	; 0x01
    140e:	80 23       	and	r24, r16
    1410:	91 23       	and	r25, r17
    1412:	99 83       	std	Y+1, r25	; 0x01
    1414:	88 83       	st	Y, r24
    }
    ( void ) xTaskResumeAll();
    1416:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
    141a:	88 81       	ld	r24, Y
    141c:	99 81       	ldd	r25, Y+1	; 0x01
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	1f 91       	pop	r17
    1424:	0f 91       	pop	r16
    1426:	ff 90       	pop	r15
    1428:	ef 90       	pop	r14
    142a:	df 90       	pop	r13
    142c:	cf 90       	pop	r12
    142e:	08 95       	ret

00001430 <vEventGroupSetBitsCallback>:
/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1430:	ba 01       	movw	r22, r20
    1432:	0e 94 c0 09 	call	0x1380	; 0x1380 <xEventGroupSetBits>
}
    1436:	08 95       	ret

00001438 <vEventGroupDelete>:
    return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    1438:	cf 93       	push	r28
    143a:	df 93       	push	r29
    143c:	ec 01       	movw	r28, r24

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
    143e:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    1442:	06 c0       	rjmp	.+12     	; 0x1450 <vEventGroupDelete+0x18>
        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    1444:	8f 81       	ldd	r24, Y+7	; 0x07
    1446:	98 85       	ldd	r25, Y+8	; 0x08
    1448:	60 e0       	ldi	r22, 0x00	; 0
    144a:	72 e0       	ldi	r23, 0x02	; 2
    144c:	0e 94 41 1b 	call	0x3682	; 0x3682 <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    1450:	8a 81       	ldd	r24, Y+2	; 0x02
    1452:	88 23       	and	r24, r24
    1454:	b9 f7       	brne	.-18     	; 0x1444 <vEventGroupDelete+0xc>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    1456:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    145a:	ce 01       	movw	r24, r28
    145c:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1460:	df 91       	pop	r29
    1462:	cf 91       	pop	r28
    1464:	08 95       	ret

00001466 <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    1466:	af 92       	push	r10
    1468:	bf 92       	push	r11
    146a:	cf 92       	push	r12
    146c:	df 92       	push	r13
    146e:	ef 92       	push	r14
    1470:	ff 92       	push	r15
    1472:	0f 93       	push	r16
    1474:	1f 93       	push	r17
    1476:	cf 93       	push	r28
    1478:	df 93       	push	r29
    147a:	6c 01       	movw	r12, r24
    147c:	7b 01       	movw	r14, r22
    147e:	a4 2e       	mov	r10, r20
    1480:	b2 2e       	mov	r11, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    1482:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    1486:	f6 01       	movw	r30, r12
    1488:	20 81       	ld	r18, Z
    148a:	31 81       	ldd	r19, Z+1	; 0x01
    148c:	c7 01       	movw	r24, r14
    148e:	82 23       	and	r24, r18
    1490:	93 23       	and	r25, r19
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    1492:	bb 20       	and	r11, r11
    1494:	21 f4       	brne	.+8      	; 0x149e <xEventGroupWaitBits+0x38>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1496:	89 2b       	or	r24, r25
    1498:	09 f0       	breq	.+2      	; 0x149c <xEventGroupWaitBits+0x36>
    149a:	5a c0       	rjmp	.+180    	; 0x1550 <xEventGroupWaitBits+0xea>
    149c:	04 c0       	rjmp	.+8      	; 0x14a6 <xEventGroupWaitBits+0x40>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    149e:	8e 15       	cp	r24, r14
    14a0:	9f 05       	cpc	r25, r15
    14a2:	09 f4       	brne	.+2      	; 0x14a6 <xEventGroupWaitBits+0x40>
    14a4:	55 c0       	rjmp	.+170    	; 0x1550 <xEventGroupWaitBits+0xea>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    14a6:	01 15       	cp	r16, r1
    14a8:	11 05       	cpc	r17, r1
    14aa:	59 f4       	brne	.+22     	; 0x14c2 <xEventGroupWaitBits+0x5c>
    14ac:	e9 01       	movw	r28, r18
    14ae:	1b c0       	rjmp	.+54     	; 0x14e6 <xEventGroupWaitBits+0x80>
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    14b0:	c7 01       	movw	r24, r14
    14b2:	80 95       	com	r24
    14b4:	90 95       	com	r25
    14b6:	82 23       	and	r24, r18
    14b8:	93 23       	and	r25, r19
    14ba:	f6 01       	movw	r30, r12
    14bc:	91 83       	std	Z+1, r25	; 0x01
    14be:	80 83       	st	Z, r24
    14c0:	4a c0       	rjmp	.+148    	; 0x1556 <xEventGroupWaitBits+0xf0>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    14c2:	aa 20       	and	r10, r10
    14c4:	19 f0       	breq	.+6      	; 0x14cc <xEventGroupWaitBits+0x66>
    14c6:	60 e0       	ldi	r22, 0x00	; 0
    14c8:	71 e0       	ldi	r23, 0x01	; 1
    14ca:	02 c0       	rjmp	.+4      	; 0x14d0 <xEventGroupWaitBits+0x6a>
    14cc:	60 e0       	ldi	r22, 0x00	; 0
    14ce:	70 e0       	ldi	r23, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    14d0:	b1 10       	cpse	r11, r1
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    14d2:	74 60       	ori	r23, 0x04	; 4
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    14d4:	6e 29       	or	r22, r14
    14d6:	7f 29       	or	r23, r15
    14d8:	c6 01       	movw	r24, r12
    14da:	02 96       	adiw	r24, 0x02	; 2
    14dc:	a8 01       	movw	r20, r16
    14de:	0e 94 60 21 	call	0x42c0	; 0x42c0 <vTaskPlaceOnUnorderedEventList>
    14e2:	c0 e0       	ldi	r28, 0x00	; 0
    14e4:	d0 e0       	ldi	r29, 0x00	; 0
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    14e6:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    14ea:	01 2b       	or	r16, r17
    14ec:	29 f1       	breq	.+74     	; 0x1538 <xEventGroupWaitBits+0xd2>
    {
        if( xAlreadyYielded == pdFALSE )
    14ee:	88 23       	and	r24, r24
    14f0:	11 f4       	brne	.+4      	; 0x14f6 <xEventGroupWaitBits+0x90>
        {
            portYIELD_WITHIN_API();
    14f2:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    14f6:	0e 94 35 1c 	call	0x386a	; 0x386a <uxTaskResetEventItemValue>

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    14fa:	91 fd       	sbrc	r25, 1
    14fc:	1b c0       	rjmp	.+54     	; 0x1534 <xEventGroupWaitBits+0xce>
        {
            taskENTER_CRITICAL();
    14fe:	0f b6       	in	r0, 0x3f	; 63
    1500:	f8 94       	cli
    1502:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    1504:	f6 01       	movw	r30, r12
    1506:	80 81       	ld	r24, Z
    1508:	91 81       	ldd	r25, Z+1	; 0x01
    150a:	97 01       	movw	r18, r14
    150c:	28 23       	and	r18, r24
    150e:	39 23       	and	r19, r25
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    1510:	bb 20       	and	r11, r11
    1512:	19 f4       	brne	.+6      	; 0x151a <xEventGroupWaitBits+0xb4>
    {
        /* Task only has to wait for one bit within uxBitsToWaitFor to be
         * set.  Is one already set? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1514:	23 2b       	or	r18, r19
    1516:	19 f5       	brne	.+70     	; 0x155e <xEventGroupWaitBits+0xf8>
    1518:	0b c0       	rjmp	.+22     	; 0x1530 <xEventGroupWaitBits+0xca>
    }
    else
    {
        /* Task has to wait for all the bits in uxBitsToWaitFor to be set.
         * Are they set already? */
        if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    151a:	2e 15       	cp	r18, r14
    151c:	3f 05       	cpc	r19, r15
    151e:	41 f4       	brne	.+16     	; 0x1530 <xEventGroupWaitBits+0xca>
    1520:	1e c0       	rjmp	.+60     	; 0x155e <xEventGroupWaitBits+0xf8>
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1522:	e0 94       	com	r14
    1524:	f0 94       	com	r15
    1526:	e8 22       	and	r14, r24
    1528:	f9 22       	and	r15, r25
    152a:	f6 01       	movw	r30, r12
    152c:	f1 82       	std	Z+1, r15	; 0x01
    152e:	e0 82       	st	Z, r14
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
    1530:	0f 90       	pop	r0
    1532:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    1534:	ec 01       	movw	r28, r24
    1536:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    1538:	ce 01       	movw	r24, r28
    153a:	df 91       	pop	r29
    153c:	cf 91       	pop	r28
    153e:	1f 91       	pop	r17
    1540:	0f 91       	pop	r16
    1542:	ff 90       	pop	r15
    1544:	ef 90       	pop	r14
    1546:	df 90       	pop	r13
    1548:	cf 90       	pop	r12
    154a:	bf 90       	pop	r11
    154c:	af 90       	pop	r10
    154e:	08 95       	ret
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    1550:	aa 20       	and	r10, r10
    1552:	09 f0       	breq	.+2      	; 0x1556 <xEventGroupWaitBits+0xf0>
    1554:	ad cf       	rjmp	.-166    	; 0x14b0 <xEventGroupWaitBits+0x4a>
    1556:	e9 01       	movw	r28, r18
    1558:	00 e0       	ldi	r16, 0x00	; 0
    155a:	10 e0       	ldi	r17, 0x00	; 0
    155c:	c4 cf       	rjmp	.-120    	; 0x14e6 <xEventGroupWaitBits+0x80>

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
                {
                    if( xClearOnExit != pdFALSE )
    155e:	aa 20       	and	r10, r10
    1560:	01 f7       	brne	.-64     	; 0x1522 <xEventGroupWaitBits+0xbc>
    1562:	e6 cf       	rjmp	.-52     	; 0x1530 <xEventGroupWaitBits+0xca>

00001564 <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    1564:	af 92       	push	r10
    1566:	bf 92       	push	r11
    1568:	cf 92       	push	r12
    156a:	df 92       	push	r13
    156c:	ef 92       	push	r14
    156e:	ff 92       	push	r15
    1570:	0f 93       	push	r16
    1572:	1f 93       	push	r17
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	6c 01       	movw	r12, r24
    157a:	8b 01       	movw	r16, r22
    157c:	7a 01       	movw	r14, r20
    157e:	59 01       	movw	r10, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    1580:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    1584:	f6 01       	movw	r30, r12
    1586:	c0 81       	ld	r28, Z
    1588:	d1 81       	ldd	r29, Z+1	; 0x01

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    158a:	c6 01       	movw	r24, r12
    158c:	b8 01       	movw	r22, r16
    158e:	0e 94 c0 09 	call	0x1380	; 0x1380 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1592:	c0 2b       	or	r28, r16
    1594:	d1 2b       	or	r29, r17
    1596:	c7 01       	movw	r24, r14
    1598:	8c 23       	and	r24, r28
    159a:	9d 23       	and	r25, r29
    159c:	8e 15       	cp	r24, r14
    159e:	9f 05       	cpc	r25, r15
    15a0:	69 f4       	brne	.+26     	; 0x15bc <xEventGroupSync+0x58>
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    15a2:	97 01       	movw	r18, r14
    15a4:	20 95       	com	r18
    15a6:	30 95       	com	r19
    15a8:	f6 01       	movw	r30, r12
    15aa:	80 81       	ld	r24, Z
    15ac:	91 81       	ldd	r25, Z+1	; 0x01
    15ae:	82 23       	and	r24, r18
    15b0:	93 23       	and	r25, r19
    15b2:	91 83       	std	Z+1, r25	; 0x01
    15b4:	80 83       	st	Z, r24
    15b6:	aa 24       	eor	r10, r10
    15b8:	bb 24       	eor	r11, r11
    15ba:	10 c0       	rjmp	.+32     	; 0x15dc <xEventGroupSync+0x78>

            xTicksToWait = 0;
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    15bc:	a1 14       	cp	r10, r1
    15be:	b1 04       	cpc	r11, r1
    15c0:	51 f0       	breq	.+20     	; 0x15d6 <xEventGroupSync+0x72>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    15c2:	b7 01       	movw	r22, r14
    15c4:	75 60       	ori	r23, 0x05	; 5
    15c6:	c6 01       	movw	r24, r12
    15c8:	02 96       	adiw	r24, 0x02	; 2
    15ca:	a5 01       	movw	r20, r10
    15cc:	0e 94 60 21 	call	0x42c0	; 0x42c0 <vTaskPlaceOnUnorderedEventList>
    15d0:	c0 e0       	ldi	r28, 0x00	; 0
    15d2:	d0 e0       	ldi	r29, 0x00	; 0
    15d4:	03 c0       	rjmp	.+6      	; 0x15dc <xEventGroupSync+0x78>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    15d6:	f6 01       	movw	r30, r12
    15d8:	c0 81       	ld	r28, Z
    15da:	d1 81       	ldd	r29, Z+1	; 0x01
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    15dc:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    15e0:	ab 28       	or	r10, r11
    15e2:	f9 f0       	breq	.+62     	; 0x1622 <xEventGroupSync+0xbe>
    {
        if( xAlreadyYielded == pdFALSE )
    15e4:	88 23       	and	r24, r24
    15e6:	11 f4       	brne	.+4      	; 0x15ec <xEventGroupSync+0x88>
        {
            portYIELD_WITHIN_API();
    15e8:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    15ec:	0e 94 35 1c 	call	0x386a	; 0x386a <uxTaskResetEventItemValue>
    15f0:	9c 01       	movw	r18, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    15f2:	91 fd       	sbrc	r25, 1
    15f4:	14 c0       	rjmp	.+40     	; 0x161e <xEventGroupSync+0xba>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    15f6:	0f b6       	in	r0, 0x3f	; 63
    15f8:	f8 94       	cli
    15fa:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    15fc:	f6 01       	movw	r30, r12
    15fe:	20 81       	ld	r18, Z
    1600:	31 81       	ldd	r19, Z+1	; 0x01

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    1602:	c7 01       	movw	r24, r14
    1604:	82 23       	and	r24, r18
    1606:	93 23       	and	r25, r19
    1608:	8e 15       	cp	r24, r14
    160a:	9f 05       	cpc	r25, r15
    160c:	31 f4       	brne	.+12     	; 0x161a <xEventGroupSync+0xb6>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    160e:	e0 94       	com	r14
    1610:	f0 94       	com	r15
    1612:	e2 22       	and	r14, r18
    1614:	f3 22       	and	r15, r19
    1616:	f1 82       	std	Z+1, r15	; 0x01
    1618:	e0 82       	st	Z, r14
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    161a:	0f 90       	pop	r0
    161c:	0f be       	out	0x3f, r0	; 63
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    161e:	e9 01       	movw	r28, r18
    1620:	d0 70       	andi	r29, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    1622:	ce 01       	movw	r24, r28
    1624:	df 91       	pop	r29
    1626:	cf 91       	pop	r28
    1628:	1f 91       	pop	r17
    162a:	0f 91       	pop	r16
    162c:	ff 90       	pop	r15
    162e:	ef 90       	pop	r14
    1630:	df 90       	pop	r13
    1632:	cf 90       	pop	r12
    1634:	bf 90       	pop	r11
    1636:	af 90       	pop	r10
    1638:	08 95       	ret

0000163a <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    163a:	cf 93       	push	r28
    163c:	df 93       	push	r29
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    163e:	8b e0       	ldi	r24, 0x0B	; 11
    1640:	90 e0       	ldi	r25, 0x00	; 0
    1642:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    1646:	ec 01       	movw	r28, r24

        if( pxEventBits != NULL )
    1648:	00 97       	sbiw	r24, 0x00	; 0
    164a:	31 f0       	breq	.+12     	; 0x1658 <xEventGroupCreate+0x1e>
        {
            pxEventBits->uxEventBits = 0;
    164c:	fc 01       	movw	r30, r24
    164e:	11 92       	st	Z+, r1
    1650:	11 92       	st	Z+, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    1652:	cf 01       	movw	r24, r30
    1654:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
    1658:	ce 01       	movw	r24, r28
    165a:	df 91       	pop	r29
    165c:	cf 91       	pop	r28
    165e:	08 95       	ret

00001660 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    return xFreeBytesRemaining;
}
    1660:	80 91 d4 01 	lds	r24, 0x01D4
    1664:	90 91 d5 01 	lds	r25, 0x01D5
    1668:	08 95       	ret

0000166a <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* This just exists to keep the linker quiet. */
}
    166a:	08 95       	ret

0000166c <vPortFree>:
    return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void * pv )
{
    166c:	cf 93       	push	r28
    166e:	df 93       	push	r29
    uint8_t * puc = ( uint8_t * ) pv;
    BlockLink_t * pxLink;

    if( pv != NULL )
    1670:	00 97       	sbiw	r24, 0x00	; 0
    1672:	a1 f1       	breq	.+104    	; 0x16dc <vPortFree+0x70>
         * before it. */
        puc -= heapSTRUCT_SIZE;

        /* This unexpected casting is to keep some compilers from issuing
         * byte alignment warnings. */
        pxLink = ( void * ) puc;
    1674:	ec 01       	movw	r28, r24
    1676:	24 97       	sbiw	r28, 0x04	; 4

        configASSERT( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 );
        configASSERT( pxLink->pxNextFreeBlock == NULL );

        if( heapBLOCK_IS_ALLOCATED( pxLink ) != 0 )
    1678:	2a 81       	ldd	r18, Y+2	; 0x02
    167a:	3b 81       	ldd	r19, Y+3	; 0x03
    167c:	37 ff       	sbrs	r19, 7
    167e:	2e c0       	rjmp	.+92     	; 0x16dc <vPortFree+0x70>
        {
            if( pxLink->pxNextFreeBlock == NULL )
    1680:	88 81       	ld	r24, Y
    1682:	99 81       	ldd	r25, Y+1	; 0x01
    1684:	89 2b       	or	r24, r25
    1686:	51 f5       	brne	.+84     	; 0x16dc <vPortFree+0x70>
            {
                /* The block is being returned to the heap - it is no longer
                 * allocated. */
                heapFREE_BLOCK( pxLink );
    1688:	3f 77       	andi	r19, 0x7F	; 127
    168a:	3b 83       	std	Y+3, r19	; 0x03
    168c:	2a 83       	std	Y+2, r18	; 0x02
                {
                    ( void ) memset( puc + heapSTRUCT_SIZE, 0, pxLink->xBlockSize - heapSTRUCT_SIZE );
                }
                #endif

                vTaskSuspendAll();
    168e:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
                {
                    /* Add this block to the list of free blocks. */
                    prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    1692:	4a 81       	ldd	r20, Y+2	; 0x02
    1694:	5b 81       	ldd	r21, Y+3	; 0x03
    1696:	a5 eb       	ldi	r26, 0xB5	; 181
    1698:	b7 e0       	ldi	r27, 0x07	; 7
    169a:	2c 91       	ld	r18, X
    169c:	11 96       	adiw	r26, 0x01	; 1
    169e:	3c 91       	ld	r19, X
    16a0:	11 97       	sbiw	r26, 0x01	; 1
    16a2:	bd 01       	movw	r22, r26
    16a4:	c9 01       	movw	r24, r18
    16a6:	dc 01       	movw	r26, r24
    16a8:	12 96       	adiw	r26, 0x02	; 2
    16aa:	8d 91       	ld	r24, X+
    16ac:	9c 91       	ld	r25, X
    16ae:	13 97       	sbiw	r26, 0x03	; 3
    16b0:	84 17       	cp	r24, r20
    16b2:	95 07       	cpc	r25, r21
    16b4:	90 f3       	brcs	.-28     	; 0x169a <vPortFree+0x2e>
    16b6:	fb 01       	movw	r30, r22
    16b8:	b9 83       	std	Y+1, r27	; 0x01
    16ba:	a8 83       	st	Y, r26
    16bc:	d1 83       	std	Z+1, r29	; 0x01
    16be:	c0 83       	st	Z, r28
                    xFreeBytesRemaining += pxLink->xBlockSize;
    16c0:	80 91 d4 01 	lds	r24, 0x01D4
    16c4:	90 91 d5 01 	lds	r25, 0x01D5
    16c8:	2a 81       	ldd	r18, Y+2	; 0x02
    16ca:	3b 81       	ldd	r19, Y+3	; 0x03
    16cc:	82 0f       	add	r24, r18
    16ce:	93 1f       	adc	r25, r19
    16d0:	90 93 d5 01 	sts	0x01D5, r25
    16d4:	80 93 d4 01 	sts	0x01D4, r24
                    traceFREE( pv, pxLink->xBlockSize );
                }
                ( void ) xTaskResumeAll();
    16d8:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
            }
        }
    }
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	08 95       	ret

000016e2 <pvPortMalloc>:
        pxIterator->pxNextFreeBlock = pxBlockToInsert;                                                                              \
    }
/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    16e2:	ef 92       	push	r14
    16e4:	ff 92       	push	r15
    16e6:	0f 93       	push	r16
    16e8:	1f 93       	push	r17
    16ea:	cf 93       	push	r28
    16ec:	df 93       	push	r29
    16ee:	8c 01       	movw	r16, r24
    BlockLink_t * pxNewBlockLink;
    PRIVILEGED_DATA static BaseType_t xHeapHasBeenInitialised = pdFALSE;
    void * pvReturn = NULL;
    size_t xAdditionalRequiredSize;

    vTaskSuspendAll();
    16f0:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    {
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( xHeapHasBeenInitialised == pdFALSE )
    16f4:	80 91 d8 01 	lds	r24, 0x01D8
    16f8:	88 23       	and	r24, r24
    16fa:	09 f5       	brne	.+66     	; 0x173e <pvPortMalloc+0x5c>
    /* Ensure the heap starts on a correctly aligned boundary. */
    pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

    /* xStart is used to hold a pointer to the first item in the list of free
     * blocks.  The void cast is used to prevent compiler warnings. */
    xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    16fc:	89 ed       	ldi	r24, 0xD9	; 217
    16fe:	91 e0       	ldi	r25, 0x01	; 1
    1700:	90 93 b6 07 	sts	0x07B6, r25
    1704:	80 93 b5 07 	sts	0x07B5, r24
    xStart.xBlockSize = ( size_t ) 0;
    1708:	10 92 b8 07 	sts	0x07B8, r1
    170c:	10 92 b7 07 	sts	0x07B7, r1

    /* xEnd is used to mark the end of the list of free blocks. */
    xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
    1710:	8b ed       	ldi	r24, 0xDB	; 219
    1712:	95 e0       	ldi	r25, 0x05	; 5
    1714:	90 93 bc 07 	sts	0x07BC, r25
    1718:	80 93 bb 07 	sts	0x07BB, r24
    xEnd.pxNextFreeBlock = NULL;
    171c:	10 92 ba 07 	sts	0x07BA, r1
    1720:	10 92 b9 07 	sts	0x07B9, r1

    /* To start with there is a single free block that is sized to take up the
     * entire heap space. */
    pxFirstFreeBlock = ( BlockLink_t * ) pucAlignedHeap;
    pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
    1724:	90 93 dc 01 	sts	0x01DC, r25
    1728:	80 93 db 01 	sts	0x01DB, r24
    pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
    172c:	89 eb       	ldi	r24, 0xB9	; 185
    172e:	97 e0       	ldi	r25, 0x07	; 7
    1730:	90 93 da 01 	sts	0x01DA, r25
    1734:	80 93 d9 01 	sts	0x01D9, r24
        /* If this is the first call to malloc then the heap will require
         * initialisation to setup the list of free blocks. */
        if( xHeapHasBeenInitialised == pdFALSE )
        {
            prvHeapInit();
            xHeapHasBeenInitialised = pdTRUE;
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	80 93 d8 01 	sts	0x01D8, r24
        }

        if( xWantedSize > 0 )
    173e:	01 15       	cp	r16, r1
    1740:	11 05       	cpc	r17, r1
    1742:	39 f0       	breq	.+14     	; 0x1752 <pvPortMalloc+0x70>
            /* The wanted size must be increased so it can contain a BlockLink_t
             * structure in addition to the requested amount of bytes. Some
             * additional increment may also be needed for alignment. */
            xAdditionalRequiredSize = heapSTRUCT_SIZE + portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK );

            if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) == 0 )
    1744:	8f ef       	ldi	r24, 0xFF	; 255
    1746:	0b 3f       	cpi	r16, 0xFB	; 251
    1748:	18 07       	cpc	r17, r24
    174a:	08 f0       	brcs	.+2      	; 0x174e <pvPortMalloc+0x6c>
    174c:	6a c0       	rjmp	.+212    	; 0x1822 <pvPortMalloc+0x140>
            {
                xWantedSize += xAdditionalRequiredSize;
    174e:	0b 5f       	subi	r16, 0xFB	; 251
    1750:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Check the block size we are trying to allocate is not so large that the
         * top bit is set.  The top bit of the block size member of the BlockLink_t
         * structure is used to determine who owns the block - the application or
         * the kernel, so it must be free. */
        if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) != 0 )
    1752:	17 fd       	sbrc	r17, 7
    1754:	66 c0       	rjmp	.+204    	; 0x1822 <pvPortMalloc+0x140>
        {
            if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1756:	01 15       	cp	r16, r1
    1758:	11 05       	cpc	r17, r1
    175a:	09 f4       	brne	.+2      	; 0x175e <pvPortMalloc+0x7c>
    175c:	62 c0       	rjmp	.+196    	; 0x1822 <pvPortMalloc+0x140>
    175e:	60 91 d4 01 	lds	r22, 0x01D4
    1762:	70 91 d5 01 	lds	r23, 0x01D5
    1766:	60 17       	cp	r22, r16
    1768:	71 07       	cpc	r23, r17
    176a:	08 f4       	brcc	.+2      	; 0x176e <pvPortMalloc+0x8c>
    176c:	5a c0       	rjmp	.+180    	; 0x1822 <pvPortMalloc+0x140>
            {
                /* Blocks are stored in byte order - traverse the list from the start
                 * (smallest) block until one of adequate size is found. */
                pxPreviousBlock = &xStart;
                pxBlock = xStart.pxNextFreeBlock;
    176e:	c0 91 b5 07 	lds	r28, 0x07B5
    1772:	d0 91 b6 07 	lds	r29, 0x07B6
    1776:	e5 eb       	ldi	r30, 0xB5	; 181
    1778:	f7 e0       	ldi	r31, 0x07	; 7

                while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    177a:	8a 81       	ldd	r24, Y+2	; 0x02
    177c:	9b 81       	ldd	r25, Y+3	; 0x03
    177e:	80 17       	cp	r24, r16
    1780:	91 07       	cpc	r25, r17
    1782:	40 f4       	brcc	.+16     	; 0x1794 <pvPortMalloc+0xb2>
    1784:	88 81       	ld	r24, Y
    1786:	99 81       	ldd	r25, Y+1	; 0x01
    1788:	9e 01       	movw	r18, r28
    178a:	00 97       	sbiw	r24, 0x00	; 0
    178c:	19 f0       	breq	.+6      	; 0x1794 <pvPortMalloc+0xb2>
    178e:	ec 01       	movw	r28, r24
    1790:	f9 01       	movw	r30, r18
    1792:	f3 cf       	rjmp	.-26     	; 0x177a <pvPortMalloc+0x98>
                    pxPreviousBlock = pxBlock;
                    pxBlock = pxBlock->pxNextFreeBlock;
                }

                /* If we found the end marker then a block of adequate size was not found. */
                if( pxBlock != &xEnd )
    1794:	a7 e0       	ldi	r26, 0x07	; 7
    1796:	c9 3b       	cpi	r28, 0xB9	; 185
    1798:	da 07       	cpc	r29, r26
    179a:	09 f4       	brne	.+2      	; 0x179e <pvPortMalloc+0xbc>
    179c:	42 c0       	rjmp	.+132    	; 0x1822 <pvPortMalloc+0x140>
                {
                    /* Return the memory space - jumping over the BlockLink_t structure
                     * at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    179e:	e0 80       	ld	r14, Z
    17a0:	f1 80       	ldd	r15, Z+1	; 0x01

                    /* This block is being returned for use so must be taken out of the
                     * list of free blocks. */
                    pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    17a2:	88 81       	ld	r24, Y
    17a4:	99 81       	ldd	r25, Y+1	; 0x01
    17a6:	91 83       	std	Z+1, r25	; 0x01
    17a8:	80 83       	st	Z, r24

                    /* If the block is larger than required it can be split into two. */
                    if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    17aa:	8a 81       	ldd	r24, Y+2	; 0x02
    17ac:	9b 81       	ldd	r25, Y+3	; 0x03
    17ae:	80 1b       	sub	r24, r16
    17b0:	91 0b       	sbc	r25, r17
    17b2:	89 30       	cpi	r24, 0x09	; 9
    17b4:	91 05       	cpc	r25, r1
    17b6:	20 f1       	brcs	.+72     	; 0x1800 <pvPortMalloc+0x11e>
                    {
                        /* This block is to be split into two.  Create a new block
                         * following the number of bytes requested. The void cast is
                         * used to prevent byte alignment warnings from the compiler. */
                        pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    17b8:	ae 01       	movw	r20, r28
    17ba:	40 0f       	add	r20, r16
    17bc:	51 1f       	adc	r21, r17

                        /* Calculate the sizes of two blocks split from the single
                         * block. */
                        pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    17be:	fa 01       	movw	r30, r20
    17c0:	93 83       	std	Z+3, r25	; 0x03
    17c2:	82 83       	std	Z+2, r24	; 0x02
                        pxBlock->xBlockSize = xWantedSize;
    17c4:	1b 83       	std	Y+3, r17	; 0x03
    17c6:	0a 83       	std	Y+2, r16	; 0x02

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    17c8:	02 80       	ldd	r0, Z+2	; 0x02
    17ca:	f3 81       	ldd	r31, Z+3	; 0x03
    17cc:	e0 2d       	mov	r30, r0
    17ce:	a5 eb       	ldi	r26, 0xB5	; 181
    17d0:	b7 e0       	ldi	r27, 0x07	; 7
    17d2:	2c 91       	ld	r18, X
    17d4:	11 96       	adiw	r26, 0x01	; 1
    17d6:	3c 91       	ld	r19, X
    17d8:	11 97       	sbiw	r26, 0x01	; 1
    17da:	1a 2f       	mov	r17, r26
    17dc:	0b 2f       	mov	r16, r27
    17de:	c9 01       	movw	r24, r18
    17e0:	dc 01       	movw	r26, r24
    17e2:	12 96       	adiw	r26, 0x02	; 2
    17e4:	8d 91       	ld	r24, X+
    17e6:	9c 91       	ld	r25, X
    17e8:	13 97       	sbiw	r26, 0x03	; 3
    17ea:	8e 17       	cp	r24, r30
    17ec:	9f 07       	cpc	r25, r31
    17ee:	88 f3       	brcs	.-30     	; 0x17d2 <pvPortMalloc+0xf0>
    17f0:	81 2f       	mov	r24, r17
    17f2:	90 2f       	mov	r25, r16
    17f4:	fa 01       	movw	r30, r20
    17f6:	b1 83       	std	Z+1, r27	; 0x01
    17f8:	a0 83       	st	Z, r26
    17fa:	dc 01       	movw	r26, r24
    17fc:	4d 93       	st	X+, r20
    17fe:	5c 93       	st	X, r21
                /* If we found the end marker then a block of adequate size was not found. */
                if( pxBlock != &xEnd )
                {
                    /* Return the memory space - jumping over the BlockLink_t structure
                     * at its start. */
                    pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    1800:	87 01       	movw	r16, r14
    1802:	0c 5f       	subi	r16, 0xFC	; 252
    1804:	1f 4f       	sbci	r17, 0xFF	; 255

                        /* Insert the new block into the list of free blocks. */
                        prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
                    }

                    xFreeBytesRemaining -= pxBlock->xBlockSize;
    1806:	8a 81       	ldd	r24, Y+2	; 0x02
    1808:	9b 81       	ldd	r25, Y+3	; 0x03
    180a:	68 1b       	sub	r22, r24
    180c:	79 0b       	sbc	r23, r25
    180e:	70 93 d5 01 	sts	0x01D5, r23
    1812:	60 93 d4 01 	sts	0x01D4, r22

                    /* The block is being returned - it is allocated and owned
                     * by the application and has no "next" block. */
                    heapALLOCATE_BLOCK( pxBlock );
    1816:	90 68       	ori	r25, 0x80	; 128
    1818:	9b 83       	std	Y+3, r25	; 0x03
    181a:	8a 83       	std	Y+2, r24	; 0x02
                    pxBlock->pxNextFreeBlock = NULL;
    181c:	19 82       	std	Y+1, r1	; 0x01
    181e:	18 82       	st	Y, r1
    1820:	02 c0       	rjmp	.+4      	; 0x1826 <pvPortMalloc+0x144>
    1822:	00 e0       	ldi	r16, 0x00	; 0
    1824:	10 e0       	ldi	r17, 0x00	; 0
            }
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    1826:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
    182a:	c8 01       	movw	r24, r16
    182c:	df 91       	pop	r29
    182e:	cf 91       	pop	r28
    1830:	1f 91       	pop	r17
    1832:	0f 91       	pop	r16
    1834:	ff 90       	pop	r15
    1836:	ef 90       	pop	r14
    1838:	08 95       	ret

0000183a <pvPortCalloc>:
}
/*-----------------------------------------------------------*/

void * pvPortCalloc( size_t xNum,
                     size_t xSize )
{
    183a:	0f 93       	push	r16
    183c:	1f 93       	push	r17
    183e:	cf 93       	push	r28
    1840:	df 93       	push	r29
    1842:	9c 01       	movw	r18, r24
    1844:	fb 01       	movw	r30, r22
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    1846:	00 97       	sbiw	r24, 0x00	; 0
    1848:	b9 f0       	breq	.+46     	; 0x1878 <pvPortCalloc+0x3e>
    184a:	8f ef       	ldi	r24, 0xFF	; 255
    184c:	9f ef       	ldi	r25, 0xFF	; 255
    184e:	b9 01       	movw	r22, r18
    1850:	0e 94 f7 23 	call	0x47ee	; 0x47ee <__udivmodhi4>
    1854:	6e 17       	cp	r22, r30
    1856:	7f 07       	cpc	r23, r31
    1858:	78 f4       	brcc	.+30     	; 0x1878 <pvPortCalloc+0x3e>
    185a:	c0 e0       	ldi	r28, 0x00	; 0
    185c:	d0 e0       	ldi	r29, 0x00	; 0
    185e:	06 c0       	rjmp	.+12     	; 0x186c <pvPortCalloc+0x32>
    {
        pv = pvPortMalloc( xNum * xSize );

        if( pv != NULL )
        {
            ( void ) memset( pv, 0, xNum * xSize );
    1860:	ce 01       	movw	r24, r28
    1862:	60 e0       	ldi	r22, 0x00	; 0
    1864:	70 e0       	ldi	r23, 0x00	; 0
    1866:	a8 01       	movw	r20, r16
    1868:	0e 94 6d 24 	call	0x48da	; 0x48da <memset>
        }
    }

    return pv;
}
    186c:	ce 01       	movw	r24, r28
    186e:	df 91       	pop	r29
    1870:	cf 91       	pop	r28
    1872:	1f 91       	pop	r17
    1874:	0f 91       	pop	r16
    1876:	08 95       	ret
{
    void * pv = NULL;

    if( heapMULTIPLY_WILL_OVERFLOW( xNum, xSize ) == 0 )
    {
        pv = pvPortMalloc( xNum * xSize );
    1878:	e2 9f       	mul	r30, r18
    187a:	80 01       	movw	r16, r0
    187c:	e3 9f       	mul	r30, r19
    187e:	10 0d       	add	r17, r0
    1880:	f2 9f       	mul	r31, r18
    1882:	10 0d       	add	r17, r0
    1884:	11 24       	eor	r1, r1
    1886:	c8 01       	movw	r24, r16
    1888:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    188c:	ec 01       	movw	r28, r24

        if( pv != NULL )
    188e:	00 97       	sbiw	r24, 0x00	; 0
    1890:	39 f7       	brne	.-50     	; 0x1860 <pvPortCalloc+0x26>
    1892:	ec cf       	rjmp	.-40     	; 0x186c <pvPortCalloc+0x32>

00001894 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1894:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1896:	9c 01       	movw	r18, r24
    1898:	2d 5f       	subi	r18, 0xFD	; 253
    189a:	3f 4f       	sbci	r19, 0xFF	; 255
    189c:	32 83       	std	Z+2, r19	; 0x02
    189e:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    18a0:	8f ef       	ldi	r24, 0xFF	; 255
    18a2:	9f ef       	ldi	r25, 0xFF	; 255
    18a4:	94 83       	std	Z+4, r25	; 0x04
    18a6:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18a8:	36 83       	std	Z+6, r19	; 0x06
    18aa:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18ac:	30 87       	std	Z+8, r19	; 0x08
    18ae:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    18b0:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    18b2:	08 95       	ret

000018b4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    18b4:	fc 01       	movw	r30, r24
    18b6:	11 86       	std	Z+9, r1	; 0x09
    18b8:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    18ba:	08 95       	ret

000018bc <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    18bc:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    18be:	fc 01       	movw	r30, r24
    18c0:	a1 81       	ldd	r26, Z+1	; 0x01
    18c2:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    18c4:	fb 01       	movw	r30, r22
    18c6:	b3 83       	std	Z+3, r27	; 0x03
    18c8:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    18ca:	14 96       	adiw	r26, 0x04	; 4
    18cc:	8d 91       	ld	r24, X+
    18ce:	9c 91       	ld	r25, X
    18d0:	15 97       	sbiw	r26, 0x05	; 5
    18d2:	95 83       	std	Z+5, r25	; 0x05
    18d4:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    18d6:	14 96       	adiw	r26, 0x04	; 4
    18d8:	ed 91       	ld	r30, X+
    18da:	fc 91       	ld	r31, X
    18dc:	15 97       	sbiw	r26, 0x05	; 5
    18de:	73 83       	std	Z+3, r23	; 0x03
    18e0:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    18e2:	15 96       	adiw	r26, 0x05	; 5
    18e4:	7c 93       	st	X, r23
    18e6:	6e 93       	st	-X, r22
    18e8:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    18ea:	fb 01       	movw	r30, r22
    18ec:	51 87       	std	Z+9, r21	; 0x09
    18ee:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    18f0:	fa 01       	movw	r30, r20
    18f2:	80 81       	ld	r24, Z
    18f4:	8f 5f       	subi	r24, 0xFF	; 255
    18f6:	80 83       	st	Z, r24
}
    18f8:	08 95       	ret

000018fa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    18fa:	cf 93       	push	r28
    18fc:	df 93       	push	r29
    18fe:	9c 01       	movw	r18, r24
    1900:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1902:	48 81       	ld	r20, Y
    1904:	59 81       	ldd	r21, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    1906:	8f ef       	ldi	r24, 0xFF	; 255
    1908:	4f 3f       	cpi	r20, 0xFF	; 255
    190a:	58 07       	cpc	r21, r24
    190c:	21 f4       	brne	.+8      	; 0x1916 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    190e:	f9 01       	movw	r30, r18
    1910:	a7 81       	ldd	r26, Z+7	; 0x07
    1912:	b0 85       	ldd	r27, Z+8	; 0x08
    1914:	0d c0       	rjmp	.+26     	; 0x1930 <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1916:	d9 01       	movw	r26, r18
    1918:	13 96       	adiw	r26, 0x03	; 3
    191a:	12 96       	adiw	r26, 0x02	; 2
    191c:	ed 91       	ld	r30, X+
    191e:	fc 91       	ld	r31, X
    1920:	13 97       	sbiw	r26, 0x03	; 3
    1922:	80 81       	ld	r24, Z
    1924:	91 81       	ldd	r25, Z+1	; 0x01
    1926:	48 17       	cp	r20, r24
    1928:	59 07       	cpc	r21, r25
    192a:	10 f0       	brcs	.+4      	; 0x1930 <vListInsert+0x36>
    192c:	df 01       	movw	r26, r30
    192e:	f5 cf       	rjmp	.-22     	; 0x191a <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    1930:	12 96       	adiw	r26, 0x02	; 2
    1932:	ed 91       	ld	r30, X+
    1934:	fc 91       	ld	r31, X
    1936:	13 97       	sbiw	r26, 0x03	; 3
    1938:	fb 83       	std	Y+3, r31	; 0x03
    193a:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    193c:	d5 83       	std	Z+5, r29	; 0x05
    193e:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    1940:	bd 83       	std	Y+5, r27	; 0x05
    1942:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    1944:	13 96       	adiw	r26, 0x03	; 3
    1946:	dc 93       	st	X, r29
    1948:	ce 93       	st	-X, r28
    194a:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    194c:	39 87       	std	Y+9, r19	; 0x09
    194e:	28 87       	std	Y+8, r18	; 0x08

    ( pxList->uxNumberOfItems )++;
    1950:	f9 01       	movw	r30, r18
    1952:	80 81       	ld	r24, Z
    1954:	8f 5f       	subi	r24, 0xFF	; 255
    1956:	80 83       	st	Z, r24
}
    1958:	df 91       	pop	r29
    195a:	cf 91       	pop	r28
    195c:	08 95       	ret

0000195e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    195e:	cf 93       	push	r28
    1960:	df 93       	push	r29
    1962:	dc 01       	movw	r26, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    1964:	18 96       	adiw	r26, 0x08	; 8
    1966:	cd 91       	ld	r28, X+
    1968:	dc 91       	ld	r29, X
    196a:	19 97       	sbiw	r26, 0x09	; 9

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    196c:	12 96       	adiw	r26, 0x02	; 2
    196e:	4d 91       	ld	r20, X+
    1970:	5c 91       	ld	r21, X
    1972:	13 97       	sbiw	r26, 0x03	; 3
    1974:	14 96       	adiw	r26, 0x04	; 4
    1976:	8d 91       	ld	r24, X+
    1978:	9c 91       	ld	r25, X
    197a:	15 97       	sbiw	r26, 0x05	; 5
    197c:	fa 01       	movw	r30, r20
    197e:	95 83       	std	Z+5, r25	; 0x05
    1980:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1982:	14 96       	adiw	r26, 0x04	; 4
    1984:	2d 91       	ld	r18, X+
    1986:	3c 91       	ld	r19, X
    1988:	15 97       	sbiw	r26, 0x05	; 5
    198a:	f9 01       	movw	r30, r18
    198c:	53 83       	std	Z+3, r21	; 0x03
    198e:	42 83       	std	Z+2, r20	; 0x02

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    1990:	89 81       	ldd	r24, Y+1	; 0x01
    1992:	9a 81       	ldd	r25, Y+2	; 0x02
    1994:	8a 17       	cp	r24, r26
    1996:	9b 07       	cpc	r25, r27
    1998:	11 f4       	brne	.+4      	; 0x199e <uxListRemove+0x40>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    199a:	3a 83       	std	Y+2, r19	; 0x02
    199c:	29 83       	std	Y+1, r18	; 0x01
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    199e:	19 96       	adiw	r26, 0x09	; 9
    19a0:	1c 92       	st	X, r1
    19a2:	1e 92       	st	-X, r1
    19a4:	18 97       	sbiw	r26, 0x08	; 8
    ( pxList->uxNumberOfItems )--;
    19a6:	88 81       	ld	r24, Y
    19a8:	81 50       	subi	r24, 0x01	; 1
    19aa:	88 83       	st	Y, r24

    return pxList->uxNumberOfItems;
    19ac:	88 81       	ld	r24, Y
}
    19ae:	df 91       	pop	r29
    19b0:	cf 91       	pop	r28
    19b2:	08 95       	ret

000019b4 <__vector_1>:



void __vector_1 (void) __attribute__ ((signal));

void __vector_1 (void){
    19b4:	1f 92       	push	r1
    19b6:	0f 92       	push	r0
    19b8:	0f b6       	in	r0, 0x3f	; 63
    19ba:	0f 92       	push	r0
    19bc:	11 24       	eor	r1, r1
    19be:	2f 93       	push	r18
    19c0:	3f 93       	push	r19
    19c2:	4f 93       	push	r20
    19c4:	5f 93       	push	r21
    19c6:	6f 93       	push	r22
    19c8:	7f 93       	push	r23
    19ca:	8f 93       	push	r24
    19cc:	9f 93       	push	r25
    19ce:	af 93       	push	r26
    19d0:	bf 93       	push	r27
    19d2:	ef 93       	push	r30
    19d4:	ff 93       	push	r31

	if(xSemaphoreTake(LEDsemph,10) == pdTRUE)
    19d6:	80 91 2f 08 	lds	r24, 0x082F
    19da:	90 91 30 08 	lds	r25, 0x0830
    19de:	6a e0       	ldi	r22, 0x0A	; 10
    19e0:	70 e0       	ldi	r23, 0x00	; 0
    19e2:	0e 94 0f 12 	call	0x241e	; 0x241e <xQueueSemaphoreTake>
    19e6:	81 30       	cpi	r24, 0x01	; 1
    19e8:	d9 f4       	brne	.+54     	; 0x1a20 <__vector_1+0x6c>
	{

		led = led ^ 1; //toggle led
    19ea:	40 91 bd 07 	lds	r20, 0x07BD
    19ee:	50 91 be 07 	lds	r21, 0x07BE
    19f2:	81 e0       	ldi	r24, 0x01	; 1
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	48 27       	eor	r20, r24
    19f8:	59 27       	eor	r21, r25
    19fa:	50 93 be 07 	sts	0x07BE, r21
    19fe:	40 93 bd 07 	sts	0x07BD, r20
		DIO_Vid_SetPinValue(Port_D, pin3, led);
    1a02:	83 e0       	ldi	r24, 0x03	; 3
    1a04:	63 e0       	ldi	r22, 0x03	; 3
    1a06:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
		xSemaphoreGive(LEDsemph);
    1a0a:	80 91 2f 08 	lds	r24, 0x082F
    1a0e:	90 91 30 08 	lds	r25, 0x0830
    1a12:	60 e0       	ldi	r22, 0x00	; 0
    1a14:	70 e0       	ldi	r23, 0x00	; 0
    1a16:	40 e0       	ldi	r20, 0x00	; 0
    1a18:	50 e0       	ldi	r21, 0x00	; 0
    1a1a:	20 e0       	ldi	r18, 0x00	; 0
    1a1c:	0e 94 59 13 	call	0x26b2	; 0x26b2 <xQueueGenericSend>

	}

}
    1a20:	ff 91       	pop	r31
    1a22:	ef 91       	pop	r30
    1a24:	bf 91       	pop	r27
    1a26:	af 91       	pop	r26
    1a28:	9f 91       	pop	r25
    1a2a:	8f 91       	pop	r24
    1a2c:	7f 91       	pop	r23
    1a2e:	6f 91       	pop	r22
    1a30:	5f 91       	pop	r21
    1a32:	4f 91       	pop	r20
    1a34:	3f 91       	pop	r19
    1a36:	2f 91       	pop	r18
    1a38:	0f 90       	pop	r0
    1a3a:	0f be       	out	0x3f, r0	; 63
    1a3c:	0f 90       	pop	r0
    1a3e:	1f 90       	pop	r1
    1a40:	18 95       	reti

00001a42 <Door>:
{

	while(1)
	{

		door = GET_BIT(PINA, pin1);
    1a42:	89 b3       	in	r24, 0x19	; 25
    1a44:	86 95       	lsr	r24
    1a46:	90 e0       	ldi	r25, 0x00	; 0
    1a48:	81 70       	andi	r24, 0x01	; 1
    1a4a:	90 70       	andi	r25, 0x00	; 0
    1a4c:	90 93 36 08 	sts	0x0836, r25
    1a50:	80 93 35 08 	sts	0x0835, r24

		if(GET_BIT(PINA, pin1) == PinLow){
    1a54:	c9 99       	sbic	0x19, 1	; 25
    1a56:	05 c0       	rjmp	.+10     	; 0x1a62 <Door+0x20>
			DIO_Vid_SetPinDirection(Port_A, pin2, output);
    1a58:	80 e0       	ldi	r24, 0x00	; 0
    1a5a:	62 e0       	ldi	r22, 0x02	; 2
    1a5c:	41 e0       	ldi	r20, 0x01	; 1
    1a5e:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
		}

		if(GET_BIT(PINA, pin1) == PinHigh){
    1a62:	c9 9b       	sbis	0x19, 1	; 25
    1a64:	05 c0       	rjmp	.+10     	; 0x1a70 <Door+0x2e>
			DIO_Vid_SetPinDirection(Port_A, pin2, input);
    1a66:	80 e0       	ldi	r24, 0x00	; 0
    1a68:	62 e0       	ldi	r22, 0x02	; 2
    1a6a:	40 e0       	ldi	r20, 0x00	; 0
    1a6c:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
		}

		vTaskDelay(2000);
    1a70:	80 ed       	ldi	r24, 0xD0	; 208
    1a72:	97 e0       	ldi	r25, 0x07	; 7
    1a74:	0e 94 a4 21 	call	0x4348	; 0x4348 <vTaskDelay>
    1a78:	e4 cf       	rjmp	.-56     	; 0x1a42 <Door>

00001a7a <LED>:
	return 0;
}


void LED(void* pvParameter)
{
    1a7a:	cf 93       	push	r28
    1a7c:	df 93       	push	r29

	while(1)
	{
		if(xSemaphoreTake(LEDsemph,0) == pdTRUE)
		{
			led = led ^ 1; //toggle led
    1a7e:	c1 e0       	ldi	r28, 0x01	; 1
    1a80:	d0 e0       	ldi	r29, 0x00	; 0
void LED(void* pvParameter)
{

	while(1)
	{
		if(xSemaphoreTake(LEDsemph,0) == pdTRUE)
    1a82:	80 91 2f 08 	lds	r24, 0x082F
    1a86:	90 91 30 08 	lds	r25, 0x0830
    1a8a:	60 e0       	ldi	r22, 0x00	; 0
    1a8c:	70 e0       	ldi	r23, 0x00	; 0
    1a8e:	0e 94 0f 12 	call	0x241e	; 0x241e <xQueueSemaphoreTake>
    1a92:	81 30       	cpi	r24, 0x01	; 1
    1a94:	b1 f7       	brne	.-20     	; 0x1a82 <LED+0x8>
		{
			led = led ^ 1; //toggle led
    1a96:	40 91 bd 07 	lds	r20, 0x07BD
    1a9a:	50 91 be 07 	lds	r21, 0x07BE
    1a9e:	4c 27       	eor	r20, r28
    1aa0:	5d 27       	eor	r21, r29
    1aa2:	50 93 be 07 	sts	0x07BE, r21
    1aa6:	40 93 bd 07 	sts	0x07BD, r20
			DIO_Vid_SetPinValue(Port_D, pin3, led);
    1aaa:	83 e0       	ldi	r24, 0x03	; 3
    1aac:	63 e0       	ldi	r22, 0x03	; 3
    1aae:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>
			xSemaphoreGive(LEDsemph);
    1ab2:	80 91 2f 08 	lds	r24, 0x082F
    1ab6:	90 91 30 08 	lds	r25, 0x0830
    1aba:	60 e0       	ldi	r22, 0x00	; 0
    1abc:	70 e0       	ldi	r23, 0x00	; 0
    1abe:	40 e0       	ldi	r20, 0x00	; 0
    1ac0:	50 e0       	ldi	r21, 0x00	; 0
    1ac2:	20 e0       	ldi	r18, 0x00	; 0
    1ac4:	0e 94 59 13 	call	0x26b2	; 0x26b2 <xQueueGenericSend>
			vTaskDelay(5000);
    1ac8:	88 e8       	ldi	r24, 0x88	; 136
    1aca:	93 e1       	ldi	r25, 0x13	; 19
    1acc:	0e 94 a4 21 	call	0x4348	; 0x4348 <vTaskDelay>
    1ad0:	d8 cf       	rjmp	.-80     	; 0x1a82 <LED+0x8>

00001ad2 <Temp>:

	while(1)
	{
		signed int volt;

		volt=Temp_ADC_read();
    1ad2:	0e 94 b5 06 	call	0xd6a	; 0xd6a <Temp_ADC_read>
		temp=(float)(volt*5)/1023.0;//conversation for LM45 Sensor
		temp = temp*100;
    1ad6:	9c 01       	movw	r18, r24
    1ad8:	22 0f       	add	r18, r18
    1ada:	33 1f       	adc	r19, r19
    1adc:	22 0f       	add	r18, r18
    1ade:	33 1f       	adc	r19, r19
    1ae0:	28 0f       	add	r18, r24
    1ae2:	39 1f       	adc	r19, r25
    1ae4:	44 27       	eor	r20, r20
    1ae6:	37 fd       	sbrc	r19, 7
    1ae8:	40 95       	com	r20
    1aea:	54 2f       	mov	r21, r20
    1aec:	ca 01       	movw	r24, r20
    1aee:	b9 01       	movw	r22, r18
    1af0:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__floatsisf>
    1af4:	20 e0       	ldi	r18, 0x00	; 0
    1af6:	30 ec       	ldi	r19, 0xC0	; 192
    1af8:	4f e7       	ldi	r20, 0x7F	; 127
    1afa:	54 e4       	ldi	r21, 0x44	; 68
    1afc:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    1b00:	20 e0       	ldi	r18, 0x00	; 0
    1b02:	30 e0       	ldi	r19, 0x00	; 0
    1b04:	48 ec       	ldi	r20, 0xC8	; 200
    1b06:	52 e4       	ldi	r21, 0x42	; 66
    1b08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1b0c:	60 93 31 08 	sts	0x0831, r22
    1b10:	70 93 32 08 	sts	0x0832, r23
    1b14:	80 93 33 08 	sts	0x0833, r24
    1b18:	90 93 34 08 	sts	0x0834, r25

		vTaskDelay(2000);
    1b1c:	80 ed       	ldi	r24, 0xD0	; 208
    1b1e:	97 e0       	ldi	r25, 0x07	; 7
    1b20:	0e 94 a4 21 	call	0x4348	; 0x4348 <vTaskDelay>
    1b24:	d6 cf       	rjmp	.-84     	; 0x1ad2 <Temp>

00001b26 <UART>:
void UART(void* pvParameter)
{

	while(1)
	{
		UART_Vid_SendString("\f");
    1b26:	80 e6       	ldi	r24, 0x60	; 96
    1b28:	90 e0       	ldi	r25, 0x00	; 0
    1b2a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
		if(led == 1)
    1b2e:	80 91 bd 07 	lds	r24, 0x07BD
    1b32:	90 91 be 07 	lds	r25, 0x07BE
    1b36:	81 30       	cpi	r24, 0x01	; 1
    1b38:	91 05       	cpc	r25, r1
    1b3a:	19 f4       	brne	.+6      	; 0x1b42 <UART+0x1c>
		{

			UART_Vid_SendString("led is on\r");
    1b3c:	82 e6       	ldi	r24, 0x62	; 98
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	04 c0       	rjmp	.+8      	; 0x1b4a <UART+0x24>

		}

		else if(led == 0){
    1b42:	89 2b       	or	r24, r25
    1b44:	21 f4       	brne	.+8      	; 0x1b4e <UART+0x28>

			UART_Vid_SendString("led is off\r");
    1b46:	8d e6       	ldi	r24, 0x6D	; 109
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
		}

		if(door == PinLow){
    1b4e:	80 91 35 08 	lds	r24, 0x0835
    1b52:	90 91 36 08 	lds	r25, 0x0836
    1b56:	89 2b       	or	r24, r25
    1b58:	19 f4       	brne	.+6      	; 0x1b60 <UART+0x3a>
			UART_Vid_SendString("door is open\r");
    1b5a:	89 e7       	ldi	r24, 0x79	; 121
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	06 c0       	rjmp	.+12     	; 0x1b6c <UART+0x46>
		}

		else{
			UART_Vid_SendString("door is closed");
    1b60:	87 e8       	ldi	r24, 0x87	; 135
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
			UART_Vid_SendString("\r");
    1b68:	86 e9       	ldi	r24, 0x96	; 150
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
		}

		UART_Vid_SendString("temp:");
    1b70:	88 e9       	ldi	r24, 0x98	; 152
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
		UART_Vid_SendInt(temp);
    1b78:	60 91 31 08 	lds	r22, 0x0831
    1b7c:	70 91 32 08 	lds	r23, 0x0832
    1b80:	80 91 33 08 	lds	r24, 0x0833
    1b84:	90 91 34 08 	lds	r25, 0x0834
    1b88:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1b8c:	0e 94 82 09 	call	0x1304	; 0x1304 <UART_Vid_SendInt>
		UART_Vid_SendString("\r");
    1b90:	86 e9       	ldi	r24, 0x96	; 150
    1b92:	90 e0       	ldi	r25, 0x00	; 0
    1b94:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <UART_Vid_SendString>
		vTaskDelay(1200);
    1b98:	80 eb       	ldi	r24, 0xB0	; 176
    1b9a:	94 e0       	ldi	r25, 0x04	; 4
    1b9c:	0e 94 a4 21 	call	0x4348	; 0x4348 <vTaskDelay>
    1ba0:	c2 cf       	rjmp	.-124    	; 0x1b26 <UART>

00001ba2 <LCD>:
void LCD(void* pvParameter)
{

	while(1)
	{
		if(led == 1)
    1ba2:	80 91 bd 07 	lds	r24, 0x07BD
    1ba6:	90 91 be 07 	lds	r25, 0x07BE
    1baa:	81 30       	cpi	r24, 0x01	; 1
    1bac:	91 05       	cpc	r25, r1
    1bae:	49 f4       	brne	.+18     	; 0x1bc2 <LCD+0x20>
		{
			LCD_vid_DisplayClear();
    1bb0:	0e 94 bc 08 	call	0x1178	; 0x1178 <LCD_vid_DisplayClear>
			LCD_vid_GoToX(0, 0);
    1bb4:	80 e0       	ldi	r24, 0x00	; 0
    1bb6:	60 e0       	ldi	r22, 0x00	; 0
    1bb8:	0e 94 b4 08 	call	0x1168	; 0x1168 <LCD_vid_GoToX>
			LCD_vid_SendString("led is on");
    1bbc:	8e e9       	ldi	r24, 0x9E	; 158
    1bbe:	90 e0       	ldi	r25, 0x00	; 0
    1bc0:	0a c0       	rjmp	.+20     	; 0x1bd6 <LCD+0x34>

		}

		else if(led == 0){
    1bc2:	89 2b       	or	r24, r25
    1bc4:	51 f4       	brne	.+20     	; 0x1bda <LCD+0x38>
			LCD_vid_DisplayClear();
    1bc6:	0e 94 bc 08 	call	0x1178	; 0x1178 <LCD_vid_DisplayClear>
			LCD_vid_GoToX(0, 0);
    1bca:	80 e0       	ldi	r24, 0x00	; 0
    1bcc:	60 e0       	ldi	r22, 0x00	; 0
    1bce:	0e 94 b4 08 	call	0x1168	; 0x1168 <LCD_vid_GoToX>
			LCD_vid_SendString("led is off");
    1bd2:	88 ea       	ldi	r24, 0xA8	; 168
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	0e 94 f7 08 	call	0x11ee	; 0x11ee <LCD_vid_SendString>
		}

		LCD_vid_GoToX(1, 0);
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	60 e0       	ldi	r22, 0x00	; 0
    1bde:	0e 94 b4 08 	call	0x1168	; 0x1168 <LCD_vid_GoToX>
		LCD_vid_SendString("temp: ");
    1be2:	83 eb       	ldi	r24, 0xB3	; 179
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	0e 94 f7 08 	call	0x11ee	; 0x11ee <LCD_vid_SendString>
		LCD_vid_SendInt(temp);
    1bea:	60 91 31 08 	lds	r22, 0x0831
    1bee:	70 91 32 08 	lds	r23, 0x0832
    1bf2:	80 91 33 08 	lds	r24, 0x0833
    1bf6:	90 91 34 08 	lds	r25, 0x0834
    1bfa:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1bfe:	0e 94 0a 09 	call	0x1214	; 0x1214 <LCD_vid_SendInt>

		if(door == PinLow){
    1c02:	80 91 35 08 	lds	r24, 0x0835
    1c06:	90 91 36 08 	lds	r25, 0x0836
    1c0a:	89 2b       	or	r24, r25
    1c0c:	49 f4       	brne	.+18     	; 0x1c20 <LCD+0x7e>
			LCD2_vid_DisplayClear();
    1c0e:	0e 94 46 08 	call	0x108c	; 0x108c <LCD2_vid_DisplayClear>
			LCD2_vid_GoToX(0, 0);
    1c12:	80 e0       	ldi	r24, 0x00	; 0
    1c14:	60 e0       	ldi	r22, 0x00	; 0
    1c16:	0e 94 3e 08 	call	0x107c	; 0x107c <LCD2_vid_GoToX>
			LCD2_vid_SendString("door is open");
    1c1a:	8a eb       	ldi	r24, 0xBA	; 186
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	08 c0       	rjmp	.+16     	; 0x1c30 <LCD+0x8e>
		}

		else{
			LCD2_vid_DisplayClear();
    1c20:	0e 94 46 08 	call	0x108c	; 0x108c <LCD2_vid_DisplayClear>
			LCD2_vid_GoToX(0, 0);
    1c24:	80 e0       	ldi	r24, 0x00	; 0
    1c26:	60 e0       	ldi	r22, 0x00	; 0
    1c28:	0e 94 3e 08 	call	0x107c	; 0x107c <LCD2_vid_GoToX>
			LCD2_vid_SendString("door is closed");
    1c2c:	87 e8       	ldi	r24, 0x87	; 135
    1c2e:	90 e0       	ldi	r25, 0x00	; 0
    1c30:	0e 94 81 08 	call	0x1102	; 0x1102 <LCD2_vid_SendString>
		}

		vTaskDelay(1000);
    1c34:	88 ee       	ldi	r24, 0xE8	; 232
    1c36:	93 e0       	ldi	r25, 0x03	; 3
    1c38:	0e 94 a4 21 	call	0x4348	; 0x4348 <vTaskDelay>
    1c3c:	b2 cf       	rjmp	.-156    	; 0x1ba2 <LCD>

00001c3e <main>:
void LCD(void* pvParameter);
void Temp(void* pvParameter);
void UART(void* pvParameter);

int main()
{
    1c3e:	ef 92       	push	r14
    1c40:	ff 92       	push	r15
    1c42:	0f 93       	push	r16
	//creat emaphor //initilize
	DIO_Vid_SetPortDirection(Port_A,output);
    1c44:	80 e0       	ldi	r24, 0x00	; 0
    1c46:	61 e0       	ldi	r22, 0x01	; 1
    1c48:	0e 94 c6 07 	call	0xf8c	; 0xf8c <DIO_Vid_SetPortDirection>
	DIO_Vid_SetPortDirection(Port_B,output);
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	61 e0       	ldi	r22, 0x01	; 1
    1c50:	0e 94 c6 07 	call	0xf8c	; 0xf8c <DIO_Vid_SetPortDirection>
	DIO_Vid_SetPortDirection(Port_C,output);
    1c54:	82 e0       	ldi	r24, 0x02	; 2
    1c56:	61 e0       	ldi	r22, 0x01	; 1
    1c58:	0e 94 c6 07 	call	0xf8c	; 0xf8c <DIO_Vid_SetPortDirection>
	DIO_Vid_SetPortDirection(Port_D,output);
    1c5c:	83 e0       	ldi	r24, 0x03	; 3
    1c5e:	61 e0       	ldi	r22, 0x01	; 1
    1c60:	0e 94 c6 07 	call	0xf8c	; 0xf8c <DIO_Vid_SetPortDirection>

	LCD_Vid_Init();
    1c64:	0e 94 c0 08 	call	0x1180	; 0x1180 <LCD_Vid_Init>
	LCD2_Vid_Init();
    1c68:	0e 94 4a 08 	call	0x1094	; 0x1094 <LCD2_Vid_Init>
	UART_VidInt();
    1c6c:	0e 94 5d 09 	call	0x12ba	; 0x12ba <UART_VidInt>
	ADC_Vid_Init();
    1c70:	0e 94 9c 06 	call	0xd38	; 0xd38 <ADC_Vid_Init>

	DIO_Vid_SetPinDirection(Port_A,pin0, input); //ADC pin
    1c74:	80 e0       	ldi	r24, 0x00	; 0
    1c76:	60 e0       	ldi	r22, 0x00	; 0
    1c78:	40 e0       	ldi	r20, 0x00	; 0
    1c7a:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	// UART pins
	DIO_Vid_SetPinDirection(Port_D,pin0,input);
    1c7e:	83 e0       	ldi	r24, 0x03	; 3
    1c80:	60 e0       	ldi	r22, 0x00	; 0
    1c82:	40 e0       	ldi	r20, 0x00	; 0
    1c84:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	DIO_Vid_SetPinDirection(Port_D,pin1,output);
    1c88:	83 e0       	ldi	r24, 0x03	; 3
    1c8a:	61 e0       	ldi	r22, 0x01	; 1
    1c8c:	41 e0       	ldi	r20, 0x01	; 1
    1c8e:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	//led pin
	DIO_Vid_SetPinDirection(Port_D,pin3,output);
    1c92:	83 e0       	ldi	r24, 0x03	; 3
    1c94:	63 e0       	ldi	r22, 0x03	; 3
    1c96:	41 e0       	ldi	r20, 0x01	; 1
    1c98:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	// button pin
	DIO_Vid_SetPinDirection(Port_D, pin2,input);
    1c9c:	83 e0       	ldi	r24, 0x03	; 3
    1c9e:	62 e0       	ldi	r22, 0x02	; 2
    1ca0:	40 e0       	ldi	r20, 0x00	; 0
    1ca2:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	DIO_Vid_SetPinValue(Port_D, pin2, PinHigh);
    1ca6:	83 e0       	ldi	r24, 0x03	; 3
    1ca8:	62 e0       	ldi	r22, 0x02	; 2
    1caa:	41 e0       	ldi	r20, 0x01	; 1
    1cac:	0e 94 31 07 	call	0xe62	; 0xe62 <DIO_Vid_SetPinValue>

	//buzzer pin
	DIO_Vid_SetPinDirection(Port_A, pin2, input);
    1cb0:	80 e0       	ldi	r24, 0x00	; 0
    1cb2:	62 e0       	ldi	r22, 0x02	; 2
    1cb4:	40 e0       	ldi	r20, 0x00	; 0
    1cb6:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>

	//door pin
	DIO_Vid_SetPinDirection(Port_A, pin1,input);
    1cba:	80 e0       	ldi	r24, 0x00	; 0
    1cbc:	61 e0       	ldi	r22, 0x01	; 1
    1cbe:	40 e0       	ldi	r20, 0x00	; 0
    1cc0:	0e 94 be 06 	call	0xd7c	; 0xd7c <DIO_Vid_SetPinDirection>
	//DIO_Vid_SetPinValue(Port_A, pin1, PinHigh);

	LEDsemph = xSemaphoreCreateBinary(); // returns 0 so we have to release the semaphore
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	60 e0       	ldi	r22, 0x00	; 0
    1cc8:	43 e0       	ldi	r20, 0x03	; 3
    1cca:	0e 94 5e 14 	call	0x28bc	; 0x28bc <xQueueGenericCreate>
    1cce:	90 93 30 08 	sts	0x0830, r25
    1cd2:	80 93 2f 08 	sts	0x082F, r24

	xSemaphoreGive(LEDsemph);
    1cd6:	60 e0       	ldi	r22, 0x00	; 0
    1cd8:	70 e0       	ldi	r23, 0x00	; 0
    1cda:	40 e0       	ldi	r20, 0x00	; 0
    1cdc:	50 e0       	ldi	r21, 0x00	; 0
    1cde:	20 e0       	ldi	r18, 0x00	; 0
    1ce0:	0e 94 59 13 	call	0x26b2	; 0x26b2 <xQueueGenericSend>

	GIE_voidEnable();
    1ce4:	0e 94 16 08 	call	0x102c	; 0x102c <GIE_voidEnable>
	EXTI_Vid_Enable();
    1ce8:	0e 94 02 08 	call	0x1004	; 0x1004 <EXTI_Vid_Enable>

	//create the tasks
	xTaskCreate(&LED, NULL,100,NULL,2,NULL);
    1cec:	8d e3       	ldi	r24, 0x3D	; 61
    1cee:	9d e0       	ldi	r25, 0x0D	; 13
    1cf0:	60 e0       	ldi	r22, 0x00	; 0
    1cf2:	70 e0       	ldi	r23, 0x00	; 0
    1cf4:	44 e6       	ldi	r20, 0x64	; 100
    1cf6:	50 e0       	ldi	r21, 0x00	; 0
    1cf8:	20 e0       	ldi	r18, 0x00	; 0
    1cfa:	30 e0       	ldi	r19, 0x00	; 0
    1cfc:	02 e0       	ldi	r16, 0x02	; 2
    1cfe:	ee 24       	eor	r14, r14
    1d00:	ff 24       	eor	r15, r15
    1d02:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>
	xTaskCreate(&LCD, NULL,200,NULL,0,NULL);
    1d06:	81 ed       	ldi	r24, 0xD1	; 209
    1d08:	9d e0       	ldi	r25, 0x0D	; 13
    1d0a:	60 e0       	ldi	r22, 0x00	; 0
    1d0c:	70 e0       	ldi	r23, 0x00	; 0
    1d0e:	48 ec       	ldi	r20, 0xC8	; 200
    1d10:	50 e0       	ldi	r21, 0x00	; 0
    1d12:	20 e0       	ldi	r18, 0x00	; 0
    1d14:	30 e0       	ldi	r19, 0x00	; 0
    1d16:	00 e0       	ldi	r16, 0x00	; 0
    1d18:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>
	xTaskCreate(&Door, NULL,100,NULL,4,NULL);
    1d1c:	81 e2       	ldi	r24, 0x21	; 33
    1d1e:	9d e0       	ldi	r25, 0x0D	; 13
    1d20:	60 e0       	ldi	r22, 0x00	; 0
    1d22:	70 e0       	ldi	r23, 0x00	; 0
    1d24:	44 e6       	ldi	r20, 0x64	; 100
    1d26:	50 e0       	ldi	r21, 0x00	; 0
    1d28:	20 e0       	ldi	r18, 0x00	; 0
    1d2a:	30 e0       	ldi	r19, 0x00	; 0
    1d2c:	04 e0       	ldi	r16, 0x04	; 4
    1d2e:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>
	xTaskCreate(&Temp, NULL,100,NULL,5,NULL);
    1d32:	89 e6       	ldi	r24, 0x69	; 105
    1d34:	9d e0       	ldi	r25, 0x0D	; 13
    1d36:	60 e0       	ldi	r22, 0x00	; 0
    1d38:	70 e0       	ldi	r23, 0x00	; 0
    1d3a:	44 e6       	ldi	r20, 0x64	; 100
    1d3c:	50 e0       	ldi	r21, 0x00	; 0
    1d3e:	20 e0       	ldi	r18, 0x00	; 0
    1d40:	30 e0       	ldi	r19, 0x00	; 0
    1d42:	05 e0       	ldi	r16, 0x05	; 5
    1d44:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>
	xTaskCreate(&UART, NULL,400,NULL,1,NULL);
    1d48:	83 e9       	ldi	r24, 0x93	; 147
    1d4a:	9d e0       	ldi	r25, 0x0D	; 13
    1d4c:	60 e0       	ldi	r22, 0x00	; 0
    1d4e:	70 e0       	ldi	r23, 0x00	; 0
    1d50:	40 e9       	ldi	r20, 0x90	; 144
    1d52:	51 e0       	ldi	r21, 0x01	; 1
    1d54:	20 e0       	ldi	r18, 0x00	; 0
    1d56:	30 e0       	ldi	r19, 0x00	; 0
    1d58:	01 e0       	ldi	r16, 0x01	; 1
    1d5a:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>


	vTaskStartScheduler();
    1d5e:	0e 94 cd 23 	call	0x479a	; 0x479a <vTaskStartScheduler>
    1d62:	ff cf       	rjmp	.-2      	; 0x1d62 <main+0x124>

00001d64 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d64:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1d66:	91 e1       	ldi	r25, 0x11	; 17
    1d68:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1d6a:	22 e2       	ldi	r18, 0x22	; 34
    1d6c:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1d6e:	83 e3       	ldi	r24, 0x33	; 51
    1d70:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1d72:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1d74:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    1d76:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1d78:	80 e8       	ldi	r24, 0x80	; 128
    1d7a:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    1d7c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1d7e:	82 e0       	ldi	r24, 0x02	; 2
    1d80:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1d82:	83 e0       	ldi	r24, 0x03	; 3
    1d84:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1d86:	84 e0       	ldi	r24, 0x04	; 4
    1d88:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1d8a:	85 e0       	ldi	r24, 0x05	; 5
    1d8c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1d8e:	86 e0       	ldi	r24, 0x06	; 6
    1d90:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    1d92:	87 e0       	ldi	r24, 0x07	; 7
    1d94:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    1d96:	88 e0       	ldi	r24, 0x08	; 8
    1d98:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    1d9a:	89 e0       	ldi	r24, 0x09	; 9
    1d9c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1d9e:	80 e1       	ldi	r24, 0x10	; 16
    1da0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    1da2:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    1da4:	82 e1       	ldi	r24, 0x12	; 18
    1da6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    1da8:	83 e1       	ldi	r24, 0x13	; 19
    1daa:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    1dac:	84 e1       	ldi	r24, 0x14	; 20
    1dae:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    1db0:	85 e1       	ldi	r24, 0x15	; 21
    1db2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    1db4:	86 e1       	ldi	r24, 0x16	; 22
    1db6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    1db8:	87 e1       	ldi	r24, 0x17	; 23
    1dba:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1dbc:	88 e1       	ldi	r24, 0x18	; 24
    1dbe:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1dc0:	89 e1       	ldi	r24, 0x19	; 25
    1dc2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1dc4:	80 e2       	ldi	r24, 0x20	; 32
    1dc6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1dc8:	81 e2       	ldi	r24, 0x21	; 33
    1dca:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1dcc:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    1dce:	83 e2       	ldi	r24, 0x23	; 35
    1dd0:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1dd2:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1dd4:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    1dd6:	86 e2       	ldi	r24, 0x26	; 38
    1dd8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    1dda:	87 e2       	ldi	r24, 0x27	; 39
    1ddc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    1dde:	88 e2       	ldi	r24, 0x28	; 40
    1de0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    1de2:	89 e2       	ldi	r24, 0x29	; 41
    1de4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1de6:	80 e3       	ldi	r24, 0x30	; 48
    1de8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1dea:	81 e3       	ldi	r24, 0x31	; 49
    1dec:	82 93       	st	-Z, r24
    1dee:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1df0:	cf 01       	movw	r24, r30
    1df2:	08 95       	ret

00001df4 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    1df4:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    1df6:	8d e3       	ldi	r24, 0x3D	; 61
    1df8:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1dfa:	8b e0       	ldi	r24, 0x0B	; 11
    1dfc:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1dfe:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1e00:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    1e02:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1e04:	a0 91 bf 07 	lds	r26, 0x07BF
    1e08:	b0 91 c0 07 	lds	r27, 0x07C0
    1e0c:	cd 91       	ld	r28, X+
    1e0e:	cd bf       	out	0x3d, r28	; 61
    1e10:	dd 91       	ld	r29, X+
    1e12:	de bf       	out	0x3e, r29	; 62
    1e14:	ff 91       	pop	r31
    1e16:	ef 91       	pop	r30
    1e18:	df 91       	pop	r29
    1e1a:	cf 91       	pop	r28
    1e1c:	bf 91       	pop	r27
    1e1e:	af 91       	pop	r26
    1e20:	9f 91       	pop	r25
    1e22:	8f 91       	pop	r24
    1e24:	7f 91       	pop	r23
    1e26:	6f 91       	pop	r22
    1e28:	5f 91       	pop	r21
    1e2a:	4f 91       	pop	r20
    1e2c:	3f 91       	pop	r19
    1e2e:	2f 91       	pop	r18
    1e30:	1f 91       	pop	r17
    1e32:	0f 91       	pop	r16
    1e34:	ff 90       	pop	r15
    1e36:	ef 90       	pop	r14
    1e38:	df 90       	pop	r13
    1e3a:	cf 90       	pop	r12
    1e3c:	bf 90       	pop	r11
    1e3e:	af 90       	pop	r10
    1e40:	9f 90       	pop	r9
    1e42:	8f 90       	pop	r8
    1e44:	7f 90       	pop	r7
    1e46:	6f 90       	pop	r6
    1e48:	5f 90       	pop	r5
    1e4a:	4f 90       	pop	r4
    1e4c:	3f 90       	pop	r3
    1e4e:	2f 90       	pop	r2
    1e50:	1f 90       	pop	r1
    1e52:	0f 90       	pop	r0
    1e54:	0f be       	out	0x3f, r0	; 63
    1e56:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1e58:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1e5a:	81 e0       	ldi	r24, 0x01	; 1
    1e5c:	08 95       	ret

00001e5e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1e5e:	08 95       	ret

00001e60 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e60:	0f 92       	push	r0
    1e62:	0f b6       	in	r0, 0x3f	; 63
    1e64:	f8 94       	cli
    1e66:	0f 92       	push	r0
    1e68:	1f 92       	push	r1
    1e6a:	11 24       	eor	r1, r1
    1e6c:	2f 92       	push	r2
    1e6e:	3f 92       	push	r3
    1e70:	4f 92       	push	r4
    1e72:	5f 92       	push	r5
    1e74:	6f 92       	push	r6
    1e76:	7f 92       	push	r7
    1e78:	8f 92       	push	r8
    1e7a:	9f 92       	push	r9
    1e7c:	af 92       	push	r10
    1e7e:	bf 92       	push	r11
    1e80:	cf 92       	push	r12
    1e82:	df 92       	push	r13
    1e84:	ef 92       	push	r14
    1e86:	ff 92       	push	r15
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	2f 93       	push	r18
    1e8e:	3f 93       	push	r19
    1e90:	4f 93       	push	r20
    1e92:	5f 93       	push	r21
    1e94:	6f 93       	push	r22
    1e96:	7f 93       	push	r23
    1e98:	8f 93       	push	r24
    1e9a:	9f 93       	push	r25
    1e9c:	af 93       	push	r26
    1e9e:	bf 93       	push	r27
    1ea0:	cf 93       	push	r28
    1ea2:	df 93       	push	r29
    1ea4:	ef 93       	push	r30
    1ea6:	ff 93       	push	r31
    1ea8:	a0 91 bf 07 	lds	r26, 0x07BF
    1eac:	b0 91 c0 07 	lds	r27, 0x07C0
    1eb0:	0d b6       	in	r0, 0x3d	; 61
    1eb2:	0d 92       	st	X+, r0
    1eb4:	0e b6       	in	r0, 0x3e	; 62
    1eb6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1eb8:	0e 94 3c 19 	call	0x3278	; 0x3278 <xTaskIncrementTick>
    1ebc:	88 23       	and	r24, r24
    1ebe:	11 f0       	breq	.+4      	; 0x1ec4 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1ec0:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1ec4:	a0 91 bf 07 	lds	r26, 0x07BF
    1ec8:	b0 91 c0 07 	lds	r27, 0x07C0
    1ecc:	cd 91       	ld	r28, X+
    1ece:	cd bf       	out	0x3d, r28	; 61
    1ed0:	dd 91       	ld	r29, X+
    1ed2:	de bf       	out	0x3e, r29	; 62
    1ed4:	ff 91       	pop	r31
    1ed6:	ef 91       	pop	r30
    1ed8:	df 91       	pop	r29
    1eda:	cf 91       	pop	r28
    1edc:	bf 91       	pop	r27
    1ede:	af 91       	pop	r26
    1ee0:	9f 91       	pop	r25
    1ee2:	8f 91       	pop	r24
    1ee4:	7f 91       	pop	r23
    1ee6:	6f 91       	pop	r22
    1ee8:	5f 91       	pop	r21
    1eea:	4f 91       	pop	r20
    1eec:	3f 91       	pop	r19
    1eee:	2f 91       	pop	r18
    1ef0:	1f 91       	pop	r17
    1ef2:	0f 91       	pop	r16
    1ef4:	ff 90       	pop	r15
    1ef6:	ef 90       	pop	r14
    1ef8:	df 90       	pop	r13
    1efa:	cf 90       	pop	r12
    1efc:	bf 90       	pop	r11
    1efe:	af 90       	pop	r10
    1f00:	9f 90       	pop	r9
    1f02:	8f 90       	pop	r8
    1f04:	7f 90       	pop	r7
    1f06:	6f 90       	pop	r6
    1f08:	5f 90       	pop	r5
    1f0a:	4f 90       	pop	r4
    1f0c:	3f 90       	pop	r3
    1f0e:	2f 90       	pop	r2
    1f10:	1f 90       	pop	r1
    1f12:	0f 90       	pop	r0
    1f14:	0f be       	out	0x3f, r0	; 63
    1f16:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1f18:	08 95       	ret

00001f1a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1f1a:	0e 94 30 0f 	call	0x1e60	; 0x1e60 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1f1e:	18 95       	reti

00001f20 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1f20:	0f 92       	push	r0
    1f22:	0f b6       	in	r0, 0x3f	; 63
    1f24:	f8 94       	cli
    1f26:	0f 92       	push	r0
    1f28:	1f 92       	push	r1
    1f2a:	11 24       	eor	r1, r1
    1f2c:	2f 92       	push	r2
    1f2e:	3f 92       	push	r3
    1f30:	4f 92       	push	r4
    1f32:	5f 92       	push	r5
    1f34:	6f 92       	push	r6
    1f36:	7f 92       	push	r7
    1f38:	8f 92       	push	r8
    1f3a:	9f 92       	push	r9
    1f3c:	af 92       	push	r10
    1f3e:	bf 92       	push	r11
    1f40:	cf 92       	push	r12
    1f42:	df 92       	push	r13
    1f44:	ef 92       	push	r14
    1f46:	ff 92       	push	r15
    1f48:	0f 93       	push	r16
    1f4a:	1f 93       	push	r17
    1f4c:	2f 93       	push	r18
    1f4e:	3f 93       	push	r19
    1f50:	4f 93       	push	r20
    1f52:	5f 93       	push	r21
    1f54:	6f 93       	push	r22
    1f56:	7f 93       	push	r23
    1f58:	8f 93       	push	r24
    1f5a:	9f 93       	push	r25
    1f5c:	af 93       	push	r26
    1f5e:	bf 93       	push	r27
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
    1f64:	ef 93       	push	r30
    1f66:	ff 93       	push	r31
    1f68:	a0 91 bf 07 	lds	r26, 0x07BF
    1f6c:	b0 91 c0 07 	lds	r27, 0x07C0
    1f70:	0d b6       	in	r0, 0x3d	; 61
    1f72:	0d 92       	st	X+, r0
    1f74:	0e b6       	in	r0, 0x3e	; 62
    1f76:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f78:	0e 94 54 1a 	call	0x34a8	; 0x34a8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1f7c:	a0 91 bf 07 	lds	r26, 0x07BF
    1f80:	b0 91 c0 07 	lds	r27, 0x07C0
    1f84:	cd 91       	ld	r28, X+
    1f86:	cd bf       	out	0x3d, r28	; 61
    1f88:	dd 91       	ld	r29, X+
    1f8a:	de bf       	out	0x3e, r29	; 62
    1f8c:	ff 91       	pop	r31
    1f8e:	ef 91       	pop	r30
    1f90:	df 91       	pop	r29
    1f92:	cf 91       	pop	r28
    1f94:	bf 91       	pop	r27
    1f96:	af 91       	pop	r26
    1f98:	9f 91       	pop	r25
    1f9a:	8f 91       	pop	r24
    1f9c:	7f 91       	pop	r23
    1f9e:	6f 91       	pop	r22
    1fa0:	5f 91       	pop	r21
    1fa2:	4f 91       	pop	r20
    1fa4:	3f 91       	pop	r19
    1fa6:	2f 91       	pop	r18
    1fa8:	1f 91       	pop	r17
    1faa:	0f 91       	pop	r16
    1fac:	ff 90       	pop	r15
    1fae:	ef 90       	pop	r14
    1fb0:	df 90       	pop	r13
    1fb2:	cf 90       	pop	r12
    1fb4:	bf 90       	pop	r11
    1fb6:	af 90       	pop	r10
    1fb8:	9f 90       	pop	r9
    1fba:	8f 90       	pop	r8
    1fbc:	7f 90       	pop	r7
    1fbe:	6f 90       	pop	r6
    1fc0:	5f 90       	pop	r5
    1fc2:	4f 90       	pop	r4
    1fc4:	3f 90       	pop	r3
    1fc6:	2f 90       	pop	r2
    1fc8:	1f 90       	pop	r1
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63
    1fce:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1fd0:	08 95       	ret

00001fd2 <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1fd2:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    1fd4:	0f b6       	in	r0, 0x3f	; 63
    1fd6:	f8 94       	cli
    1fd8:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1fda:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1fe0:	08 95       	ret

00001fe2 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1fe2:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    1fe4:	0f b6       	in	r0, 0x3f	; 63
    1fe6:	f8 94       	cli
    1fe8:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1fea:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    1fec:	0f 90       	pop	r0
    1fee:	0f be       	out	0x3f, r0	; 63
    1ff0:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ff2:	89 1b       	sub	r24, r25
    1ff4:	08 95       	ret

00001ff6 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1ff6:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    1ff8:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ffa:	08 95       	ret

00001ffc <xQueueIsQueueEmptyFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1ffc:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1ffe:	82 8d       	ldd	r24, Z+26	; 0x1a
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	88 23       	and	r24, r24
    2004:	09 f4       	brne	.+2      	; 0x2008 <xQueueIsQueueEmptyFromISR+0xc>
    2006:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2008:	89 2f       	mov	r24, r25
    200a:	08 95       	ret

0000200c <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    200c:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    200e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2010:	20 e0       	ldi	r18, 0x00	; 0
    2012:	83 8d       	ldd	r24, Z+27	; 0x1b
    2014:	98 17       	cp	r25, r24
    2016:	09 f4       	brne	.+2      	; 0x201a <xQueueIsQueueFullFromISR+0xe>
    2018:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    201a:	82 2f       	mov	r24, r18
    201c:	08 95       	ret

0000201e <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    201e:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    2022:	08 95       	ret

00002024 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    2024:	fc 01       	movw	r30, r24
    2026:	56 2f       	mov	r21, r22
    2028:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    202a:	24 8d       	ldd	r18, Z+28	; 0x1c
    202c:	22 23       	and	r18, r18
    202e:	b9 f0       	breq	.+46     	; 0x205e <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2030:	86 81       	ldd	r24, Z+6	; 0x06
    2032:	97 81       	ldd	r25, Z+7	; 0x07
    2034:	82 0f       	add	r24, r18
    2036:	91 1d       	adc	r25, r1
    2038:	97 83       	std	Z+7, r25	; 0x07
    203a:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    203c:	24 81       	ldd	r18, Z+4	; 0x04
    203e:	35 81       	ldd	r19, Z+5	; 0x05
    2040:	82 17       	cp	r24, r18
    2042:	93 07       	cpc	r25, r19
    2044:	20 f0       	brcs	.+8      	; 0x204e <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    2046:	80 81       	ld	r24, Z
    2048:	91 81       	ldd	r25, Z+1	; 0x01
    204a:	97 83       	std	Z+7, r25	; 0x07
    204c:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    204e:	44 8d       	ldd	r20, Z+28	; 0x1c
    2050:	66 81       	ldd	r22, Z+6	; 0x06
    2052:	77 81       	ldd	r23, Z+7	; 0x07
    2054:	85 2f       	mov	r24, r21
    2056:	9a 2f       	mov	r25, r26
    2058:	50 e0       	ldi	r21, 0x00	; 0
    205a:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>
    205e:	08 95       	ret

00002060 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    2060:	0f 93       	push	r16
    2062:	1f 93       	push	r17
    2064:	cf 93       	push	r28
    2066:	df 93       	push	r29
    2068:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    206a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    206c:	88 23       	and	r24, r24
    206e:	41 f0       	breq	.+16     	; 0x2080 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2070:	0e 81       	ldd	r16, Y+6	; 0x06
    2072:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    2074:	ce 01       	movw	r24, r28
    2076:	0e 94 12 10 	call	0x2024	; 0x2024 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    207a:	1f 83       	std	Y+7, r17	; 0x07
    207c:	0e 83       	std	Y+6, r16	; 0x06
    207e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	1f 91       	pop	r17
    2086:	0f 91       	pop	r16
    2088:	08 95       	ret

0000208a <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    208a:	0f 93       	push	r16
    208c:	1f 93       	push	r17
    208e:	cf 93       	push	r28
    2090:	df 93       	push	r29
    2092:	ec 01       	movw	r28, r24
    2094:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2096:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    2098:	4c 8d       	ldd	r20, Y+28	; 0x1c
    209a:	44 23       	and	r20, r20
    209c:	c1 f1       	breq	.+112    	; 0x210e <prvCopyDataToQueue+0x84>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    209e:	00 23       	and	r16, r16
    20a0:	b1 f4       	brne	.+44     	; 0x20ce <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    20a2:	8a 81       	ldd	r24, Y+2	; 0x02
    20a4:	9b 81       	ldd	r25, Y+3	; 0x03
    20a6:	50 e0       	ldi	r21, 0x00	; 0
    20a8:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    20ac:	8c 8d       	ldd	r24, Y+28	; 0x1c
    20ae:	2a 81       	ldd	r18, Y+2	; 0x02
    20b0:	3b 81       	ldd	r19, Y+3	; 0x03
    20b2:	28 0f       	add	r18, r24
    20b4:	31 1d       	adc	r19, r1
    20b6:	3b 83       	std	Y+3, r19	; 0x03
    20b8:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    20ba:	8c 81       	ldd	r24, Y+4	; 0x04
    20bc:	9d 81       	ldd	r25, Y+5	; 0x05
    20be:	28 17       	cp	r18, r24
    20c0:	39 07       	cpc	r19, r25
    20c2:	28 f1       	brcs	.+74     	; 0x210e <prvCopyDataToQueue+0x84>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    20c4:	88 81       	ld	r24, Y
    20c6:	99 81       	ldd	r25, Y+1	; 0x01
    20c8:	9b 83       	std	Y+3, r25	; 0x03
    20ca:	8a 83       	std	Y+2, r24	; 0x02
    20cc:	20 c0       	rjmp	.+64     	; 0x210e <prvCopyDataToQueue+0x84>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    20ce:	8e 81       	ldd	r24, Y+6	; 0x06
    20d0:	9f 81       	ldd	r25, Y+7	; 0x07
    20d2:	50 e0       	ldi	r21, 0x00	; 0
    20d4:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    20d8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    20da:	90 e0       	ldi	r25, 0x00	; 0
    20dc:	44 27       	eor	r20, r20
    20de:	55 27       	eor	r21, r21
    20e0:	48 1b       	sub	r20, r24
    20e2:	59 0b       	sbc	r21, r25
    20e4:	8e 81       	ldd	r24, Y+6	; 0x06
    20e6:	9f 81       	ldd	r25, Y+7	; 0x07
    20e8:	84 0f       	add	r24, r20
    20ea:	95 1f       	adc	r25, r21
    20ec:	9f 83       	std	Y+7, r25	; 0x07
    20ee:	8e 83       	std	Y+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    20f0:	28 81       	ld	r18, Y
    20f2:	39 81       	ldd	r19, Y+1	; 0x01
    20f4:	82 17       	cp	r24, r18
    20f6:	93 07       	cpc	r25, r19
    20f8:	30 f4       	brcc	.+12     	; 0x2106 <prvCopyDataToQueue+0x7c>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    20fa:	8c 81       	ldd	r24, Y+4	; 0x04
    20fc:	9d 81       	ldd	r25, Y+5	; 0x05
    20fe:	84 0f       	add	r24, r20
    2100:	95 1f       	adc	r25, r21
    2102:	9f 83       	std	Y+7, r25	; 0x07
    2104:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    2106:	02 30       	cpi	r16, 0x02	; 2
    2108:	11 f4       	brne	.+4      	; 0x210e <prvCopyDataToQueue+0x84>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    210a:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    210c:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    210e:	1f 5f       	subi	r17, 0xFF	; 255
    2110:	1a 8f       	std	Y+26, r17	; 0x1a

    return xReturn;
}
    2112:	80 e0       	ldi	r24, 0x00	; 0
    2114:	df 91       	pop	r29
    2116:	cf 91       	pop	r28
    2118:	1f 91       	pop	r17
    211a:	0f 91       	pop	r16
    211c:	08 95       	ret

0000211e <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    211e:	ef 92       	push	r14
    2120:	ff 92       	push	r15
    2122:	0f 93       	push	r16
    2124:	1f 93       	push	r17
    2126:	cf 93       	push	r28
    2128:	df 93       	push	r29
    212a:	ec 01       	movw	r28, r24
    212c:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    212e:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2130:	11 23       	and	r17, r17
    2132:	11 f4       	brne	.+4      	; 0x2138 <xQueueReceiveFromISR+0x1a>
    2134:	80 e0       	ldi	r24, 0x00	; 0
    2136:	1e c0       	rjmp	.+60     	; 0x2174 <xQueueReceiveFromISR+0x56>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    2138:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    213a:	0e 94 12 10 	call	0x2024	; 0x2024 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    213e:	11 50       	subi	r17, 0x01	; 1
    2140:	1a 8f       	std	Y+26, r17	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    2142:	0f 3f       	cpi	r16, 0xFF	; 255
    2144:	81 f4       	brne	.+32     	; 0x2166 <xQueueReceiveFromISR+0x48>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2146:	88 85       	ldd	r24, Y+8	; 0x08
    2148:	88 23       	and	r24, r24
    214a:	99 f0       	breq	.+38     	; 0x2172 <xQueueReceiveFromISR+0x54>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    214c:	ce 01       	movw	r24, r28
    214e:	08 96       	adiw	r24, 0x08	; 8
    2150:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2154:	88 23       	and	r24, r24
    2156:	69 f0       	breq	.+26     	; 0x2172 <xQueueReceiveFromISR+0x54>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    2158:	e1 14       	cp	r14, r1
    215a:	f1 04       	cpc	r15, r1
    215c:	51 f0       	breq	.+20     	; 0x2172 <xQueueReceiveFromISR+0x54>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    215e:	81 e0       	ldi	r24, 0x01	; 1
    2160:	f7 01       	movw	r30, r14
    2162:	80 83       	st	Z, r24
    2164:	07 c0       	rjmp	.+14     	; 0x2174 <xQueueReceiveFromISR+0x56>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    2166:	0e 94 2e 19 	call	0x325c	; 0x325c <uxTaskGetNumberOfTasks>
    216a:	08 17       	cp	r16, r24
    216c:	10 f4       	brcc	.+4      	; 0x2172 <xQueueReceiveFromISR+0x54>
    216e:	0f 5f       	subi	r16, 0xFF	; 255
    2170:	0d 8f       	std	Y+29, r16	; 0x1d
    2172:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2174:	df 91       	pop	r29
    2176:	cf 91       	pop	r28
    2178:	1f 91       	pop	r17
    217a:	0f 91       	pop	r16
    217c:	ff 90       	pop	r15
    217e:	ef 90       	pop	r14
    2180:	08 95       	ret

00002182 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    2182:	ef 92       	push	r14
    2184:	ff 92       	push	r15
    2186:	1f 93       	push	r17
    2188:	cf 93       	push	r28
    218a:	df 93       	push	r29
    218c:	ec 01       	movw	r28, r24
    218e:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2190:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    2192:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2194:	98 17       	cp	r25, r24
    2196:	10 f0       	brcs	.+4      	; 0x219c <xQueueGiveFromISR+0x1a>
    2198:	80 e0       	ldi	r24, 0x00	; 0
    219a:	1c c0       	rjmp	.+56     	; 0x21d4 <xQueueGiveFromISR+0x52>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    219c:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    219e:	9f 5f       	subi	r25, 0xFF	; 255
    21a0:	9a 8f       	std	Y+26, r25	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    21a2:	1f 3f       	cpi	r17, 0xFF	; 255
    21a4:	81 f4       	brne	.+32     	; 0x21c6 <xQueueGiveFromISR+0x44>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    21a6:	89 89       	ldd	r24, Y+17	; 0x11
    21a8:	88 23       	and	r24, r24
    21aa:	99 f0       	breq	.+38     	; 0x21d2 <xQueueGiveFromISR+0x50>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    21ac:	ce 01       	movw	r24, r28
    21ae:	41 96       	adiw	r24, 0x11	; 17
    21b0:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    21b4:	88 23       	and	r24, r24
    21b6:	69 f0       	breq	.+26     	; 0x21d2 <xQueueGiveFromISR+0x50>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    21b8:	e1 14       	cp	r14, r1
    21ba:	f1 04       	cpc	r15, r1
    21bc:	51 f0       	breq	.+20     	; 0x21d2 <xQueueGiveFromISR+0x50>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    21be:	81 e0       	ldi	r24, 0x01	; 1
    21c0:	f7 01       	movw	r30, r14
    21c2:	80 83       	st	Z, r24
    21c4:	07 c0       	rjmp	.+14     	; 0x21d4 <xQueueGiveFromISR+0x52>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    21c6:	0e 94 2e 19 	call	0x325c	; 0x325c <uxTaskGetNumberOfTasks>
    21ca:	18 17       	cp	r17, r24
    21cc:	10 f4       	brcc	.+4      	; 0x21d2 <xQueueGiveFromISR+0x50>
    21ce:	1f 5f       	subi	r17, 0xFF	; 255
    21d0:	1e 8f       	std	Y+30, r17	; 0x1e
    21d2:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    21d4:	df 91       	pop	r29
    21d6:	cf 91       	pop	r28
    21d8:	1f 91       	pop	r17
    21da:	ff 90       	pop	r15
    21dc:	ef 90       	pop	r14
    21de:	08 95       	ret

000021e0 <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    21e0:	ef 92       	push	r14
    21e2:	ff 92       	push	r15
    21e4:	1f 93       	push	r17
    21e6:	cf 93       	push	r28
    21e8:	df 93       	push	r29
    21ea:	ec 01       	movw	r28, r24
    21ec:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    21ee:	9a 8d       	ldd	r25, Y+26	; 0x1a
    21f0:	8b 8d       	ldd	r24, Y+27	; 0x1b
    21f2:	98 17       	cp	r25, r24
    21f4:	20 f0       	brcs	.+8      	; 0x21fe <xQueueGenericSendFromISR+0x1e>
    21f6:	22 30       	cpi	r18, 0x02	; 2
    21f8:	11 f0       	breq	.+4      	; 0x21fe <xQueueGenericSendFromISR+0x1e>
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	1f c0       	rjmp	.+62     	; 0x223c <xQueueGenericSendFromISR+0x5c>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    21fe:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    2200:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2202:	ce 01       	movw	r24, r28
    2204:	42 2f       	mov	r20, r18
    2206:	0e 94 45 10 	call	0x208a	; 0x208a <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    220a:	1f 3f       	cpi	r17, 0xFF	; 255
    220c:	81 f4       	brne	.+32     	; 0x222e <xQueueGenericSendFromISR+0x4e>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    220e:	89 89       	ldd	r24, Y+17	; 0x11
    2210:	88 23       	and	r24, r24
    2212:	99 f0       	breq	.+38     	; 0x223a <xQueueGenericSendFromISR+0x5a>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2214:	ce 01       	movw	r24, r28
    2216:	41 96       	adiw	r24, 0x11	; 17
    2218:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    221c:	88 23       	and	r24, r24
    221e:	69 f0       	breq	.+26     	; 0x223a <xQueueGenericSendFromISR+0x5a>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    2220:	e1 14       	cp	r14, r1
    2222:	f1 04       	cpc	r15, r1
    2224:	51 f0       	breq	.+20     	; 0x223a <xQueueGenericSendFromISR+0x5a>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    2226:	81 e0       	ldi	r24, 0x01	; 1
    2228:	f7 01       	movw	r30, r14
    222a:	80 83       	st	Z, r24
    222c:	07 c0       	rjmp	.+14     	; 0x223c <xQueueGenericSendFromISR+0x5c>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    222e:	0e 94 2e 19 	call	0x325c	; 0x325c <uxTaskGetNumberOfTasks>
    2232:	18 17       	cp	r17, r24
    2234:	10 f4       	brcc	.+4      	; 0x223a <xQueueGenericSendFromISR+0x5a>
    2236:	1f 5f       	subi	r17, 0xFF	; 255
    2238:	1e 8f       	std	Y+30, r17	; 0x1e
    223a:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    223c:	df 91       	pop	r29
    223e:	cf 91       	pop	r28
    2240:	1f 91       	pop	r17
    2242:	ff 90       	pop	r15
    2244:	ef 90       	pop	r14
    2246:	08 95       	ret

00002248 <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2248:	ef 92       	push	r14
    224a:	ff 92       	push	r15
    224c:	1f 93       	push	r17
    224e:	cf 93       	push	r28
    2250:	df 93       	push	r29
    2252:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    225a:	1e 8d       	ldd	r17, Y+30	; 0x1e
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    225c:	91 e1       	ldi	r25, 0x11	; 17
    225e:	e9 2e       	mov	r14, r25
    2260:	f1 2c       	mov	r15, r1
    2262:	ec 0e       	add	r14, r28
    2264:	fd 1e       	adc	r15, r29
    2266:	0b c0       	rjmp	.+22     	; 0x227e <prvUnlockQueue+0x36>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2268:	89 89       	ldd	r24, Y+17	; 0x11
    226a:	88 23       	and	r24, r24
    226c:	51 f0       	breq	.+20     	; 0x2282 <prvUnlockQueue+0x3a>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    226e:	c7 01       	movw	r24, r14
    2270:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2274:	88 23       	and	r24, r24
    2276:	11 f0       	breq	.+4      	; 0x227c <prvUnlockQueue+0x34>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    2278:	0e 94 2b 1c 	call	0x3856	; 0x3856 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    227c:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    227e:	11 16       	cp	r1, r17
    2280:	9c f3       	brlt	.-26     	; 0x2268 <prvUnlockQueue+0x20>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    2282:	8f ef       	ldi	r24, 0xFF	; 255
    2284:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    2286:	0f 90       	pop	r0
    2288:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    228a:	0f b6       	in	r0, 0x3f	; 63
    228c:	f8 94       	cli
    228e:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    2290:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2292:	88 e0       	ldi	r24, 0x08	; 8
    2294:	e8 2e       	mov	r14, r24
    2296:	f1 2c       	mov	r15, r1
    2298:	ec 0e       	add	r14, r28
    229a:	fd 1e       	adc	r15, r29
    229c:	0b c0       	rjmp	.+22     	; 0x22b4 <prvUnlockQueue+0x6c>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    229e:	88 85       	ldd	r24, Y+8	; 0x08
    22a0:	88 23       	and	r24, r24
    22a2:	51 f0       	breq	.+20     	; 0x22b8 <prvUnlockQueue+0x70>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    22a4:	c7 01       	movw	r24, r14
    22a6:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    22aa:	88 23       	and	r24, r24
    22ac:	11 f0       	breq	.+4      	; 0x22b2 <prvUnlockQueue+0x6a>
                {
                    vTaskMissedYield();
    22ae:	0e 94 2b 1c 	call	0x3856	; 0x3856 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    22b2:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    22b4:	11 16       	cp	r1, r17
    22b6:	9c f3       	brlt	.-26     	; 0x229e <prvUnlockQueue+0x56>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    22b8:	8f ef       	ldi	r24, 0xFF	; 255
    22ba:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    22bc:	0f 90       	pop	r0
    22be:	0f be       	out	0x3f, r0	; 63
}
    22c0:	df 91       	pop	r29
    22c2:	cf 91       	pop	r28
    22c4:	1f 91       	pop	r17
    22c6:	ff 90       	pop	r15
    22c8:	ef 90       	pop	r14
    22ca:	08 95       	ret

000022cc <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    22cc:	8f 92       	push	r8
    22ce:	9f 92       	push	r9
    22d0:	af 92       	push	r10
    22d2:	bf 92       	push	r11
    22d4:	cf 92       	push	r12
    22d6:	df 92       	push	r13
    22d8:	ef 92       	push	r14
    22da:	ff 92       	push	r15
    22dc:	0f 93       	push	r16
    22de:	1f 93       	push	r17
    22e0:	df 93       	push	r29
    22e2:	cf 93       	push	r28
    22e4:	00 d0       	rcall	.+0      	; 0x22e6 <xQueuePeek+0x1a>
    22e6:	00 d0       	rcall	.+0      	; 0x22e8 <xQueuePeek+0x1c>
    22e8:	0f 92       	push	r0
    22ea:	cd b7       	in	r28, 0x3d	; 61
    22ec:	de b7       	in	r29, 0x3e	; 62
    22ee:	7c 01       	movw	r14, r24
    22f0:	5b 01       	movw	r10, r22
    22f2:	5d 83       	std	Y+5, r21	; 0x05
    22f4:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22f6:	41 e1       	ldi	r20, 0x11	; 17
    22f8:	c4 2e       	mov	r12, r20
    22fa:	d1 2c       	mov	r13, r1
    22fc:	c8 0e       	add	r12, r24
    22fe:	d9 1e       	adc	r13, r25
    2300:	20 e0       	ldi	r18, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2302:	8e 01       	movw	r16, r28
    2304:	0f 5f       	subi	r16, 0xFF	; 255
    2306:	1f 4f       	sbci	r17, 0xFF	; 255

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2308:	34 e0       	ldi	r19, 0x04	; 4
    230a:	83 2e       	mov	r8, r19
    230c:	91 2c       	mov	r9, r1
    230e:	8c 0e       	add	r8, r28
    2310:	9d 1e       	adc	r9, r29
    2312:	01 c0       	rjmp	.+2      	; 0x2316 <xQueuePeek+0x4a>
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2314:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2316:	0f b6       	in	r0, 0x3f	; 63
    2318:	f8 94       	cli
    231a:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    231c:	f7 01       	movw	r30, r14
    231e:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2320:	88 23       	and	r24, r24
    2322:	b9 f0       	breq	.+46     	; 0x2352 <xQueuePeek+0x86>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    2324:	06 81       	ldd	r16, Z+6	; 0x06
    2326:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    2328:	c7 01       	movw	r24, r14
    232a:	b5 01       	movw	r22, r10
    232c:	0e 94 12 10 	call	0x2024	; 0x2024 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    2330:	f7 01       	movw	r30, r14
    2332:	17 83       	std	Z+7, r17	; 0x07
    2334:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2336:	81 89       	ldd	r24, Z+17	; 0x11
    2338:	88 23       	and	r24, r24
    233a:	39 f0       	breq	.+14     	; 0x234a <xQueuePeek+0x7e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    233c:	c6 01       	movw	r24, r12
    233e:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2342:	88 23       	and	r24, r24
    2344:	11 f0       	breq	.+4      	; 0x234a <xQueuePeek+0x7e>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    2346:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    234a:	0f 90       	pop	r0
    234c:	0f be       	out	0x3f, r0	; 63
    234e:	81 e0       	ldi	r24, 0x01	; 1
    2350:	54 c0       	rjmp	.+168    	; 0x23fa <xQueuePeek+0x12e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2352:	8c 81       	ldd	r24, Y+4	; 0x04
    2354:	9d 81       	ldd	r25, Y+5	; 0x05
    2356:	89 2b       	or	r24, r25
    2358:	21 f4       	brne	.+8      	; 0x2362 <xQueuePeek+0x96>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    235a:	0f 90       	pop	r0
    235c:	0f be       	out	0x3f, r0	; 63
    235e:	80 e0       	ldi	r24, 0x00	; 0
    2360:	4c c0       	rjmp	.+152    	; 0x23fa <xQueuePeek+0x12e>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    2362:	22 23       	and	r18, r18
    2364:	19 f4       	brne	.+6      	; 0x236c <xQueuePeek+0xa0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2366:	c8 01       	movw	r24, r16
    2368:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    2370:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2374:	0f b6       	in	r0, 0x3f	; 63
    2376:	f8 94       	cli
    2378:	0f 92       	push	r0
    237a:	f7 01       	movw	r30, r14
    237c:	85 8d       	ldd	r24, Z+29	; 0x1d
    237e:	8f 3f       	cpi	r24, 0xFF	; 255
    2380:	09 f4       	brne	.+2      	; 0x2384 <xQueuePeek+0xb8>
    2382:	15 8e       	std	Z+29, r1	; 0x1d
    2384:	f7 01       	movw	r30, r14
    2386:	86 8d       	ldd	r24, Z+30	; 0x1e
    2388:	8f 3f       	cpi	r24, 0xFF	; 255
    238a:	09 f4       	brne	.+2      	; 0x238e <xQueuePeek+0xc2>
    238c:	16 8e       	std	Z+30, r1	; 0x1e
    238e:	0f 90       	pop	r0
    2390:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2392:	c8 01       	movw	r24, r16
    2394:	b4 01       	movw	r22, r8
    2396:	0e 94 f6 1b 	call	0x37ec	; 0x37ec <xTaskCheckForTimeOut>
    239a:	88 23       	and	r24, r24
    239c:	f9 f4       	brne	.+62     	; 0x23dc <xQueuePeek+0x110>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    239e:	0f b6       	in	r0, 0x3f	; 63
    23a0:	f8 94       	cli
    23a2:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    23a4:	f7 01       	movw	r30, r14
    23a6:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    23a8:	0f 90       	pop	r0
    23aa:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23ac:	88 23       	and	r24, r24
    23ae:	81 f4       	brne	.+32     	; 0x23d0 <xQueuePeek+0x104>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23b0:	6c 81       	ldd	r22, Y+4	; 0x04
    23b2:	7d 81       	ldd	r23, Y+5	; 0x05
    23b4:	c6 01       	movw	r24, r12
    23b6:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    23ba:	c7 01       	movw	r24, r14
    23bc:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    23c0:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    23c4:	88 23       	and	r24, r24
    23c6:	09 f0       	breq	.+2      	; 0x23ca <xQueuePeek+0xfe>
    23c8:	a5 cf       	rjmp	.-182    	; 0x2314 <xQueuePeek+0x48>
                {
                    portYIELD_WITHIN_API();
    23ca:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    23ce:	a2 cf       	rjmp	.-188    	; 0x2314 <xQueuePeek+0x48>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    23d0:	c7 01       	movw	r24, r14
    23d2:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    23d6:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    23da:	9c cf       	rjmp	.-200    	; 0x2314 <xQueuePeek+0x48>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    23dc:	c7 01       	movw	r24, r14
    23de:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    23e2:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    23e6:	0f b6       	in	r0, 0x3f	; 63
    23e8:	f8 94       	cli
    23ea:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    23ec:	f7 01       	movw	r30, r14
    23ee:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    23f0:	0f 90       	pop	r0
    23f2:	0f be       	out	0x3f, r0	; 63
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23f4:	88 23       	and	r24, r24
    23f6:	09 f0       	breq	.+2      	; 0x23fa <xQueuePeek+0x12e>
    23f8:	8d cf       	rjmp	.-230    	; 0x2314 <xQueuePeek+0x48>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    23fa:	0f 90       	pop	r0
    23fc:	0f 90       	pop	r0
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	cf 91       	pop	r28
    2406:	df 91       	pop	r29
    2408:	1f 91       	pop	r17
    240a:	0f 91       	pop	r16
    240c:	ff 90       	pop	r15
    240e:	ef 90       	pop	r14
    2410:	df 90       	pop	r13
    2412:	cf 90       	pop	r12
    2414:	bf 90       	pop	r11
    2416:	af 90       	pop	r10
    2418:	9f 90       	pop	r9
    241a:	8f 90       	pop	r8
    241c:	08 95       	ret

0000241e <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    241e:	af 92       	push	r10
    2420:	bf 92       	push	r11
    2422:	cf 92       	push	r12
    2424:	df 92       	push	r13
    2426:	ef 92       	push	r14
    2428:	ff 92       	push	r15
    242a:	0f 93       	push	r16
    242c:	1f 93       	push	r17
    242e:	df 93       	push	r29
    2430:	cf 93       	push	r28
    2432:	00 d0       	rcall	.+0      	; 0x2434 <xQueueSemaphoreTake+0x16>
    2434:	00 d0       	rcall	.+0      	; 0x2436 <xQueueSemaphoreTake+0x18>
    2436:	0f 92       	push	r0
    2438:	cd b7       	in	r28, 0x3d	; 61
    243a:	de b7       	in	r29, 0x3e	; 62
    243c:	8c 01       	movw	r16, r24
    243e:	7d 83       	std	Y+5, r23	; 0x05
    2440:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2442:	61 e1       	ldi	r22, 0x11	; 17
    2444:	e6 2e       	mov	r14, r22
    2446:	f1 2c       	mov	r15, r1
    2448:	e8 0e       	add	r14, r24
    244a:	f9 1e       	adc	r15, r25
    244c:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    244e:	6e 01       	movw	r12, r28
    2450:	08 94       	sec
    2452:	c1 1c       	adc	r12, r1
    2454:	d1 1c       	adc	r13, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2456:	54 e0       	ldi	r21, 0x04	; 4
    2458:	a5 2e       	mov	r10, r21
    245a:	b1 2c       	mov	r11, r1
    245c:	ac 0e       	add	r10, r28
    245e:	bd 1e       	adc	r11, r29
    2460:	01 c0       	rjmp	.+2      	; 0x2464 <xQueueSemaphoreTake+0x46>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2462:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2464:	0f b6       	in	r0, 0x3f	; 63
    2466:	f8 94       	cli
    2468:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    246a:	f8 01       	movw	r30, r16
    246c:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    246e:	88 23       	and	r24, r24
    2470:	89 f0       	breq	.+34     	; 0x2494 <xQueueSemaphoreTake+0x76>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2472:	81 50       	subi	r24, 0x01	; 1
    2474:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2476:	80 85       	ldd	r24, Z+8	; 0x08
    2478:	88 23       	and	r24, r24
    247a:	41 f0       	breq	.+16     	; 0x248c <xQueueSemaphoreTake+0x6e>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    247c:	c8 01       	movw	r24, r16
    247e:	08 96       	adiw	r24, 0x08	; 8
    2480:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2484:	88 23       	and	r24, r24
    2486:	11 f0       	breq	.+4      	; 0x248c <xQueueSemaphoreTake+0x6e>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2488:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    248c:	0f 90       	pop	r0
    248e:	0f be       	out	0x3f, r0	; 63
    2490:	81 e0       	ldi	r24, 0x01	; 1
    2492:	54 c0       	rjmp	.+168    	; 0x253c <xQueueSemaphoreTake+0x11e>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    2494:	8c 81       	ldd	r24, Y+4	; 0x04
    2496:	9d 81       	ldd	r25, Y+5	; 0x05
    2498:	89 2b       	or	r24, r25
    249a:	21 f4       	brne	.+8      	; 0x24a4 <xQueueSemaphoreTake+0x86>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63
    24a0:	80 e0       	ldi	r24, 0x00	; 0
    24a2:	4c c0       	rjmp	.+152    	; 0x253c <xQueueSemaphoreTake+0x11e>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    24a4:	22 23       	and	r18, r18
    24a6:	19 f4       	brne	.+6      	; 0x24ae <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    24a8:	c6 01       	movw	r24, r12
    24aa:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    24ae:	0f 90       	pop	r0
    24b0:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    24b2:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    24b6:	0f b6       	in	r0, 0x3f	; 63
    24b8:	f8 94       	cli
    24ba:	0f 92       	push	r0
    24bc:	f8 01       	movw	r30, r16
    24be:	85 8d       	ldd	r24, Z+29	; 0x1d
    24c0:	8f 3f       	cpi	r24, 0xFF	; 255
    24c2:	09 f4       	brne	.+2      	; 0x24c6 <xQueueSemaphoreTake+0xa8>
    24c4:	15 8e       	std	Z+29, r1	; 0x1d
    24c6:	f8 01       	movw	r30, r16
    24c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    24ca:	8f 3f       	cpi	r24, 0xFF	; 255
    24cc:	09 f4       	brne	.+2      	; 0x24d0 <xQueueSemaphoreTake+0xb2>
    24ce:	16 8e       	std	Z+30, r1	; 0x1e
    24d0:	0f 90       	pop	r0
    24d2:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    24d4:	c6 01       	movw	r24, r12
    24d6:	b5 01       	movw	r22, r10
    24d8:	0e 94 f6 1b 	call	0x37ec	; 0x37ec <xTaskCheckForTimeOut>
    24dc:	88 23       	and	r24, r24
    24de:	f9 f4       	brne	.+62     	; 0x251e <xQueueSemaphoreTake+0x100>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    24e0:	0f b6       	in	r0, 0x3f	; 63
    24e2:	f8 94       	cli
    24e4:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    24e6:	f8 01       	movw	r30, r16
    24e8:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    24ea:	0f 90       	pop	r0
    24ec:	0f be       	out	0x3f, r0	; 63
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    24ee:	88 23       	and	r24, r24
    24f0:	81 f4       	brne	.+32     	; 0x2512 <xQueueSemaphoreTake+0xf4>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    24f2:	6c 81       	ldd	r22, Y+4	; 0x04
    24f4:	7d 81       	ldd	r23, Y+5	; 0x05
    24f6:	c7 01       	movw	r24, r14
    24f8:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    24fc:	c8 01       	movw	r24, r16
    24fe:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2502:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    2506:	88 23       	and	r24, r24
    2508:	09 f0       	breq	.+2      	; 0x250c <xQueueSemaphoreTake+0xee>
    250a:	ab cf       	rjmp	.-170    	; 0x2462 <xQueueSemaphoreTake+0x44>
                {
                    portYIELD_WITHIN_API();
    250c:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    2510:	a8 cf       	rjmp	.-176    	; 0x2462 <xQueueSemaphoreTake+0x44>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    2512:	c8 01       	movw	r24, r16
    2514:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2518:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    251c:	a2 cf       	rjmp	.-188    	; 0x2462 <xQueueSemaphoreTake+0x44>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    251e:	c8 01       	movw	r24, r16
    2520:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2524:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2528:	0f b6       	in	r0, 0x3f	; 63
    252a:	f8 94       	cli
    252c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    252e:	f8 01       	movw	r30, r16
    2530:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    2532:	0f 90       	pop	r0
    2534:	0f be       	out	0x3f, r0	; 63

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2536:	88 23       	and	r24, r24
    2538:	09 f0       	breq	.+2      	; 0x253c <xQueueSemaphoreTake+0x11e>
    253a:	93 cf       	rjmp	.-218    	; 0x2462 <xQueueSemaphoreTake+0x44>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    253c:	0f 90       	pop	r0
    253e:	0f 90       	pop	r0
    2540:	0f 90       	pop	r0
    2542:	0f 90       	pop	r0
    2544:	0f 90       	pop	r0
    2546:	cf 91       	pop	r28
    2548:	df 91       	pop	r29
    254a:	1f 91       	pop	r17
    254c:	0f 91       	pop	r16
    254e:	ff 90       	pop	r15
    2550:	ef 90       	pop	r14
    2552:	df 90       	pop	r13
    2554:	cf 90       	pop	r12
    2556:	bf 90       	pop	r11
    2558:	af 90       	pop	r10
    255a:	08 95       	ret

0000255c <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    255c:	6f 92       	push	r6
    255e:	7f 92       	push	r7
    2560:	8f 92       	push	r8
    2562:	9f 92       	push	r9
    2564:	af 92       	push	r10
    2566:	bf 92       	push	r11
    2568:	cf 92       	push	r12
    256a:	df 92       	push	r13
    256c:	ff 92       	push	r15
    256e:	0f 93       	push	r16
    2570:	1f 93       	push	r17
    2572:	df 93       	push	r29
    2574:	cf 93       	push	r28
    2576:	00 d0       	rcall	.+0      	; 0x2578 <xQueueReceive+0x1c>
    2578:	00 d0       	rcall	.+0      	; 0x257a <xQueueReceive+0x1e>
    257a:	0f 92       	push	r0
    257c:	cd b7       	in	r28, 0x3d	; 61
    257e:	de b7       	in	r29, 0x3e	; 62
    2580:	8c 01       	movw	r16, r24
    2582:	5b 01       	movw	r10, r22
    2584:	5d 83       	std	Y+5, r21	; 0x05
    2586:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2588:	e1 e1       	ldi	r30, 0x11	; 17
    258a:	ce 2e       	mov	r12, r30
    258c:	d1 2c       	mov	r13, r1
    258e:	c8 0e       	add	r12, r24
    2590:	d9 1e       	adc	r13, r25
    2592:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    2594:	4e 01       	movw	r8, r28
    2596:	08 94       	sec
    2598:	81 1c       	adc	r8, r1
    259a:	91 1c       	adc	r9, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    259c:	74 e0       	ldi	r23, 0x04	; 4
    259e:	67 2e       	mov	r6, r23
    25a0:	71 2c       	mov	r7, r1
    25a2:	6c 0e       	add	r6, r28
    25a4:	7d 1e       	adc	r7, r29
    25a6:	01 c0       	rjmp	.+2      	; 0x25aa <xQueueReceive+0x4e>
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    25a8:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    25aa:	0f b6       	in	r0, 0x3f	; 63
    25ac:	f8 94       	cli
    25ae:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25b0:	f8 01       	movw	r30, r16
    25b2:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25b4:	ff 20       	and	r15, r15
    25b6:	b1 f0       	breq	.+44     	; 0x25e4 <xQueueReceive+0x88>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    25b8:	c8 01       	movw	r24, r16
    25ba:	b5 01       	movw	r22, r10
    25bc:	0e 94 12 10 	call	0x2024	; 0x2024 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    25c0:	fa 94       	dec	r15
    25c2:	f8 01       	movw	r30, r16
    25c4:	f2 8e       	std	Z+26, r15	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25c6:	80 85       	ldd	r24, Z+8	; 0x08
    25c8:	88 23       	and	r24, r24
    25ca:	41 f0       	breq	.+16     	; 0x25dc <xQueueReceive+0x80>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    25cc:	c8 01       	movw	r24, r16
    25ce:	08 96       	adiw	r24, 0x08	; 8
    25d0:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    25d4:	88 23       	and	r24, r24
    25d6:	11 f0       	breq	.+4      	; 0x25dc <xQueueReceive+0x80>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    25d8:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    25dc:	0f 90       	pop	r0
    25de:	0f be       	out	0x3f, r0	; 63
    25e0:	81 e0       	ldi	r24, 0x01	; 1
    25e2:	54 c0       	rjmp	.+168    	; 0x268c <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    25e4:	8c 81       	ldd	r24, Y+4	; 0x04
    25e6:	9d 81       	ldd	r25, Y+5	; 0x05
    25e8:	89 2b       	or	r24, r25
    25ea:	21 f4       	brne	.+8      	; 0x25f4 <xQueueReceive+0x98>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    25ec:	0f 90       	pop	r0
    25ee:	0f be       	out	0x3f, r0	; 63
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	4c c0       	rjmp	.+152    	; 0x268c <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    25f4:	22 23       	and	r18, r18
    25f6:	19 f4       	brne	.+6      	; 0x25fe <xQueueReceive+0xa2>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    25f8:	c4 01       	movw	r24, r8
    25fa:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    25fe:	0f 90       	pop	r0
    2600:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2602:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    2606:	0f b6       	in	r0, 0x3f	; 63
    2608:	f8 94       	cli
    260a:	0f 92       	push	r0
    260c:	f8 01       	movw	r30, r16
    260e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2610:	8f 3f       	cpi	r24, 0xFF	; 255
    2612:	09 f4       	brne	.+2      	; 0x2616 <xQueueReceive+0xba>
    2614:	15 8e       	std	Z+29, r1	; 0x1d
    2616:	f8 01       	movw	r30, r16
    2618:	86 8d       	ldd	r24, Z+30	; 0x1e
    261a:	8f 3f       	cpi	r24, 0xFF	; 255
    261c:	09 f4       	brne	.+2      	; 0x2620 <xQueueReceive+0xc4>
    261e:	16 8e       	std	Z+30, r1	; 0x1e
    2620:	0f 90       	pop	r0
    2622:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2624:	c4 01       	movw	r24, r8
    2626:	b3 01       	movw	r22, r6
    2628:	0e 94 f6 1b 	call	0x37ec	; 0x37ec <xTaskCheckForTimeOut>
    262c:	88 23       	and	r24, r24
    262e:	f9 f4       	brne	.+62     	; 0x266e <xQueueReceive+0x112>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2630:	0f b6       	in	r0, 0x3f	; 63
    2632:	f8 94       	cli
    2634:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2636:	f8 01       	movw	r30, r16
    2638:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    263a:	0f 90       	pop	r0
    263c:	0f be       	out	0x3f, r0	; 63
        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    263e:	88 23       	and	r24, r24
    2640:	81 f4       	brne	.+32     	; 0x2662 <xQueueReceive+0x106>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2642:	6c 81       	ldd	r22, Y+4	; 0x04
    2644:	7d 81       	ldd	r23, Y+5	; 0x05
    2646:	c6 01       	movw	r24, r12
    2648:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    264c:	c8 01       	movw	r24, r16
    264e:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    2652:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    2656:	88 23       	and	r24, r24
    2658:	09 f0       	breq	.+2      	; 0x265c <xQueueReceive+0x100>
    265a:	a6 cf       	rjmp	.-180    	; 0x25a8 <xQueueReceive+0x4c>
                {
                    portYIELD_WITHIN_API();
    265c:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    2660:	a3 cf       	rjmp	.-186    	; 0x25a8 <xQueueReceive+0x4c>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    2662:	c8 01       	movw	r24, r16
    2664:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    2668:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    266c:	9d cf       	rjmp	.-198    	; 0x25a8 <xQueueReceive+0x4c>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    266e:	c8 01       	movw	r24, r16
    2670:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    2674:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2678:	0f b6       	in	r0, 0x3f	; 63
    267a:	f8 94       	cli
    267c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    267e:	f8 01       	movw	r30, r16
    2680:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    2682:	0f 90       	pop	r0
    2684:	0f be       	out	0x3f, r0	; 63
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
            ( void ) xTaskResumeAll();

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2686:	88 23       	and	r24, r24
    2688:	09 f0       	breq	.+2      	; 0x268c <xQueueReceive+0x130>
    268a:	8e cf       	rjmp	.-228    	; 0x25a8 <xQueueReceive+0x4c>
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    268c:	0f 90       	pop	r0
    268e:	0f 90       	pop	r0
    2690:	0f 90       	pop	r0
    2692:	0f 90       	pop	r0
    2694:	0f 90       	pop	r0
    2696:	cf 91       	pop	r28
    2698:	df 91       	pop	r29
    269a:	1f 91       	pop	r17
    269c:	0f 91       	pop	r16
    269e:	ff 90       	pop	r15
    26a0:	df 90       	pop	r13
    26a2:	cf 90       	pop	r12
    26a4:	bf 90       	pop	r11
    26a6:	af 90       	pop	r10
    26a8:	9f 90       	pop	r9
    26aa:	8f 90       	pop	r8
    26ac:	7f 90       	pop	r7
    26ae:	6f 90       	pop	r6
    26b0:	08 95       	ret

000026b2 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    26b2:	6f 92       	push	r6
    26b4:	7f 92       	push	r7
    26b6:	9f 92       	push	r9
    26b8:	af 92       	push	r10
    26ba:	bf 92       	push	r11
    26bc:	cf 92       	push	r12
    26be:	df 92       	push	r13
    26c0:	ef 92       	push	r14
    26c2:	ff 92       	push	r15
    26c4:	0f 93       	push	r16
    26c6:	1f 93       	push	r17
    26c8:	df 93       	push	r29
    26ca:	cf 93       	push	r28
    26cc:	00 d0       	rcall	.+0      	; 0x26ce <xQueueGenericSend+0x1c>
    26ce:	00 d0       	rcall	.+0      	; 0x26d0 <xQueueGenericSend+0x1e>
    26d0:	0f 92       	push	r0
    26d2:	cd b7       	in	r28, 0x3d	; 61
    26d4:	de b7       	in	r29, 0x3e	; 62
    26d6:	8c 01       	movw	r16, r24
    26d8:	6b 01       	movw	r12, r22
    26da:	5d 83       	std	Y+5, r21	; 0x05
    26dc:	4c 83       	std	Y+4, r20	; 0x04
    26de:	92 2e       	mov	r9, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    26e0:	a8 e0       	ldi	r26, 0x08	; 8
    26e2:	ea 2e       	mov	r14, r26
    26e4:	f1 2c       	mov	r15, r1
    26e6:	e8 0e       	add	r14, r24
    26e8:	f9 1e       	adc	r15, r25
    26ea:	20 e0       	ldi	r18, 0x00	; 0
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    26ec:	5e 01       	movw	r10, r28
    26ee:	08 94       	sec
    26f0:	a1 1c       	adc	r10, r1
    26f2:	b1 1c       	adc	r11, r1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    26f4:	f4 e0       	ldi	r31, 0x04	; 4
    26f6:	6f 2e       	mov	r6, r31
    26f8:	71 2c       	mov	r7, r1
    26fa:	6c 0e       	add	r6, r28
    26fc:	7d 1e       	adc	r7, r29
    26fe:	01 c0       	rjmp	.+2      	; 0x2702 <xQueueGenericSend+0x50>
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2700:	21 e0       	ldi	r18, 0x01	; 1
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    2702:	0f b6       	in	r0, 0x3f	; 63
    2704:	f8 94       	cli
    2706:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2708:	f8 01       	movw	r30, r16
    270a:	92 8d       	ldd	r25, Z+26	; 0x1a
    270c:	83 8d       	ldd	r24, Z+27	; 0x1b
    270e:	98 17       	cp	r25, r24
    2710:	18 f0       	brcs	.+6      	; 0x2718 <xQueueGenericSend+0x66>
    2712:	f2 e0       	ldi	r31, 0x02	; 2
    2714:	9f 16       	cp	r9, r31
    2716:	c9 f4       	brne	.+50     	; 0x274a <xQueueGenericSend+0x98>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2718:	c8 01       	movw	r24, r16
    271a:	b6 01       	movw	r22, r12
    271c:	49 2d       	mov	r20, r9
    271e:	0e 94 45 10 	call	0x208a	; 0x208a <prvCopyDataToQueue>
    2722:	98 2f       	mov	r25, r24

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2724:	f8 01       	movw	r30, r16
    2726:	81 89       	ldd	r24, Z+17	; 0x11
    2728:	88 23       	and	r24, r24
    272a:	39 f0       	breq	.+14     	; 0x273a <xQueueGenericSend+0x88>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    272c:	c8 01       	movw	r24, r16
    272e:	41 96       	adiw	r24, 0x11	; 17
    2730:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2734:	88 23       	and	r24, r24
    2736:	29 f0       	breq	.+10     	; 0x2742 <xQueueGenericSend+0x90>
    2738:	02 c0       	rjmp	.+4      	; 0x273e <xQueueGenericSend+0x8c>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    273a:	99 23       	and	r25, r25
    273c:	11 f0       	breq	.+4      	; 0x2742 <xQueueGenericSend+0x90>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    273e:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    2742:	0f 90       	pop	r0
    2744:	0f be       	out	0x3f, r0	; 63
    2746:	81 e0       	ldi	r24, 0x01	; 1
    2748:	4c c0       	rjmp	.+152    	; 0x27e2 <xQueueGenericSend+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    274a:	8c 81       	ldd	r24, Y+4	; 0x04
    274c:	9d 81       	ldd	r25, Y+5	; 0x05
    274e:	89 2b       	or	r24, r25
    2750:	19 f4       	brne	.+6      	; 0x2758 <xQueueGenericSend+0xa6>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	44 c0       	rjmp	.+136    	; 0x27e0 <xQueueGenericSend+0x12e>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    2758:	22 23       	and	r18, r18
    275a:	19 f4       	brne	.+6      	; 0x2762 <xQueueGenericSend+0xb0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    275c:	c5 01       	movw	r24, r10
    275e:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <vTaskInternalSetTimeOutState>
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    2762:	0f 90       	pop	r0
    2764:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    2766:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    276a:	0f b6       	in	r0, 0x3f	; 63
    276c:	f8 94       	cli
    276e:	0f 92       	push	r0
    2770:	f8 01       	movw	r30, r16
    2772:	85 8d       	ldd	r24, Z+29	; 0x1d
    2774:	8f 3f       	cpi	r24, 0xFF	; 255
    2776:	09 f4       	brne	.+2      	; 0x277a <xQueueGenericSend+0xc8>
    2778:	15 8e       	std	Z+29, r1	; 0x1d
    277a:	f8 01       	movw	r30, r16
    277c:	86 8d       	ldd	r24, Z+30	; 0x1e
    277e:	8f 3f       	cpi	r24, 0xFF	; 255
    2780:	09 f4       	brne	.+2      	; 0x2784 <xQueueGenericSend+0xd2>
    2782:	16 8e       	std	Z+30, r1	; 0x1e
    2784:	0f 90       	pop	r0
    2786:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2788:	c5 01       	movw	r24, r10
    278a:	b3 01       	movw	r22, r6
    278c:	0e 94 f6 1b 	call	0x37ec	; 0x37ec <xTaskCheckForTimeOut>
    2790:	88 23       	and	r24, r24
    2792:	09 f5       	brne	.+66     	; 0x27d6 <xQueueGenericSend+0x124>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    2794:	0f b6       	in	r0, 0x3f	; 63
    2796:	f8 94       	cli
    2798:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    279a:	f8 01       	movw	r30, r16
    279c:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    279e:	0f 90       	pop	r0
    27a0:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    27a2:	f8 01       	movw	r30, r16
    27a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    27a6:	98 17       	cp	r25, r24
    27a8:	81 f4       	brne	.+32     	; 0x27ca <xQueueGenericSend+0x118>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    27aa:	6c 81       	ldd	r22, Y+4	; 0x04
    27ac:	7d 81       	ldd	r23, Y+5	; 0x05
    27ae:	c7 01       	movw	r24, r14
    27b0:	0e 94 ea 21 	call	0x43d4	; 0x43d4 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    27b4:	c8 01       	movw	r24, r16
    27b6:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    27ba:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    27be:	88 23       	and	r24, r24
    27c0:	09 f0       	breq	.+2      	; 0x27c4 <xQueueGenericSend+0x112>
    27c2:	9e cf       	rjmp	.-196    	; 0x2700 <xQueueGenericSend+0x4e>
                {
                    portYIELD_WITHIN_API();
    27c4:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    27c8:	9b cf       	rjmp	.-202    	; 0x2700 <xQueueGenericSend+0x4e>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    27ca:	c8 01       	movw	r24, r16
    27cc:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    27d0:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    27d4:	95 cf       	rjmp	.-214    	; 0x2700 <xQueueGenericSend+0x4e>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    27d6:	c8 01       	movw	r24, r16
    27d8:	0e 94 24 11 	call	0x2248	; 0x2248 <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    27dc:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
    27e0:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    27e2:	0f 90       	pop	r0
    27e4:	0f 90       	pop	r0
    27e6:	0f 90       	pop	r0
    27e8:	0f 90       	pop	r0
    27ea:	0f 90       	pop	r0
    27ec:	cf 91       	pop	r28
    27ee:	df 91       	pop	r29
    27f0:	1f 91       	pop	r17
    27f2:	0f 91       	pop	r16
    27f4:	ff 90       	pop	r15
    27f6:	ef 90       	pop	r14
    27f8:	df 90       	pop	r13
    27fa:	cf 90       	pop	r12
    27fc:	bf 90       	pop	r11
    27fe:	af 90       	pop	r10
    2800:	9f 90       	pop	r9
    2802:	7f 90       	pop	r7
    2804:	6f 90       	pop	r6
    2806:	08 95       	ret

00002808 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    2808:	cf 93       	push	r28
    280a:	df 93       	push	r29
    280c:	ec 01       	movw	r28, r24
    280e:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    2810:	00 97       	sbiw	r24, 0x00	; 0
    2812:	09 f4       	brne	.+2      	; 0x2816 <xQueueGenericReset+0xe>
    2814:	4f c0       	rjmp	.+158    	; 0x28b4 <xQueueGenericReset+0xac>
    2816:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2818:	22 23       	and	r18, r18
    281a:	09 f4       	brne	.+2      	; 0x281e <xQueueGenericReset+0x16>
    281c:	4b c0       	rjmp	.+150    	; 0x28b4 <xQueueGenericReset+0xac>
    281e:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2820:	8f ef       	ldi	r24, 0xFF	; 255
    2822:	9f e7       	ldi	r25, 0x7F	; 127
    2824:	62 2f       	mov	r22, r18
    2826:	70 e0       	ldi	r23, 0x00	; 0
    2828:	0e 94 f7 23 	call	0x47ee	; 0x47ee <__udivmodhi4>
    282c:	83 2f       	mov	r24, r19
    282e:	90 e0       	ldi	r25, 0x00	; 0
    2830:	68 17       	cp	r22, r24
    2832:	79 07       	cpc	r23, r25
    2834:	08 f4       	brcc	.+2      	; 0x2838 <xQueueGenericReset+0x30>
    2836:	3e c0       	rjmp	.+124    	; 0x28b4 <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    2838:	0f b6       	in	r0, 0x3f	; 63
    283a:	f8 94       	cli
    283c:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    283e:	32 9f       	mul	r19, r18
    2840:	c0 01       	movw	r24, r0
    2842:	11 24       	eor	r1, r1
    2844:	48 81       	ld	r20, Y
    2846:	59 81       	ldd	r21, Y+1	; 0x01
    2848:	84 0f       	add	r24, r20
    284a:	95 1f       	adc	r25, r21
    284c:	9d 83       	std	Y+5, r25	; 0x05
    284e:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    2850:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    2852:	5b 83       	std	Y+3, r21	; 0x03
    2854:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    2856:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2858:	30 e0       	ldi	r19, 0x00	; 0
    285a:	21 50       	subi	r18, 0x01	; 1
    285c:	30 40       	sbci	r19, 0x00	; 0
    285e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2860:	90 e0       	ldi	r25, 0x00	; 0
    2862:	bc 01       	movw	r22, r24
    2864:	26 9f       	mul	r18, r22
    2866:	c0 01       	movw	r24, r0
    2868:	27 9f       	mul	r18, r23
    286a:	90 0d       	add	r25, r0
    286c:	36 9f       	mul	r19, r22
    286e:	90 0d       	add	r25, r0
    2870:	11 24       	eor	r1, r1
    2872:	48 0f       	add	r20, r24
    2874:	59 1f       	adc	r21, r25
    2876:	5f 83       	std	Y+7, r21	; 0x07
    2878:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    287a:	8f ef       	ldi	r24, 0xFF	; 255
    287c:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    287e:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    2880:	ee 23       	and	r30, r30
    2882:	61 f4       	brne	.+24     	; 0x289c <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2884:	88 85       	ldd	r24, Y+8	; 0x08
    2886:	88 23       	and	r24, r24
    2888:	89 f0       	breq	.+34     	; 0x28ac <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    288a:	ce 01       	movw	r24, r28
    288c:	08 96       	adiw	r24, 0x08	; 8
    288e:	0e 94 8e 1a 	call	0x351c	; 0x351c <xTaskRemoveFromEventList>
    2892:	88 23       	and	r24, r24
    2894:	59 f0       	breq	.+22     	; 0x28ac <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    2896:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    289a:	08 c0       	rjmp	.+16     	; 0x28ac <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    289c:	ce 01       	movw	r24, r28
    289e:	08 96       	adiw	r24, 0x08	; 8
    28a0:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    28a4:	ce 01       	movw	r24, r28
    28a6:	41 96       	adiw	r24, 0x11	; 17
    28a8:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    28ac:	0f 90       	pop	r0
    28ae:	0f be       	out	0x3f, r0	; 63
    28b0:	81 e0       	ldi	r24, 0x01	; 1
    28b2:	01 c0       	rjmp	.+2      	; 0x28b6 <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    28b4:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    28b6:	df 91       	pop	r29
    28b8:	cf 91       	pop	r28
    28ba:	08 95       	ret

000028bc <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    28bc:	0f 93       	push	r16
    28be:	1f 93       	push	r17
    28c0:	cf 93       	push	r28
    28c2:	df 93       	push	r29
    28c4:	18 2f       	mov	r17, r24
    28c6:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    28c8:	88 23       	and	r24, r24
    28ca:	41 f1       	breq	.+80     	; 0x291c <xQueueGenericCreate+0x60>
    28cc:	8f ef       	ldi	r24, 0xFF	; 255
    28ce:	9f e7       	ldi	r25, 0x7F	; 127
    28d0:	61 2f       	mov	r22, r17
    28d2:	70 e0       	ldi	r23, 0x00	; 0
    28d4:	0e 94 f7 23 	call	0x47ee	; 0x47ee <__udivmodhi4>
    28d8:	80 2f       	mov	r24, r16
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	68 17       	cp	r22, r24
    28de:	79 07       	cpc	r23, r25
    28e0:	e8 f0       	brcs	.+58     	; 0x291c <xQueueGenericCreate+0x60>
    28e2:	01 9f       	mul	r16, r17
    28e4:	c0 01       	movw	r24, r0
    28e6:	11 24       	eor	r1, r1
    28e8:	2f e7       	ldi	r18, 0x7F	; 127
    28ea:	81 3e       	cpi	r24, 0xE1	; 225
    28ec:	92 07       	cpc	r25, r18
    28ee:	b0 f4       	brcc	.+44     	; 0x291c <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    28f0:	4f 96       	adiw	r24, 0x1f	; 31
    28f2:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    28f6:	fc 01       	movw	r30, r24
    28f8:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    28fa:	00 97       	sbiw	r24, 0x00	; 0
    28fc:	89 f0       	breq	.+34     	; 0x2920 <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    28fe:	00 23       	and	r16, r16
    2900:	19 f4       	brne	.+6      	; 0x2908 <xQueueGenericCreate+0x4c>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    2902:	91 83       	std	Z+1, r25	; 0x01
    2904:	80 83       	st	Z, r24
    2906:	03 c0       	rjmp	.+6      	; 0x290e <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    2908:	4f 96       	adiw	r24, 0x1f	; 31
    290a:	91 83       	std	Z+1, r25	; 0x01
    290c:	80 83       	st	Z, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    290e:	13 8f       	std	Z+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    2910:	04 8f       	std	Z+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    2912:	cf 01       	movw	r24, r30
    2914:	61 e0       	ldi	r22, 0x01	; 1
    2916:	0e 94 04 14 	call	0x2808	; 0x2808 <xQueueGenericReset>
    291a:	02 c0       	rjmp	.+4      	; 0x2920 <xQueueGenericCreate+0x64>
    291c:	c0 e0       	ldi	r28, 0x00	; 0
    291e:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    2920:	ce 01       	movw	r24, r28
    2922:	df 91       	pop	r29
    2924:	cf 91       	pop	r28
    2926:	1f 91       	pop	r17
    2928:	0f 91       	pop	r16
    292a:	08 95       	ret

0000292c <xStreamBufferSetTriggerLevel>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    292c:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    292e:	61 15       	cp	r22, r1
    2930:	71 05       	cpc	r23, r1
    2932:	11 f4       	brne	.+4      	; 0x2938 <xStreamBufferSetTriggerLevel+0xc>
    2934:	61 e0       	ldi	r22, 0x01	; 1
    2936:	70 e0       	ldi	r23, 0x00	; 0
        xTriggerLevel = ( size_t ) 1;
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    2938:	84 81       	ldd	r24, Z+4	; 0x04
    293a:	95 81       	ldd	r25, Z+5	; 0x05
    293c:	68 17       	cp	r22, r24
    293e:	79 07       	cpc	r23, r25
    2940:	10 f0       	brcs	.+4      	; 0x2946 <xStreamBufferSetTriggerLevel+0x1a>
    2942:	80 e0       	ldi	r24, 0x00	; 0
    2944:	08 95       	ret
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2946:	77 83       	std	Z+7, r23	; 0x07
    2948:	66 83       	std	Z+6, r22	; 0x06
    294a:	81 e0       	ldi	r24, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    294c:	08 95       	ret

0000294e <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    294e:	fc 01       	movw	r30, r24
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2950:	64 81       	ldd	r22, Z+4	; 0x04
    2952:	75 81       	ldd	r23, Z+5	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    2954:	20 81       	ld	r18, Z
    2956:	31 81       	ldd	r19, Z+1	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2958:	40 81       	ld	r20, Z
    295a:	51 81       	ldd	r21, Z+1	; 0x01
        xSpace -= pxStreamBuffer->xHead;
    295c:	82 81       	ldd	r24, Z+2	; 0x02
    295e:	93 81       	ldd	r25, Z+3	; 0x03
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    2960:	46 0f       	add	r20, r22
    2962:	57 1f       	adc	r21, r23
        xSpace -= pxStreamBuffer->xHead;
    2964:	48 1b       	sub	r20, r24
    2966:	59 0b       	sbc	r21, r25
    } while( xOriginalTail != pxStreamBuffer->xTail );
    2968:	80 81       	ld	r24, Z
    296a:	91 81       	ldd	r25, Z+1	; 0x01
    296c:	28 17       	cp	r18, r24
    296e:	39 07       	cpc	r19, r25
    2970:	89 f7       	brne	.-30     	; 0x2954 <xStreamBufferSpacesAvailable+0x6>

    xSpace -= ( size_t ) 1;
    2972:	9a 01       	movw	r18, r20
    2974:	21 50       	subi	r18, 0x01	; 1
    2976:	30 40       	sbci	r19, 0x00	; 0

    if( xSpace >= pxStreamBuffer->xLength )
    2978:	26 17       	cp	r18, r22
    297a:	37 07       	cpc	r19, r23
    297c:	10 f0       	brcs	.+4      	; 0x2982 <xStreamBufferSpacesAvailable+0x34>
    {
        xSpace -= pxStreamBuffer->xLength;
    297e:	26 1b       	sub	r18, r22
    2980:	37 0b       	sbc	r19, r23
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
}
    2982:	c9 01       	movw	r24, r18
    2984:	08 95       	ret

00002986 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2986:	fc 01       	movw	r30, r24
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2988:	44 81       	ldd	r20, Z+4	; 0x04
    298a:	55 81       	ldd	r21, Z+5	; 0x05
    298c:	22 81       	ldd	r18, Z+2	; 0x02
    298e:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2990:	80 81       	ld	r24, Z
    2992:	91 81       	ldd	r25, Z+1	; 0x01
    2994:	24 0f       	add	r18, r20
    2996:	35 1f       	adc	r19, r21
    2998:	28 1b       	sub	r18, r24
    299a:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    299c:	24 17       	cp	r18, r20
    299e:	35 07       	cpc	r19, r21
    29a0:	10 f0       	brcs	.+4      	; 0x29a6 <xStreamBufferBytesAvailable+0x20>
    {
        xCount -= pxStreamBuffer->xLength;
    29a2:	24 1b       	sub	r18, r20
    29a4:	35 0b       	sbc	r19, r21

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    return xReturn;
}
    29a6:	c9 01       	movw	r24, r18
    29a8:	08 95       	ret

000029aa <xStreamBufferIsEmpty>:
    return xCount;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    29aa:	fc 01       	movw	r30, r24
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    29ac:	20 81       	ld	r18, Z
    29ae:	31 81       	ldd	r19, Z+1	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    29b0:	82 81       	ldd	r24, Z+2	; 0x02
    29b2:	93 81       	ldd	r25, Z+3	; 0x03
    29b4:	40 e0       	ldi	r20, 0x00	; 0
    29b6:	82 17       	cp	r24, r18
    29b8:	93 07       	cpc	r25, r19
    29ba:	09 f4       	brne	.+2      	; 0x29be <xStreamBufferIsEmpty+0x14>
    29bc:	41 e0       	ldi	r20, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    29be:	84 2f       	mov	r24, r20
    29c0:	08 95       	ret

000029c2 <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    29c2:	cf 93       	push	r28
    29c4:	df 93       	push	r29
    29c6:	fc 01       	movw	r30, r24

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    29c8:	86 85       	ldd	r24, Z+14	; 0x0e
    29ca:	80 fd       	sbrc	r24, 0
    29cc:	03 c0       	rjmp	.+6      	; 0x29d4 <xStreamBufferIsFull+0x12>
    29ce:	c0 e0       	ldi	r28, 0x00	; 0
    29d0:	d0 e0       	ldi	r29, 0x00	; 0
    29d2:	02 c0       	rjmp	.+4      	; 0x29d8 <xStreamBufferIsFull+0x16>
    29d4:	c2 e0       	ldi	r28, 0x02	; 2
    29d6:	d0 e0       	ldi	r29, 0x00	; 0
    {
        xBytesToStoreMessageLength = 0;
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    29d8:	cf 01       	movw	r24, r30
    29da:	0e 94 a7 14 	call	0x294e	; 0x294e <xStreamBufferSpacesAvailable>
    29de:	20 e0       	ldi	r18, 0x00	; 0
    29e0:	c8 17       	cp	r28, r24
    29e2:	d9 07       	cpc	r29, r25
    29e4:	08 f0       	brcs	.+2      	; 0x29e8 <xStreamBufferIsFull+0x26>
    29e6:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    29e8:	82 2f       	mov	r24, r18
    29ea:	df 91       	pop	r29
    29ec:	cf 91       	pop	r28
    29ee:	08 95       	ret

000029f0 <xStreamBufferReceiveCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    29f0:	cf 92       	push	r12
    29f2:	df 92       	push	r13
    29f4:	ef 92       	push	r14
    29f6:	ff 92       	push	r15
    29f8:	0f 93       	push	r16
    29fa:	cf 93       	push	r28
    29fc:	df 93       	push	r29
    29fe:	ec 01       	movw	r28, r24
    2a00:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2a02:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a04:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a06:	89 2b       	or	r24, r25
    2a08:	11 f4       	brne	.+4      	; 0x2a0e <xStreamBufferReceiveCompletedFromISR+0x1e>
    2a0a:	80 e0       	ldi	r24, 0x00	; 0
    2a0c:	0f c0       	rjmp	.+30     	; 0x2a2c <xStreamBufferReceiveCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2a0e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a10:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a12:	60 e0       	ldi	r22, 0x00	; 0
    2a14:	20 e0       	ldi	r18, 0x00	; 0
    2a16:	30 e0       	ldi	r19, 0x00	; 0
    2a18:	40 e0       	ldi	r20, 0x00	; 0
    2a1a:	50 e0       	ldi	r21, 0x00	; 0
    2a1c:	00 e0       	ldi	r16, 0x00	; 0
    2a1e:	ee 24       	eor	r14, r14
    2a20:	ff 24       	eor	r15, r15
    2a22:	0e 94 4d 1c 	call	0x389a	; 0x389a <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2a26:	1b 86       	std	Y+11, r1	; 0x0b
    2a28:	1a 86       	std	Y+10, r1	; 0x0a
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2a2c:	df 91       	pop	r29
    2a2e:	cf 91       	pop	r28
    2a30:	0f 91       	pop	r16
    2a32:	ff 90       	pop	r15
    2a34:	ef 90       	pop	r14
    2a36:	df 90       	pop	r13
    2a38:	cf 90       	pop	r12
    2a3a:	08 95       	ret

00002a3c <xStreamBufferSendCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    2a3c:	cf 92       	push	r12
    2a3e:	df 92       	push	r13
    2a40:	ef 92       	push	r14
    2a42:	ff 92       	push	r15
    2a44:	0f 93       	push	r16
    2a46:	cf 93       	push	r28
    2a48:	df 93       	push	r29
    2a4a:	ec 01       	movw	r28, r24
    2a4c:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2a4e:	88 85       	ldd	r24, Y+8	; 0x08
    2a50:	99 85       	ldd	r25, Y+9	; 0x09
    2a52:	89 2b       	or	r24, r25
    2a54:	11 f4       	brne	.+4      	; 0x2a5a <xStreamBufferSendCompletedFromISR+0x1e>
    2a56:	80 e0       	ldi	r24, 0x00	; 0
    2a58:	0f c0       	rjmp	.+30     	; 0x2a78 <xStreamBufferSendCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2a5a:	88 85       	ldd	r24, Y+8	; 0x08
    2a5c:	99 85       	ldd	r25, Y+9	; 0x09
    2a5e:	60 e0       	ldi	r22, 0x00	; 0
    2a60:	20 e0       	ldi	r18, 0x00	; 0
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	40 e0       	ldi	r20, 0x00	; 0
    2a66:	50 e0       	ldi	r21, 0x00	; 0
    2a68:	00 e0       	ldi	r16, 0x00	; 0
    2a6a:	ee 24       	eor	r14, r14
    2a6c:	ff 24       	eor	r15, r15
    2a6e:	0e 94 4d 1c 	call	0x389a	; 0x389a <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2a72:	19 86       	std	Y+9, r1	; 0x09
    2a74:	18 86       	std	Y+8, r1	; 0x08
    2a76:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    2a78:	df 91       	pop	r29
    2a7a:	cf 91       	pop	r28
    2a7c:	0f 91       	pop	r16
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	df 90       	pop	r13
    2a84:	cf 90       	pop	r12
    2a86:	08 95       	ret

00002a88 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    2a88:	af 92       	push	r10
    2a8a:	bf 92       	push	r11
    2a8c:	cf 92       	push	r12
    2a8e:	df 92       	push	r13
    2a90:	ef 92       	push	r14
    2a92:	ff 92       	push	r15
    2a94:	0f 93       	push	r16
    2a96:	1f 93       	push	r17
    2a98:	cf 93       	push	r28
    2a9a:	df 93       	push	r29
    2a9c:	6c 01       	movw	r12, r24
    2a9e:	8b 01       	movw	r16, r22
    2aa0:	7a 01       	movw	r14, r20
    2aa2:	59 01       	movw	r10, r18
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    2aa4:	dc 01       	movw	r26, r24
    2aa6:	14 96       	adiw	r26, 0x04	; 4
    2aa8:	cd 91       	ld	r28, X+
    2aaa:	dc 91       	ld	r29, X
    2aac:	15 97       	sbiw	r26, 0x05	; 5
    2aae:	c2 1b       	sub	r28, r18
    2ab0:	d3 0b       	sbc	r29, r19
    2ab2:	4c 17       	cp	r20, r28
    2ab4:	5d 07       	cpc	r21, r29
    2ab6:	08 f4       	brcc	.+2      	; 0x2aba <prvReadBytesFromBuffer+0x32>
    2ab8:	ea 01       	movw	r28, r20

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2aba:	f6 01       	movw	r30, r12
    2abc:	24 85       	ldd	r18, Z+12	; 0x0c
    2abe:	35 85       	ldd	r19, Z+13	; 0x0d
    2ac0:	2a 0d       	add	r18, r10
    2ac2:	3b 1d       	adc	r19, r11
    2ac4:	c8 01       	movw	r24, r16
    2ac6:	b9 01       	movw	r22, r18
    2ac8:	ae 01       	movw	r20, r28
    2aca:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    2ace:	ce 15       	cp	r28, r14
    2ad0:	df 05       	cpc	r29, r15
    2ad2:	80 f4       	brcc	.+32     	; 0x2af4 <prvReadBytesFromBuffer+0x6c>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2ad4:	98 01       	movw	r18, r16
    2ad6:	2c 0f       	add	r18, r28
    2ad8:	3d 1f       	adc	r19, r29
    2ada:	f7 01       	movw	r30, r14
    2adc:	ec 1b       	sub	r30, r28
    2ade:	fd 0b       	sbc	r31, r29
    2ae0:	d6 01       	movw	r26, r12
    2ae2:	1c 96       	adiw	r26, 0x0c	; 12
    2ae4:	6c 91       	ld	r22, X
    2ae6:	1c 97       	sbiw	r26, 0x0c	; 12
    2ae8:	1d 96       	adiw	r26, 0x0d	; 13
    2aea:	7c 91       	ld	r23, X
    2aec:	c9 01       	movw	r24, r18
    2aee:	af 01       	movw	r20, r30
    2af0:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    2af4:	95 01       	movw	r18, r10
    2af6:	2e 0d       	add	r18, r14
    2af8:	3f 1d       	adc	r19, r15

    if( xTail >= pxStreamBuffer->xLength )
    2afa:	f6 01       	movw	r30, r12
    2afc:	84 81       	ldd	r24, Z+4	; 0x04
    2afe:	95 81       	ldd	r25, Z+5	; 0x05
    2b00:	28 17       	cp	r18, r24
    2b02:	39 07       	cpc	r19, r25
    2b04:	10 f0       	brcs	.+4      	; 0x2b0a <prvReadBytesFromBuffer+0x82>
    {
        xTail -= pxStreamBuffer->xLength;
    2b06:	28 1b       	sub	r18, r24
    2b08:	39 0b       	sbc	r19, r25
    }

    return xTail;
}
    2b0a:	c9 01       	movw	r24, r18
    2b0c:	df 91       	pop	r29
    2b0e:	cf 91       	pop	r28
    2b10:	1f 91       	pop	r17
    2b12:	0f 91       	pop	r16
    2b14:	ff 90       	pop	r15
    2b16:	ef 90       	pop	r14
    2b18:	df 90       	pop	r13
    2b1a:	cf 90       	pop	r12
    2b1c:	bf 90       	pop	r11
    2b1e:	af 90       	pop	r10
    2b20:	08 95       	ret

00002b22 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    2b22:	af 92       	push	r10
    2b24:	bf 92       	push	r11
    2b26:	cf 92       	push	r12
    2b28:	df 92       	push	r13
    2b2a:	ef 92       	push	r14
    2b2c:	ff 92       	push	r15
    2b2e:	0f 93       	push	r16
    2b30:	1f 93       	push	r17
    2b32:	df 93       	push	r29
    2b34:	cf 93       	push	r28
    2b36:	00 d0       	rcall	.+0      	; 0x2b38 <prvReadMessageFromBuffer+0x16>
    2b38:	cd b7       	in	r28, 0x3d	; 61
    2b3a:	de b7       	in	r29, 0x3e	; 62
    2b3c:	7c 01       	movw	r14, r24
    2b3e:	5b 01       	movw	r10, r22
    2b40:	6a 01       	movw	r12, r20
    2b42:	89 01       	movw	r16, r18
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    2b44:	fc 01       	movw	r30, r24
    2b46:	20 81       	ld	r18, Z
    2b48:	31 81       	ldd	r19, Z+1	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2b4a:	86 85       	ldd	r24, Z+14	; 0x0e
    2b4c:	80 fd       	sbrc	r24, 0
    2b4e:	02 c0       	rjmp	.+4      	; 0x2b54 <prvReadMessageFromBuffer+0x32>
    2b50:	ca 01       	movw	r24, r20
    2b52:	12 c0       	rjmp	.+36     	; 0x2b78 <prvReadMessageFromBuffer+0x56>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    2b54:	c7 01       	movw	r24, r14
    2b56:	be 01       	movw	r22, r28
    2b58:	6f 5f       	subi	r22, 0xFF	; 255
    2b5a:	7f 4f       	sbci	r23, 0xFF	; 255
    2b5c:	42 e0       	ldi	r20, 0x02	; 2
    2b5e:	50 e0       	ldi	r21, 0x00	; 0
    2b60:	0e 94 44 15 	call	0x2a88	; 0x2a88 <prvReadBytesFromBuffer>
    2b64:	9c 01       	movw	r18, r24
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2b66:	89 81       	ldd	r24, Y+1	; 0x01
    2b68:	9a 81       	ldd	r25, Y+2	; 0x02

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2b6a:	02 50       	subi	r16, 0x02	; 2
    2b6c:	10 40       	sbci	r17, 0x00	; 0

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    2b6e:	c8 16       	cp	r12, r24
    2b70:	d9 06       	cpc	r13, r25
    2b72:	10 f4       	brcc	.+4      	; 0x2b78 <prvReadMessageFromBuffer+0x56>
    2b74:	80 e0       	ldi	r24, 0x00	; 0
    2b76:	90 e0       	ldi	r25, 0x00	; 0
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    2b78:	80 17       	cp	r24, r16
    2b7a:	91 07       	cpc	r25, r17
    2b7c:	08 f4       	brcc	.+2      	; 0x2b80 <prvReadMessageFromBuffer+0x5e>
    2b7e:	8c 01       	movw	r16, r24

    if( xCount != ( size_t ) 0 )
    2b80:	01 15       	cp	r16, r1
    2b82:	11 05       	cpc	r17, r1
    2b84:	41 f0       	breq	.+16     	; 0x2b96 <prvReadMessageFromBuffer+0x74>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    2b86:	c7 01       	movw	r24, r14
    2b88:	b5 01       	movw	r22, r10
    2b8a:	a8 01       	movw	r20, r16
    2b8c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <prvReadBytesFromBuffer>
    2b90:	f7 01       	movw	r30, r14
    2b92:	91 83       	std	Z+1, r25	; 0x01
    2b94:	80 83       	st	Z, r24
    }

    return xCount;
}
    2b96:	c8 01       	movw	r24, r16
    2b98:	0f 90       	pop	r0
    2b9a:	0f 90       	pop	r0
    2b9c:	cf 91       	pop	r28
    2b9e:	df 91       	pop	r29
    2ba0:	1f 91       	pop	r17
    2ba2:	0f 91       	pop	r16
    2ba4:	ff 90       	pop	r15
    2ba6:	ef 90       	pop	r14
    2ba8:	df 90       	pop	r13
    2baa:	cf 90       	pop	r12
    2bac:	bf 90       	pop	r11
    2bae:	af 90       	pop	r10
    2bb0:	08 95       	ret

00002bb2 <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    2bb2:	af 92       	push	r10
    2bb4:	bf 92       	push	r11
    2bb6:	cf 92       	push	r12
    2bb8:	df 92       	push	r13
    2bba:	ef 92       	push	r14
    2bbc:	ff 92       	push	r15
    2bbe:	0f 93       	push	r16
    2bc0:	cf 93       	push	r28
    2bc2:	df 93       	push	r29
    2bc4:	ec 01       	movw	r28, r24
    2bc6:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2bc8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2bca:	80 fd       	sbrc	r24, 0
    2bcc:	03 c0       	rjmp	.+6      	; 0x2bd4 <xStreamBufferReceiveFromISR+0x22>
    2bce:	a0 e0       	ldi	r26, 0x00	; 0
    2bd0:	b0 e0       	ldi	r27, 0x00	; 0
    2bd2:	02 c0       	rjmp	.+4      	; 0x2bd8 <xStreamBufferReceiveFromISR+0x26>
    2bd4:	a2 e0       	ldi	r26, 0x02	; 2
    2bd6:	b0 e0       	ldi	r27, 0x00	; 0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2bd8:	ec 81       	ldd	r30, Y+4	; 0x04
    2bda:	fd 81       	ldd	r31, Y+5	; 0x05
    2bdc:	2a 81       	ldd	r18, Y+2	; 0x02
    2bde:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2be0:	88 81       	ld	r24, Y
    2be2:	99 81       	ldd	r25, Y+1	; 0x01
    2be4:	2e 0f       	add	r18, r30
    2be6:	3f 1f       	adc	r19, r31
    2be8:	28 1b       	sub	r18, r24
    2bea:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2bec:	2e 17       	cp	r18, r30
    2bee:	3f 07       	cpc	r19, r31
    2bf0:	10 f0       	brcs	.+4      	; 0x2bf6 <xStreamBufferReceiveFromISR+0x44>
    {
        xCount -= pxStreamBuffer->xLength;
    2bf2:	2e 1b       	sub	r18, r30
    2bf4:	3f 0b       	sbc	r19, r31
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2bf6:	a2 17       	cp	r26, r18
    2bf8:	b3 07       	cpc	r27, r19
    2bfa:	18 f0       	brcs	.+6      	; 0x2c02 <xStreamBufferReceiveFromISR+0x50>
    2bfc:	aa 24       	eor	r10, r10
    2bfe:	bb 24       	eor	r11, r11
    2c00:	18 c0       	rjmp	.+48     	; 0x2c32 <xStreamBufferReceiveFromISR+0x80>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2c02:	ce 01       	movw	r24, r28
    2c04:	0e 94 91 15 	call	0x2b22	; 0x2b22 <prvReadMessageFromBuffer>
    2c08:	5c 01       	movw	r10, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    2c0a:	00 97       	sbiw	r24, 0x00	; 0
    2c0c:	91 f0       	breq	.+36     	; 0x2c32 <xStreamBufferReceiveFromISR+0x80>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2c0e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c10:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c12:	89 2b       	or	r24, r25
    2c14:	71 f0       	breq	.+28     	; 0x2c32 <xStreamBufferReceiveFromISR+0x80>
    2c16:	8a 85       	ldd	r24, Y+10	; 0x0a
    2c18:	9b 85       	ldd	r25, Y+11	; 0x0b
    2c1a:	60 e0       	ldi	r22, 0x00	; 0
    2c1c:	20 e0       	ldi	r18, 0x00	; 0
    2c1e:	30 e0       	ldi	r19, 0x00	; 0
    2c20:	40 e0       	ldi	r20, 0x00	; 0
    2c22:	50 e0       	ldi	r21, 0x00	; 0
    2c24:	00 e0       	ldi	r16, 0x00	; 0
    2c26:	ee 24       	eor	r14, r14
    2c28:	ff 24       	eor	r15, r15
    2c2a:	0e 94 4d 1c 	call	0x389a	; 0x389a <xTaskGenericNotifyFromISR>
    2c2e:	1b 86       	std	Y+11, r1	; 0x0b
    2c30:	1a 86       	std	Y+10, r1	; 0x0a
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
}
    2c32:	c5 01       	movw	r24, r10
    2c34:	df 91       	pop	r29
    2c36:	cf 91       	pop	r28
    2c38:	0f 91       	pop	r16
    2c3a:	ff 90       	pop	r15
    2c3c:	ef 90       	pop	r14
    2c3e:	df 90       	pop	r13
    2c40:	cf 90       	pop	r12
    2c42:	bf 90       	pop	r11
    2c44:	af 90       	pop	r10
    2c46:	08 95       	ret

00002c48 <xStreamBufferNextMessageLengthBytes>:
    return xReceivedLength;
}
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2c48:	df 93       	push	r29
    2c4a:	cf 93       	push	r28
    2c4c:	00 d0       	rcall	.+0      	; 0x2c4e <xStreamBufferNextMessageLengthBytes+0x6>
    2c4e:	cd b7       	in	r28, 0x3d	; 61
    2c50:	de b7       	in	r29, 0x3e	; 62
    2c52:	fc 01       	movw	r30, r24
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2c54:	86 85       	ldd	r24, Z+14	; 0x0e
    2c56:	80 ff       	sbrs	r24, 0
    2c58:	1f c0       	rjmp	.+62     	; 0x2c98 <xStreamBufferNextMessageLengthBytes+0x50>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2c5a:	44 81       	ldd	r20, Z+4	; 0x04
    2c5c:	55 81       	ldd	r21, Z+5	; 0x05
    2c5e:	22 81       	ldd	r18, Z+2	; 0x02
    2c60:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2c62:	80 81       	ld	r24, Z
    2c64:	91 81       	ldd	r25, Z+1	; 0x01
    2c66:	24 0f       	add	r18, r20
    2c68:	35 1f       	adc	r19, r21
    2c6a:	28 1b       	sub	r18, r24
    2c6c:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2c6e:	24 17       	cp	r18, r20
    2c70:	35 07       	cpc	r19, r21
    2c72:	10 f0       	brcs	.+4      	; 0x2c78 <xStreamBufferNextMessageLengthBytes+0x30>
    {
        xCount -= pxStreamBuffer->xLength;
    2c74:	24 1b       	sub	r18, r20
    2c76:	35 0b       	sbc	r19, r21
    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2c78:	23 30       	cpi	r18, 0x03	; 3
    2c7a:	31 05       	cpc	r19, r1
    2c7c:	68 f0       	brcs	.+26     	; 0x2c98 <xStreamBufferNextMessageLengthBytes+0x50>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    2c7e:	20 81       	ld	r18, Z
    2c80:	31 81       	ldd	r19, Z+1	; 0x01
    2c82:	cf 01       	movw	r24, r30
    2c84:	be 01       	movw	r22, r28
    2c86:	6f 5f       	subi	r22, 0xFF	; 255
    2c88:	7f 4f       	sbci	r23, 0xFF	; 255
    2c8a:	42 e0       	ldi	r20, 0x02	; 2
    2c8c:	50 e0       	ldi	r21, 0x00	; 0
    2c8e:	0e 94 44 15 	call	0x2a88	; 0x2a88 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    2c92:	29 81       	ldd	r18, Y+1	; 0x01
    2c94:	3a 81       	ldd	r19, Y+2	; 0x02
    2c96:	02 c0       	rjmp	.+4      	; 0x2c9c <xStreamBufferNextMessageLengthBytes+0x54>
    2c98:	20 e0       	ldi	r18, 0x00	; 0
    2c9a:	30 e0       	ldi	r19, 0x00	; 0
    {
        xReturn = 0;
    }

    return xReturn;
}
    2c9c:	c9 01       	movw	r24, r18
    2c9e:	0f 90       	pop	r0
    2ca0:	0f 90       	pop	r0
    2ca2:	cf 91       	pop	r28
    2ca4:	df 91       	pop	r29
    2ca6:	08 95       	ret

00002ca8 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    2ca8:	af 92       	push	r10
    2caa:	bf 92       	push	r11
    2cac:	cf 92       	push	r12
    2cae:	df 92       	push	r13
    2cb0:	ef 92       	push	r14
    2cb2:	ff 92       	push	r15
    2cb4:	0f 93       	push	r16
    2cb6:	1f 93       	push	r17
    2cb8:	cf 93       	push	r28
    2cba:	df 93       	push	r29
    2cbc:	7c 01       	movw	r14, r24
    2cbe:	6b 01       	movw	r12, r22
    2cc0:	8a 01       	movw	r16, r20
    2cc2:	59 01       	movw	r10, r18
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    2cc4:	dc 01       	movw	r26, r24
    2cc6:	14 96       	adiw	r26, 0x04	; 4
    2cc8:	cd 91       	ld	r28, X+
    2cca:	dc 91       	ld	r29, X
    2ccc:	15 97       	sbiw	r26, 0x05	; 5
    2cce:	c2 1b       	sub	r28, r18
    2cd0:	d3 0b       	sbc	r29, r19
    2cd2:	4c 17       	cp	r20, r28
    2cd4:	5d 07       	cpc	r21, r29
    2cd6:	08 f4       	brcc	.+2      	; 0x2cda <prvWriteBytesToBuffer+0x32>
    2cd8:	ea 01       	movw	r28, r20

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2cda:	f7 01       	movw	r30, r14
    2cdc:	24 85       	ldd	r18, Z+12	; 0x0c
    2cde:	35 85       	ldd	r19, Z+13	; 0x0d
    2ce0:	2a 0d       	add	r18, r10
    2ce2:	3b 1d       	adc	r19, r11
    2ce4:	c9 01       	movw	r24, r18
    2ce6:	b6 01       	movw	r22, r12
    2ce8:	ae 01       	movw	r20, r28
    2cea:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    2cee:	c0 17       	cp	r28, r16
    2cf0:	d1 07       	cpc	r29, r17
    2cf2:	80 f4       	brcc	.+32     	; 0x2d14 <prvWriteBytesToBuffer+0x6c>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2cf4:	f8 01       	movw	r30, r16
    2cf6:	ec 1b       	sub	r30, r28
    2cf8:	fd 0b       	sbc	r31, r29
    2cfa:	96 01       	movw	r18, r12
    2cfc:	2c 0f       	add	r18, r28
    2cfe:	3d 1f       	adc	r19, r29
    2d00:	d7 01       	movw	r26, r14
    2d02:	1c 96       	adiw	r26, 0x0c	; 12
    2d04:	8c 91       	ld	r24, X
    2d06:	1c 97       	sbiw	r26, 0x0c	; 12
    2d08:	1d 96       	adiw	r26, 0x0d	; 13
    2d0a:	9c 91       	ld	r25, X
    2d0c:	b9 01       	movw	r22, r18
    2d0e:	af 01       	movw	r20, r30
    2d10:	0e 94 64 24 	call	0x48c8	; 0x48c8 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    2d14:	95 01       	movw	r18, r10
    2d16:	20 0f       	add	r18, r16
    2d18:	31 1f       	adc	r19, r17

    if( xHead >= pxStreamBuffer->xLength )
    2d1a:	f7 01       	movw	r30, r14
    2d1c:	84 81       	ldd	r24, Z+4	; 0x04
    2d1e:	95 81       	ldd	r25, Z+5	; 0x05
    2d20:	28 17       	cp	r18, r24
    2d22:	39 07       	cpc	r19, r25
    2d24:	10 f0       	brcs	.+4      	; 0x2d2a <prvWriteBytesToBuffer+0x82>
    {
        xHead -= pxStreamBuffer->xLength;
    2d26:	28 1b       	sub	r18, r24
    2d28:	39 0b       	sbc	r19, r25
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
    2d2a:	c9 01       	movw	r24, r18
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	1f 91       	pop	r17
    2d32:	0f 91       	pop	r16
    2d34:	ff 90       	pop	r15
    2d36:	ef 90       	pop	r14
    2d38:	df 90       	pop	r13
    2d3a:	cf 90       	pop	r12
    2d3c:	bf 90       	pop	r11
    2d3e:	af 90       	pop	r10
    2d40:	08 95       	ret

00002d42 <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    2d42:	af 92       	push	r10
    2d44:	bf 92       	push	r11
    2d46:	cf 92       	push	r12
    2d48:	df 92       	push	r13
    2d4a:	ef 92       	push	r14
    2d4c:	ff 92       	push	r15
    2d4e:	0f 93       	push	r16
    2d50:	1f 93       	push	r17
    2d52:	df 93       	push	r29
    2d54:	cf 93       	push	r28
    2d56:	00 d0       	rcall	.+0      	; 0x2d58 <prvWriteMessageToBuffer+0x16>
    2d58:	cd b7       	in	r28, 0x3d	; 61
    2d5a:	de b7       	in	r29, 0x3e	; 62
    2d5c:	6c 01       	movw	r12, r24
    2d5e:	5b 01       	movw	r10, r22
    2d60:	7a 01       	movw	r14, r20
    size_t xNextHead = pxStreamBuffer->xHead;
    2d62:	dc 01       	movw	r26, r24
    2d64:	12 96       	adiw	r26, 0x02	; 2
    2d66:	ed 91       	ld	r30, X+
    2d68:	fc 91       	ld	r31, X
    2d6a:	13 97       	sbiw	r26, 0x03	; 3
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2d6c:	1e 96       	adiw	r26, 0x0e	; 14
    2d6e:	8c 91       	ld	r24, X
    2d70:	80 ff       	sbrs	r24, 0
    2d72:	13 c0       	rjmp	.+38     	; 0x2d9a <prvWriteMessageToBuffer+0x58>
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    2d74:	20 17       	cp	r18, r16
    2d76:	31 07       	cpc	r19, r17
    2d78:	18 f4       	brcc	.+6      	; 0x2d80 <prvWriteMessageToBuffer+0x3e>
    2d7a:	ee 24       	eor	r14, r14
    2d7c:	ff 24       	eor	r15, r15
    2d7e:	1d c0       	rjmp	.+58     	; 0x2dba <prvWriteMessageToBuffer+0x78>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    2d80:	5a 83       	std	Y+2, r21	; 0x02
    2d82:	49 83       	std	Y+1, r20	; 0x01
        if( xSpace >= xRequiredSpace )
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    2d84:	c6 01       	movw	r24, r12
    2d86:	be 01       	movw	r22, r28
    2d88:	6f 5f       	subi	r22, 0xFF	; 255
    2d8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d8c:	42 e0       	ldi	r20, 0x02	; 2
    2d8e:	50 e0       	ldi	r21, 0x00	; 0
    2d90:	9f 01       	movw	r18, r30
    2d92:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvWriteBytesToBuffer>
    2d96:	fc 01       	movw	r30, r24
    2d98:	04 c0       	rjmp	.+8      	; 0x2da2 <prvWriteMessageToBuffer+0x60>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    2d9a:	24 17       	cp	r18, r20
    2d9c:	35 07       	cpc	r19, r21
    2d9e:	08 f4       	brcc	.+2      	; 0x2da2 <prvWriteMessageToBuffer+0x60>
    2da0:	79 01       	movw	r14, r18
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    2da2:	e1 14       	cp	r14, r1
    2da4:	f1 04       	cpc	r15, r1
    2da6:	49 f0       	breq	.+18     	; 0x2dba <prvWriteMessageToBuffer+0x78>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    2da8:	c6 01       	movw	r24, r12
    2daa:	b5 01       	movw	r22, r10
    2dac:	a7 01       	movw	r20, r14
    2dae:	9f 01       	movw	r18, r30
    2db0:	0e 94 54 16 	call	0x2ca8	; 0x2ca8 <prvWriteBytesToBuffer>
    2db4:	f6 01       	movw	r30, r12
    2db6:	93 83       	std	Z+3, r25	; 0x03
    2db8:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
}
    2dba:	c7 01       	movw	r24, r14
    2dbc:	0f 90       	pop	r0
    2dbe:	0f 90       	pop	r0
    2dc0:	cf 91       	pop	r28
    2dc2:	df 91       	pop	r29
    2dc4:	1f 91       	pop	r17
    2dc6:	0f 91       	pop	r16
    2dc8:	ff 90       	pop	r15
    2dca:	ef 90       	pop	r14
    2dcc:	df 90       	pop	r13
    2dce:	cf 90       	pop	r12
    2dd0:	bf 90       	pop	r11
    2dd2:	af 90       	pop	r10
    2dd4:	08 95       	ret

00002dd6 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    2dd6:	af 92       	push	r10
    2dd8:	bf 92       	push	r11
    2dda:	cf 92       	push	r12
    2ddc:	df 92       	push	r13
    2dde:	ef 92       	push	r14
    2de0:	ff 92       	push	r15
    2de2:	0f 93       	push	r16
    2de4:	1f 93       	push	r17
    2de6:	cf 93       	push	r28
    2de8:	df 93       	push	r29
    2dea:	ec 01       	movw	r28, r24
    2dec:	5b 01       	movw	r10, r22
    2dee:	8a 01       	movw	r16, r20
    2df0:	69 01       	movw	r12, r18

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2df2:	8e 85       	ldd	r24, Y+14	; 0x0e
    2df4:	80 fd       	sbrc	r24, 0
    2df6:	02 c0       	rjmp	.+4      	; 0x2dfc <xStreamBufferSendFromISR+0x26>
    2df8:	7a 01       	movw	r14, r20
    2dfa:	05 c0       	rjmp	.+10     	; 0x2e06 <xStreamBufferSendFromISR+0x30>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2dfc:	82 e0       	ldi	r24, 0x02	; 2
    2dfe:	e8 2e       	mov	r14, r24
    2e00:	f1 2c       	mov	r15, r1
    2e02:	e4 0e       	add	r14, r20
    2e04:	f5 1e       	adc	r15, r21
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2e06:	ce 01       	movw	r24, r28
    2e08:	0e 94 a7 14 	call	0x294e	; 0x294e <xStreamBufferSpacesAvailable>
    2e0c:	9c 01       	movw	r18, r24
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2e0e:	ce 01       	movw	r24, r28
    2e10:	b5 01       	movw	r22, r10
    2e12:	a8 01       	movw	r20, r16
    2e14:	87 01       	movw	r16, r14
    2e16:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <prvWriteMessageToBuffer>
    2e1a:	5c 01       	movw	r10, r24

    if( xReturn > ( size_t ) 0 )
    2e1c:	00 97       	sbiw	r24, 0x00	; 0
    2e1e:	31 f1       	breq	.+76     	; 0x2e6c <xStreamBufferSendFromISR+0x96>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2e20:	4c 81       	ldd	r20, Y+4	; 0x04
    2e22:	5d 81       	ldd	r21, Y+5	; 0x05
    2e24:	2a 81       	ldd	r18, Y+2	; 0x02
    2e26:	3b 81       	ldd	r19, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2e28:	88 81       	ld	r24, Y
    2e2a:	99 81       	ldd	r25, Y+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2e2c:	24 0f       	add	r18, r20
    2e2e:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    2e30:	28 1b       	sub	r18, r24
    2e32:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    2e34:	24 17       	cp	r18, r20
    2e36:	35 07       	cpc	r19, r21
    2e38:	10 f0       	brcs	.+4      	; 0x2e3e <xStreamBufferSendFromISR+0x68>
    {
        xCount -= pxStreamBuffer->xLength;
    2e3a:	24 1b       	sub	r18, r20
    2e3c:	35 0b       	sbc	r19, r21
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );

    if( xReturn > ( size_t ) 0 )
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2e3e:	8e 81       	ldd	r24, Y+6	; 0x06
    2e40:	9f 81       	ldd	r25, Y+7	; 0x07
    2e42:	28 17       	cp	r18, r24
    2e44:	39 07       	cpc	r19, r25
    2e46:	90 f0       	brcs	.+36     	; 0x2e6c <xStreamBufferSendFromISR+0x96>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2e48:	88 85       	ldd	r24, Y+8	; 0x08
    2e4a:	99 85       	ldd	r25, Y+9	; 0x09
    2e4c:	89 2b       	or	r24, r25
    2e4e:	71 f0       	breq	.+28     	; 0x2e6c <xStreamBufferSendFromISR+0x96>
    2e50:	88 85       	ldd	r24, Y+8	; 0x08
    2e52:	99 85       	ldd	r25, Y+9	; 0x09
    2e54:	60 e0       	ldi	r22, 0x00	; 0
    2e56:	20 e0       	ldi	r18, 0x00	; 0
    2e58:	30 e0       	ldi	r19, 0x00	; 0
    2e5a:	40 e0       	ldi	r20, 0x00	; 0
    2e5c:	50 e0       	ldi	r21, 0x00	; 0
    2e5e:	00 e0       	ldi	r16, 0x00	; 0
    2e60:	ee 24       	eor	r14, r14
    2e62:	ff 24       	eor	r15, r15
    2e64:	0e 94 4d 1c 	call	0x389a	; 0x389a <xTaskGenericNotifyFromISR>
    2e68:	19 86       	std	Y+9, r1	; 0x09
    2e6a:	18 86       	std	Y+8, r1	; 0x08
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    2e6c:	c5 01       	movw	r24, r10
    2e6e:	df 91       	pop	r29
    2e70:	cf 91       	pop	r28
    2e72:	1f 91       	pop	r17
    2e74:	0f 91       	pop	r16
    2e76:	ff 90       	pop	r15
    2e78:	ef 90       	pop	r14
    2e7a:	df 90       	pop	r13
    2e7c:	cf 90       	pop	r12
    2e7e:	bf 90       	pop	r11
    2e80:	af 90       	pop	r10
    2e82:	08 95       	ret

00002e84 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    2e84:	6f 92       	push	r6
    2e86:	7f 92       	push	r7
    2e88:	8f 92       	push	r8
    2e8a:	9f 92       	push	r9
    2e8c:	af 92       	push	r10
    2e8e:	bf 92       	push	r11
    2e90:	cf 92       	push	r12
    2e92:	df 92       	push	r13
    2e94:	ef 92       	push	r14
    2e96:	ff 92       	push	r15
    2e98:	0f 93       	push	r16
    2e9a:	1f 93       	push	r17
    2e9c:	cf 93       	push	r28
    2e9e:	df 93       	push	r29
    2ea0:	ec 01       	movw	r28, r24
    2ea2:	4b 01       	movw	r8, r22
    2ea4:	3a 01       	movw	r6, r20
    2ea6:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2ea8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2eaa:	80 fd       	sbrc	r24, 0
    2eac:	03 c0       	rjmp	.+6      	; 0x2eb4 <xStreamBufferReceive+0x30>
    2eae:	aa 24       	eor	r10, r10
    2eb0:	bb 24       	eor	r11, r11
    2eb2:	03 c0       	rjmp	.+6      	; 0x2eba <xStreamBufferReceive+0x36>
    2eb4:	92 e0       	ldi	r25, 0x02	; 2
    2eb6:	a9 2e       	mov	r10, r25
    2eb8:	b1 2c       	mov	r11, r1
    2eba:	2c 81       	ldd	r18, Y+4	; 0x04
    2ebc:	3d 81       	ldd	r19, Y+5	; 0x05
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    2ebe:	c1 14       	cp	r12, r1
    2ec0:	d1 04       	cpc	r13, r1
    2ec2:	91 f1       	breq	.+100    	; 0x2f28 <xStreamBufferReceive+0xa4>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    2ec4:	0f b6       	in	r0, 0x3f	; 63
    2ec6:	f8 94       	cli
    2ec8:	0f 92       	push	r0
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2eca:	0a 81       	ldd	r16, Y+2	; 0x02
    2ecc:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2ece:	88 81       	ld	r24, Y
    2ed0:	99 81       	ldd	r25, Y+1	; 0x01
    2ed2:	02 0f       	add	r16, r18
    2ed4:	13 1f       	adc	r17, r19
    2ed6:	08 1b       	sub	r16, r24
    2ed8:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    2eda:	02 17       	cp	r16, r18
    2edc:	13 07       	cpc	r17, r19
    2ede:	10 f0       	brcs	.+4      	; 0x2ee4 <xStreamBufferReceive+0x60>
    {
        xCount -= pxStreamBuffer->xLength;
    2ee0:	02 1b       	sub	r16, r18
    2ee2:	13 0b       	sbc	r17, r19
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    2ee4:	a0 16       	cp	r10, r16
    2ee6:	b1 06       	cpc	r11, r17
    2ee8:	48 f0       	brcs	.+18     	; 0x2efc <xStreamBufferReceive+0x78>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    2eea:	80 e0       	ldi	r24, 0x00	; 0
    2eec:	90 e0       	ldi	r25, 0x00	; 0
    2eee:	60 e0       	ldi	r22, 0x00	; 0
    2ef0:	0e 94 fb 1d 	call	0x3bf6	; 0x3bf6 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    2ef4:	0e 94 2f 1c 	call	0x385e	; 0x385e <xTaskGetCurrentTaskHandle>
    2ef8:	99 87       	std	Y+9, r25	; 0x09
    2efa:	88 87       	std	Y+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    2efc:	0f 90       	pop	r0
    2efe:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    2f00:	a0 16       	cp	r10, r16
    2f02:	b1 06       	cpc	r11, r17
    2f04:	20 f1       	brcs	.+72     	; 0x2f4e <xStreamBufferReceive+0xca>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    2f06:	80 e0       	ldi	r24, 0x00	; 0
    2f08:	40 e0       	ldi	r20, 0x00	; 0
    2f0a:	50 e0       	ldi	r21, 0x00	; 0
    2f0c:	60 e0       	ldi	r22, 0x00	; 0
    2f0e:	70 e0       	ldi	r23, 0x00	; 0
    2f10:	00 e0       	ldi	r16, 0x00	; 0
    2f12:	10 e0       	ldi	r17, 0x00	; 0
    2f14:	20 e0       	ldi	r18, 0x00	; 0
    2f16:	30 e0       	ldi	r19, 0x00	; 0
    2f18:	ee 24       	eor	r14, r14
    2f1a:	ff 24       	eor	r15, r15
    2f1c:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2f20:	19 86       	std	Y+9, r1	; 0x09
    2f22:	18 86       	std	Y+8, r1	; 0x08
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2f24:	2c 81       	ldd	r18, Y+4	; 0x04
    2f26:	3d 81       	ldd	r19, Y+5	; 0x05
    2f28:	0a 81       	ldd	r16, Y+2	; 0x02
    2f2a:	1b 81       	ldd	r17, Y+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    2f2c:	88 81       	ld	r24, Y
    2f2e:	99 81       	ldd	r25, Y+1	; 0x01
    2f30:	02 0f       	add	r16, r18
    2f32:	13 1f       	adc	r17, r19
    2f34:	08 1b       	sub	r16, r24
    2f36:	19 0b       	sbc	r17, r25

    if( xCount >= pxStreamBuffer->xLength )
    2f38:	02 17       	cp	r16, r18
    2f3a:	13 07       	cpc	r17, r19
    2f3c:	10 f0       	brcs	.+4      	; 0x2f42 <xStreamBufferReceive+0xbe>
    {
        xCount -= pxStreamBuffer->xLength;
    2f3e:	02 1b       	sub	r16, r18
    2f40:	13 0b       	sbc	r17, r19
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    2f42:	a0 16       	cp	r10, r16
    2f44:	b1 06       	cpc	r11, r17
    2f46:	18 f0       	brcs	.+6      	; 0x2f4e <xStreamBufferReceive+0xca>
    2f48:	cc 24       	eor	r12, r12
    2f4a:	dd 24       	eor	r13, r13
    2f4c:	1f c0       	rjmp	.+62     	; 0x2f8c <xStreamBufferReceive+0x108>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    2f4e:	ce 01       	movw	r24, r28
    2f50:	b4 01       	movw	r22, r8
    2f52:	a3 01       	movw	r20, r6
    2f54:	98 01       	movw	r18, r16
    2f56:	0e 94 91 15 	call	0x2b22	; 0x2b22 <prvReadMessageFromBuffer>
    2f5a:	6c 01       	movw	r12, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    2f5c:	00 97       	sbiw	r24, 0x00	; 0
    2f5e:	b1 f0       	breq	.+44     	; 0x2f8c <xStreamBufferReceive+0x108>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    2f60:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    2f64:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f66:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f68:	89 2b       	or	r24, r25
    2f6a:	71 f0       	breq	.+28     	; 0x2f88 <xStreamBufferReceive+0x104>
    2f6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f70:	60 e0       	ldi	r22, 0x00	; 0
    2f72:	20 e0       	ldi	r18, 0x00	; 0
    2f74:	30 e0       	ldi	r19, 0x00	; 0
    2f76:	40 e0       	ldi	r20, 0x00	; 0
    2f78:	50 e0       	ldi	r21, 0x00	; 0
    2f7a:	00 e0       	ldi	r16, 0x00	; 0
    2f7c:	ee 24       	eor	r14, r14
    2f7e:	ff 24       	eor	r15, r15
    2f80:	0e 94 45 1e 	call	0x3c8a	; 0x3c8a <xTaskGenericNotify>
    2f84:	1b 86       	std	Y+11, r1	; 0x0b
    2f86:	1a 86       	std	Y+10, r1	; 0x0a
    2f88:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    2f8c:	c6 01       	movw	r24, r12
    2f8e:	df 91       	pop	r29
    2f90:	cf 91       	pop	r28
    2f92:	1f 91       	pop	r17
    2f94:	0f 91       	pop	r16
    2f96:	ff 90       	pop	r15
    2f98:	ef 90       	pop	r14
    2f9a:	df 90       	pop	r13
    2f9c:	cf 90       	pop	r12
    2f9e:	bf 90       	pop	r11
    2fa0:	af 90       	pop	r10
    2fa2:	9f 90       	pop	r9
    2fa4:	8f 90       	pop	r8
    2fa6:	7f 90       	pop	r7
    2fa8:	6f 90       	pop	r6
    2faa:	08 95       	ret

00002fac <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    2fac:	2f 92       	push	r2
    2fae:	3f 92       	push	r3
    2fb0:	4f 92       	push	r4
    2fb2:	5f 92       	push	r5
    2fb4:	6f 92       	push	r6
    2fb6:	7f 92       	push	r7
    2fb8:	8f 92       	push	r8
    2fba:	9f 92       	push	r9
    2fbc:	af 92       	push	r10
    2fbe:	bf 92       	push	r11
    2fc0:	cf 92       	push	r12
    2fc2:	df 92       	push	r13
    2fc4:	ef 92       	push	r14
    2fc6:	ff 92       	push	r15
    2fc8:	0f 93       	push	r16
    2fca:	1f 93       	push	r17
    2fcc:	df 93       	push	r29
    2fce:	cf 93       	push	r28
    2fd0:	cd b7       	in	r28, 0x3d	; 61
    2fd2:	de b7       	in	r29, 0x3e	; 62
    2fd4:	27 97       	sbiw	r28, 0x07	; 7
    2fd6:	0f b6       	in	r0, 0x3f	; 63
    2fd8:	f8 94       	cli
    2fda:	de bf       	out	0x3e, r29	; 62
    2fdc:	0f be       	out	0x3f, r0	; 63
    2fde:	cd bf       	out	0x3d, r28	; 61
    2fe0:	5c 01       	movw	r10, r24
    2fe2:	7f 83       	std	Y+7, r23	; 0x07
    2fe4:	6e 83       	std	Y+6, r22	; 0x06
    2fe6:	2a 01       	movw	r4, r20
    2fe8:	3d 83       	std	Y+5, r19	; 0x05
    2fea:	2c 83       	std	Y+4, r18	; 0x04
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    2fec:	fc 01       	movw	r30, r24
    2fee:	24 81       	ldd	r18, Z+4	; 0x04
    2ff0:	35 81       	ldd	r19, Z+5	; 0x05
    2ff2:	21 50       	subi	r18, 0x01	; 1
    2ff4:	30 40       	sbci	r19, 0x00	; 0

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2ff6:	86 85       	ldd	r24, Z+14	; 0x0e
    2ff8:	80 ff       	sbrs	r24, 0
    2ffa:	0b c0       	rjmp	.+22     	; 0x3012 <xStreamBufferSend+0x66>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2ffc:	42 e0       	ldi	r20, 0x02	; 2
    2ffe:	64 2e       	mov	r6, r20
    3000:	71 2c       	mov	r7, r1
    3002:	64 0c       	add	r6, r4
    3004:	75 1c       	adc	r7, r5
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    3006:	26 15       	cp	r18, r6
    3008:	37 05       	cpc	r19, r7
    300a:	48 f4       	brcc	.+18     	; 0x301e <xStreamBufferSend+0x72>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    300c:	1d 82       	std	Y+5, r1	; 0x05
    300e:	1c 82       	std	Y+4, r1	; 0x04
    3010:	06 c0       	rjmp	.+12     	; 0x301e <xStreamBufferSend+0x72>
    else
    {
        /* If this is a stream buffer then it is acceptable to write only part
         * of the message to the buffer.  Cap the length to the total length of
         * the buffer. */
        if( xRequiredSpace > xMaxReportedSpace )
    3012:	24 17       	cp	r18, r20
    3014:	35 07       	cpc	r19, r21
    3016:	10 f4       	brcc	.+4      	; 0x301c <xStreamBufferSend+0x70>
    3018:	39 01       	movw	r6, r18
    301a:	01 c0       	rjmp	.+2      	; 0x301e <xStreamBufferSend+0x72>
    301c:	3a 01       	movw	r6, r20
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    301e:	8c 81       	ldd	r24, Y+4	; 0x04
    3020:	9d 81       	ldd	r25, Y+5	; 0x05
    3022:	89 2b       	or	r24, r25
    3024:	09 f4       	brne	.+2      	; 0x3028 <xStreamBufferSend+0x7c>
    3026:	3d c0       	rjmp	.+122    	; 0x30a2 <xStreamBufferSend+0xf6>
    {
        vTaskSetTimeOutState( &xTimeOut );
    3028:	8e 01       	movw	r16, r28
    302a:	0f 5f       	subi	r16, 0xFF	; 255
    302c:	1f 4f       	sbci	r17, 0xFF	; 255
    302e:	c8 01       	movw	r24, r16
    3030:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <vTaskSetTimeOutState>
            taskEXIT_CRITICAL();

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
            pxStreamBuffer->xTaskWaitingToSend = NULL;
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3034:	18 01       	movw	r2, r16

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    3036:	0f b6       	in	r0, 0x3f	; 63
    3038:	f8 94       	cli
    303a:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    303c:	c5 01       	movw	r24, r10
    303e:	0e 94 a7 14 	call	0x294e	; 0x294e <xStreamBufferSpacesAvailable>
    3042:	4c 01       	movw	r8, r24

                if( xSpace < xRequiredSpace )
    3044:	86 15       	cp	r24, r6
    3046:	97 05       	cpc	r25, r7
    3048:	38 f5       	brcc	.+78     	; 0x3098 <xStreamBufferSend+0xec>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    304a:	80 e0       	ldi	r24, 0x00	; 0
    304c:	90 e0       	ldi	r25, 0x00	; 0
    304e:	60 e0       	ldi	r22, 0x00	; 0
    3050:	0e 94 fb 1d 	call	0x3bf6	; 0x3bf6 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    3054:	0e 94 2f 1c 	call	0x385e	; 0x385e <xTaskGetCurrentTaskHandle>
    3058:	f5 01       	movw	r30, r10
    305a:	93 87       	std	Z+11, r25	; 0x0b
    305c:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    305e:	0f 90       	pop	r0
    3060:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    3062:	cc 80       	ldd	r12, Y+4	; 0x04
    3064:	dd 80       	ldd	r13, Y+5	; 0x05
    3066:	80 e0       	ldi	r24, 0x00	; 0
    3068:	40 e0       	ldi	r20, 0x00	; 0
    306a:	50 e0       	ldi	r21, 0x00	; 0
    306c:	60 e0       	ldi	r22, 0x00	; 0
    306e:	70 e0       	ldi	r23, 0x00	; 0
    3070:	00 e0       	ldi	r16, 0x00	; 0
    3072:	10 e0       	ldi	r17, 0x00	; 0
    3074:	20 e0       	ldi	r18, 0x00	; 0
    3076:	30 e0       	ldi	r19, 0x00	; 0
    3078:	ee 24       	eor	r14, r14
    307a:	ff 24       	eor	r15, r15
    307c:	0e 94 4c 20 	call	0x4098	; 0x4098 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    3080:	f5 01       	movw	r30, r10
    3082:	13 86       	std	Z+11, r1	; 0x0b
    3084:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    3086:	c1 01       	movw	r24, r2
    3088:	be 01       	movw	r22, r28
    308a:	6c 5f       	subi	r22, 0xFC	; 252
    308c:	7f 4f       	sbci	r23, 0xFF	; 255
    308e:	0e 94 f6 1b 	call	0x37ec	; 0x37ec <xTaskCheckForTimeOut>
    3092:	88 23       	and	r24, r24
    3094:	81 f2       	breq	.-96     	; 0x3036 <xStreamBufferSend+0x8a>
    3096:	02 c0       	rjmp	.+4      	; 0x309c <xStreamBufferSend+0xf0>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    3098:	0f 90       	pop	r0
    309a:	0f be       	out	0x3f, r0	; 63
    309c:	94 01       	movw	r18, r8
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    309e:	89 28       	or	r8, r9
    30a0:	21 f4       	brne	.+8      	; 0x30aa <xStreamBufferSend+0xfe>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    30a2:	c5 01       	movw	r24, r10
    30a4:	0e 94 a7 14 	call	0x294e	; 0x294e <xStreamBufferSpacesAvailable>
    30a8:	9c 01       	movw	r18, r24
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    30aa:	c5 01       	movw	r24, r10
    30ac:	6e 81       	ldd	r22, Y+6	; 0x06
    30ae:	7f 81       	ldd	r23, Y+7	; 0x07
    30b0:	a2 01       	movw	r20, r4
    30b2:	83 01       	movw	r16, r6
    30b4:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <prvWriteMessageToBuffer>
    30b8:	6c 01       	movw	r12, r24

    if( xReturn > ( size_t ) 0 )
    30ba:	00 97       	sbiw	r24, 0x00	; 0
    30bc:	71 f1       	breq	.+92     	; 0x311a <xStreamBufferSend+0x16e>
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    30be:	f5 01       	movw	r30, r10
    30c0:	44 81       	ldd	r20, Z+4	; 0x04
    30c2:	55 81       	ldd	r21, Z+5	; 0x05
    30c4:	22 81       	ldd	r18, Z+2	; 0x02
    30c6:	33 81       	ldd	r19, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    30c8:	80 81       	ld	r24, Z
    30ca:	91 81       	ldd	r25, Z+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    30cc:	24 0f       	add	r18, r20
    30ce:	35 1f       	adc	r19, r21
    xCount -= pxStreamBuffer->xTail;
    30d0:	28 1b       	sub	r18, r24
    30d2:	39 0b       	sbc	r19, r25

    if( xCount >= pxStreamBuffer->xLength )
    30d4:	24 17       	cp	r18, r20
    30d6:	35 07       	cpc	r19, r21
    30d8:	10 f0       	brcs	.+4      	; 0x30de <xStreamBufferSend+0x132>
    {
        xCount -= pxStreamBuffer->xLength;
    30da:	24 1b       	sub	r18, r20
    30dc:	35 0b       	sbc	r19, r21
    if( xReturn > ( size_t ) 0 )
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    30de:	f5 01       	movw	r30, r10
    30e0:	86 81       	ldd	r24, Z+6	; 0x06
    30e2:	97 81       	ldd	r25, Z+7	; 0x07
    30e4:	28 17       	cp	r18, r24
    30e6:	39 07       	cpc	r19, r25
    30e8:	c0 f0       	brcs	.+48     	; 0x311a <xStreamBufferSend+0x16e>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    30ea:	0e 94 17 19 	call	0x322e	; 0x322e <vTaskSuspendAll>
    30ee:	f5 01       	movw	r30, r10
    30f0:	80 85       	ldd	r24, Z+8	; 0x08
    30f2:	91 85       	ldd	r25, Z+9	; 0x09
    30f4:	89 2b       	or	r24, r25
    30f6:	79 f0       	breq	.+30     	; 0x3116 <xStreamBufferSend+0x16a>
    30f8:	80 85       	ldd	r24, Z+8	; 0x08
    30fa:	91 85       	ldd	r25, Z+9	; 0x09
    30fc:	60 e0       	ldi	r22, 0x00	; 0
    30fe:	20 e0       	ldi	r18, 0x00	; 0
    3100:	30 e0       	ldi	r19, 0x00	; 0
    3102:	40 e0       	ldi	r20, 0x00	; 0
    3104:	50 e0       	ldi	r21, 0x00	; 0
    3106:	00 e0       	ldi	r16, 0x00	; 0
    3108:	ee 24       	eor	r14, r14
    310a:	ff 24       	eor	r15, r15
    310c:	0e 94 45 1e 	call	0x3c8a	; 0x3c8a <xTaskGenericNotify>
    3110:	f5 01       	movw	r30, r10
    3112:	11 86       	std	Z+9, r1	; 0x09
    3114:	10 86       	std	Z+8, r1	; 0x08
    3116:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
}
    311a:	c6 01       	movw	r24, r12
    311c:	27 96       	adiw	r28, 0x07	; 7
    311e:	0f b6       	in	r0, 0x3f	; 63
    3120:	f8 94       	cli
    3122:	de bf       	out	0x3e, r29	; 62
    3124:	0f be       	out	0x3f, r0	; 63
    3126:	cd bf       	out	0x3d, r28	; 61
    3128:	cf 91       	pop	r28
    312a:	df 91       	pop	r29
    312c:	1f 91       	pop	r17
    312e:	0f 91       	pop	r16
    3130:	ff 90       	pop	r15
    3132:	ef 90       	pop	r14
    3134:	df 90       	pop	r13
    3136:	cf 90       	pop	r12
    3138:	bf 90       	pop	r11
    313a:	af 90       	pop	r10
    313c:	9f 90       	pop	r9
    313e:	8f 90       	pop	r8
    3140:	7f 90       	pop	r7
    3142:	6f 90       	pop	r6
    3144:	5f 90       	pop	r5
    3146:	4f 90       	pop	r4
    3148:	3f 90       	pop	r3
    314a:	2f 90       	pop	r2
    314c:	08 95       	ret

0000314e <xStreamBufferReset>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    314e:	fc 01       	movw	r30, r24
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    3150:	0f b6       	in	r0, 0x3f	; 63
    3152:	f8 94       	cli
    3154:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    3156:	80 85       	ldd	r24, Z+8	; 0x08
    3158:	91 85       	ldd	r25, Z+9	; 0x09
    315a:	89 2b       	or	r24, r25
    315c:	c9 f4       	brne	.+50     	; 0x3190 <xStreamBufferReset+0x42>
    315e:	82 85       	ldd	r24, Z+10	; 0x0a
    3160:	93 85       	ldd	r25, Z+11	; 0x0b
    3162:	89 2b       	or	r24, r25
    3164:	a9 f4       	brne	.+42     	; 0x3190 <xStreamBufferReset+0x42>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    3166:	24 85       	ldd	r18, Z+12	; 0x0c
    3168:	35 85       	ldd	r19, Z+13	; 0x0d
    316a:	44 81       	ldd	r20, Z+4	; 0x04
    316c:	55 81       	ldd	r21, Z+5	; 0x05
    316e:	66 81       	ldd	r22, Z+6	; 0x06
    3170:	77 81       	ldd	r23, Z+7	; 0x07
    3172:	96 85       	ldd	r25, Z+14	; 0x0e
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    3174:	8f e0       	ldi	r24, 0x0F	; 15
    3176:	df 01       	movw	r26, r30
    3178:	1d 92       	st	X+, r1
    317a:	8a 95       	dec	r24
    317c:	e9 f7       	brne	.-6      	; 0x3178 <xStreamBufferReset+0x2a>
    pxStreamBuffer->pucBuffer = pucBuffer;
    317e:	35 87       	std	Z+13, r19	; 0x0d
    3180:	24 87       	std	Z+12, r18	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    3182:	55 83       	std	Z+5, r21	; 0x05
    3184:	44 83       	std	Z+4, r20	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    3186:	77 83       	std	Z+7, r23	; 0x07
    3188:	66 83       	std	Z+6, r22	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    318a:	96 87       	std	Z+14, r25	; 0x0e
    318c:	81 e0       	ldi	r24, 0x01	; 1
    318e:	01 c0       	rjmp	.+2      	; 0x3192 <xStreamBufferReset+0x44>
    3190:	80 e0       	ldi	r24, 0x00	; 0
            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
        }
    }
    taskEXIT_CRITICAL();
    3192:	0f 90       	pop	r0
    3194:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    3196:	08 95       	ret

00003198 <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    3198:	fc 01       	movw	r30, r24

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    319a:	86 85       	ldd	r24, Z+14	; 0x0e
    319c:	81 fd       	sbrc	r24, 1
    319e:	04 c0       	rjmp	.+8      	; 0x31a8 <vStreamBufferDelete+0x10>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    31a0:	cf 01       	movw	r24, r30
    31a2:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
    31a6:	08 95       	ret
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    31a8:	8f e0       	ldi	r24, 0x0F	; 15
    31aa:	df 01       	movw	r26, r30
    31ac:	1d 92       	st	X+, r1
    31ae:	8a 95       	dec	r24
    31b0:	e9 f7       	brne	.-6      	; 0x31ac <vStreamBufferDelete+0x14>
    31b2:	08 95       	ret

000031b4 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    31b4:	cf 92       	push	r12
    31b6:	df 92       	push	r13
    31b8:	ff 92       	push	r15
    31ba:	0f 93       	push	r16
    31bc:	1f 93       	push	r17
    31be:	cf 93       	push	r28
    31c0:	df 93       	push	r29
    31c2:	6c 01       	movw	r12, r24
    31c4:	8b 01       	movw	r16, r22
    31c6:	f4 2e       	mov	r15, r20

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    31c8:	61 15       	cp	r22, r1
    31ca:	71 05       	cpc	r23, r1
    31cc:	11 f4       	brne	.+4      	; 0x31d2 <xStreamBufferGenericCreate+0x1e>
    31ce:	01 e0       	ldi	r16, 0x01	; 1
    31d0:	10 e0       	ldi	r17, 0x00	; 0
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    31d2:	c6 01       	movw	r24, r12
    31d4:	40 96       	adiw	r24, 0x10	; 16
    31d6:	c8 16       	cp	r12, r24
    31d8:	d9 06       	cpc	r13, r25
    31da:	18 f0       	brcs	.+6      	; 0x31e2 <xStreamBufferGenericCreate+0x2e>
    31dc:	a0 e0       	ldi	r26, 0x00	; 0
    31de:	b0 e0       	ldi	r27, 0x00	; 0
    31e0:	1d c0       	rjmp	.+58     	; 0x321c <xStreamBufferGenericCreate+0x68>
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    31e2:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    31e6:	fc 01       	movw	r30, r24
    31e8:	dc 01       	movw	r26, r24
        else
        {
            pucAllocatedMemory = NULL;
        }

        if( pucAllocatedMemory != NULL )
    31ea:	00 97       	sbiw	r24, 0x00	; 0
    31ec:	b9 f0       	breq	.+46     	; 0x321c <xStreamBufferGenericCreate+0x68>
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    31ee:	8f e0       	ldi	r24, 0x0F	; 15
    31f0:	ef 01       	movw	r28, r30
    31f2:	19 92       	st	Y+, r1
    31f4:	8a 95       	dec	r24
    31f6:	e9 f7       	brne	.-6      	; 0x31f2 <xStreamBufferGenericCreate+0x3e>
    pxStreamBuffer->pucBuffer = pucBuffer;
    31f8:	1f 96       	adiw	r26, 0x0f	; 15
    31fa:	b5 87       	std	Z+13, r27	; 0x0d
    31fc:	a4 87       	std	Z+12, r26	; 0x0c
    31fe:	1f 97       	sbiw	r26, 0x0f	; 15
    pxStreamBuffer->xLength = xBufferSizeBytes;
    3200:	08 94       	sec
    3202:	c1 1c       	adc	r12, r1
    3204:	d1 1c       	adc	r13, r1
    3206:	d5 82       	std	Z+5, r13	; 0x05
    3208:	c4 82       	std	Z+4, r12	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    320a:	17 83       	std	Z+7, r17	; 0x07
    320c:	06 83       	std	Z+6, r16	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    320e:	16 86       	std	Z+14, r1	; 0x0e
    3210:	81 e0       	ldi	r24, 0x01	; 1
    3212:	f8 16       	cp	r15, r24
    3214:	19 f4       	brne	.+6      	; 0x321c <xStreamBufferGenericCreate+0x68>
    3216:	1e 96       	adiw	r26, 0x0e	; 14
    3218:	fc 92       	st	X, r15
    321a:	1e 97       	sbiw	r26, 0x0e	; 14
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }
    321c:	cd 01       	movw	r24, r26
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	1f 91       	pop	r17
    3224:	0f 91       	pop	r16
    3226:	ff 90       	pop	r15
    3228:	df 90       	pop	r13
    322a:	cf 90       	pop	r12
    322c:	08 95       	ret

0000322e <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    322e:	80 91 c1 07 	lds	r24, 0x07C1
    3232:	8f 5f       	subi	r24, 0xFF	; 255
    3234:	80 93 c1 07 	sts	0x07C1, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    3238:	08 95       	ret

0000323a <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    323a:	0f b6       	in	r0, 0x3f	; 63
    323c:	f8 94       	cli
    323e:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    3240:	20 91 c4 07 	lds	r18, 0x07C4
    3244:	30 91 c5 07 	lds	r19, 0x07C5
    }
    portTICK_TYPE_EXIT_CRITICAL();
    3248:	0f 90       	pop	r0
    324a:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    324c:	c9 01       	movw	r24, r18
    324e:	08 95       	ret

00003250 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    3250:	20 91 c4 07 	lds	r18, 0x07C4
    3254:	30 91 c5 07 	lds	r19, 0x07C5
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    3258:	c9 01       	movw	r24, r18
    325a:	08 95       	ret

0000325c <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    325c:	80 91 cb 07 	lds	r24, 0x07CB
}
    3260:	08 95       	ret

00003262 <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3262:	00 97       	sbiw	r24, 0x00	; 0
    3264:	21 f4       	brne	.+8      	; 0x326e <pcTaskGetName+0xc>
    3266:	80 91 bf 07 	lds	r24, 0x07BF
    326a:	90 91 c0 07 	lds	r25, 0x07C0
    326e:	9c 01       	movw	r18, r24
    3270:	27 5e       	subi	r18, 0xE7	; 231
    3272:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    3274:	c9 01       	movw	r24, r18
    3276:	08 95       	ret

00003278 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    3278:	ef 92       	push	r14
    327a:	ff 92       	push	r15
    327c:	0f 93       	push	r16
    327e:	1f 93       	push	r17
    3280:	cf 93       	push	r28
    3282:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3284:	80 91 c1 07 	lds	r24, 0x07C1
    3288:	88 23       	and	r24, r24
    328a:	09 f0       	breq	.+2      	; 0x328e <xTaskIncrementTick+0x16>
    328c:	fb c0       	rjmp	.+502    	; 0x3484 <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    328e:	00 91 c4 07 	lds	r16, 0x07C4
    3292:	10 91 c5 07 	lds	r17, 0x07C5
    3296:	0f 5f       	subi	r16, 0xFF	; 255
    3298:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    329a:	10 93 c5 07 	sts	0x07C5, r17
    329e:	00 93 c4 07 	sts	0x07C4, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    32a2:	01 15       	cp	r16, r1
    32a4:	11 05       	cpc	r17, r1
    32a6:	61 f5       	brne	.+88     	; 0x3300 <xTaskIncrementTick+0x88>
        {
            taskSWITCH_DELAYED_LISTS();
    32a8:	20 91 19 08 	lds	r18, 0x0819
    32ac:	30 91 1a 08 	lds	r19, 0x081A
    32b0:	80 91 1b 08 	lds	r24, 0x081B
    32b4:	90 91 1c 08 	lds	r25, 0x081C
    32b8:	90 93 1a 08 	sts	0x081A, r25
    32bc:	80 93 19 08 	sts	0x0819, r24
    32c0:	30 93 1c 08 	sts	0x081C, r19
    32c4:	20 93 1b 08 	sts	0x081B, r18
    32c8:	80 91 c8 07 	lds	r24, 0x07C8
    32cc:	8f 5f       	subi	r24, 0xFF	; 255
    32ce:	80 93 c8 07 	sts	0x07C8, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    32d2:	e0 91 19 08 	lds	r30, 0x0819
    32d6:	f0 91 1a 08 	lds	r31, 0x081A
    32da:	80 81       	ld	r24, Z
    32dc:	88 23       	and	r24, r24
    32de:	19 f4       	brne	.+6      	; 0x32e6 <xTaskIncrementTick+0x6e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    32e0:	8f ef       	ldi	r24, 0xFF	; 255
    32e2:	9f ef       	ldi	r25, 0xFF	; 255
    32e4:	09 c0       	rjmp	.+18     	; 0x32f8 <xTaskIncrementTick+0x80>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    32e6:	e0 91 19 08 	lds	r30, 0x0819
    32ea:	f0 91 1a 08 	lds	r31, 0x081A
    32ee:	05 80       	ldd	r0, Z+5	; 0x05
    32f0:	f6 81       	ldd	r31, Z+6	; 0x06
    32f2:	e0 2d       	mov	r30, r0
    32f4:	80 81       	ld	r24, Z
    32f6:	91 81       	ldd	r25, Z+1	; 0x01
    32f8:	90 93 c7 07 	sts	0x07C7, r25
    32fc:	80 93 c6 07 	sts	0x07C6, r24

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    3300:	80 91 c6 07 	lds	r24, 0x07C6
    3304:	90 91 c7 07 	lds	r25, 0x07C7
    3308:	08 17       	cp	r16, r24
    330a:	19 07       	cpc	r17, r25
    330c:	08 f4       	brcc	.+2      	; 0x3310 <xTaskIncrementTick+0x98>
    330e:	a2 c0       	rjmp	.+324    	; 0x3454 <xTaskIncrementTick+0x1dc>
    3310:	ff 24       	eor	r15, r15
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    3312:	39 e0       	ldi	r19, 0x09	; 9
    3314:	e3 2e       	mov	r14, r19
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3316:	e0 91 19 08 	lds	r30, 0x0819
    331a:	f0 91 1a 08 	lds	r31, 0x081A
    331e:	80 81       	ld	r24, Z
    3320:	88 23       	and	r24, r24
    3322:	19 f4       	brne	.+6      	; 0x332a <xTaskIncrementTick+0xb2>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3324:	8f ef       	ldi	r24, 0xFF	; 255
    3326:	9f ef       	ldi	r25, 0xFF	; 255
    3328:	0e c0       	rjmp	.+28     	; 0x3346 <xTaskIncrementTick+0xce>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    332a:	e0 91 19 08 	lds	r30, 0x0819
    332e:	f0 91 1a 08 	lds	r31, 0x081A
    3332:	05 80       	ldd	r0, Z+5	; 0x05
    3334:	f6 81       	ldd	r31, Z+6	; 0x06
    3336:	e0 2d       	mov	r30, r0
    3338:	c6 81       	ldd	r28, Z+6	; 0x06
    333a:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    333c:	8a 81       	ldd	r24, Y+2	; 0x02
    333e:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    3340:	08 17       	cp	r16, r24
    3342:	19 07       	cpc	r17, r25
    3344:	28 f4       	brcc	.+10     	; 0x3350 <xTaskIncrementTick+0xd8>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    3346:	90 93 c7 07 	sts	0x07C7, r25
    334a:	80 93 c6 07 	sts	0x07C6, r24
    334e:	83 c0       	rjmp	.+262    	; 0x3456 <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3350:	aa 85       	ldd	r26, Y+10	; 0x0a
    3352:	bb 85       	ldd	r27, Y+11	; 0x0b
    3354:	4c 81       	ldd	r20, Y+4	; 0x04
    3356:	5d 81       	ldd	r21, Y+5	; 0x05
    3358:	8e 81       	ldd	r24, Y+6	; 0x06
    335a:	9f 81       	ldd	r25, Y+7	; 0x07
    335c:	fa 01       	movw	r30, r20
    335e:	95 83       	std	Z+5, r25	; 0x05
    3360:	84 83       	std	Z+4, r24	; 0x04
    3362:	2e 81       	ldd	r18, Y+6	; 0x06
    3364:	3f 81       	ldd	r19, Y+7	; 0x07
    3366:	f9 01       	movw	r30, r18
    3368:	53 83       	std	Z+3, r21	; 0x03
    336a:	42 83       	std	Z+2, r20	; 0x02
    336c:	be 01       	movw	r22, r28
    336e:	6e 5f       	subi	r22, 0xFE	; 254
    3370:	7f 4f       	sbci	r23, 0xFF	; 255
    3372:	11 96       	adiw	r26, 0x01	; 1
    3374:	8d 91       	ld	r24, X+
    3376:	9c 91       	ld	r25, X
    3378:	12 97       	sbiw	r26, 0x02	; 2
    337a:	86 17       	cp	r24, r22
    337c:	97 07       	cpc	r25, r23
    337e:	21 f4       	brne	.+8      	; 0x3388 <xTaskIncrementTick+0x110>
    3380:	12 96       	adiw	r26, 0x02	; 2
    3382:	3c 93       	st	X, r19
    3384:	2e 93       	st	-X, r18
    3386:	11 97       	sbiw	r26, 0x01	; 1
    3388:	1b 86       	std	Y+11, r1	; 0x0b
    338a:	1a 86       	std	Y+10, r1	; 0x0a
    338c:	8c 91       	ld	r24, X
    338e:	81 50       	subi	r24, 0x01	; 1
    3390:	8c 93       	st	X, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3392:	ac 89       	ldd	r26, Y+20	; 0x14
    3394:	bd 89       	ldd	r27, Y+21	; 0x15
    3396:	10 97       	sbiw	r26, 0x00	; 0
    3398:	f9 f0       	breq	.+62     	; 0x33d8 <xTaskIncrementTick+0x160>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    339a:	2e 85       	ldd	r18, Y+14	; 0x0e
    339c:	3f 85       	ldd	r19, Y+15	; 0x0f
    339e:	88 89       	ldd	r24, Y+16	; 0x10
    33a0:	99 89       	ldd	r25, Y+17	; 0x11
    33a2:	f9 01       	movw	r30, r18
    33a4:	95 83       	std	Z+5, r25	; 0x05
    33a6:	84 83       	std	Z+4, r24	; 0x04
    33a8:	48 89       	ldd	r20, Y+16	; 0x10
    33aa:	59 89       	ldd	r21, Y+17	; 0x11
    33ac:	fa 01       	movw	r30, r20
    33ae:	33 83       	std	Z+3, r19	; 0x03
    33b0:	22 83       	std	Z+2, r18	; 0x02
    33b2:	9e 01       	movw	r18, r28
    33b4:	24 5f       	subi	r18, 0xF4	; 244
    33b6:	3f 4f       	sbci	r19, 0xFF	; 255
    33b8:	11 96       	adiw	r26, 0x01	; 1
    33ba:	8d 91       	ld	r24, X+
    33bc:	9c 91       	ld	r25, X
    33be:	12 97       	sbiw	r26, 0x02	; 2
    33c0:	82 17       	cp	r24, r18
    33c2:	93 07       	cpc	r25, r19
    33c4:	21 f4       	brne	.+8      	; 0x33ce <xTaskIncrementTick+0x156>
    33c6:	12 96       	adiw	r26, 0x02	; 2
    33c8:	5c 93       	st	X, r21
    33ca:	4e 93       	st	-X, r20
    33cc:	11 97       	sbiw	r26, 0x01	; 1
    33ce:	1d 8a       	std	Y+21, r1	; 0x15
    33d0:	1c 8a       	std	Y+20, r1	; 0x14
    33d2:	8c 91       	ld	r24, X
    33d4:	81 50       	subi	r24, 0x01	; 1
    33d6:	8c 93       	st	X, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    33d8:	9e 89       	ldd	r25, Y+22	; 0x16
    33da:	80 91 c2 07 	lds	r24, 0x07C2
    33de:	89 17       	cp	r24, r25
    33e0:	10 f4       	brcc	.+4      	; 0x33e6 <xTaskIncrementTick+0x16e>
    33e2:	90 93 c2 07 	sts	0x07C2, r25
    33e6:	89 2f       	mov	r24, r25
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	fc 01       	movw	r30, r24
    33ec:	23 e0       	ldi	r18, 0x03	; 3
    33ee:	ee 0f       	add	r30, r30
    33f0:	ff 1f       	adc	r31, r31
    33f2:	2a 95       	dec	r18
    33f4:	e1 f7       	brne	.-8      	; 0x33ee <xTaskIncrementTick+0x176>
    33f6:	e8 0f       	add	r30, r24
    33f8:	f9 1f       	adc	r31, r25
    33fa:	ef 52       	subi	r30, 0x2F	; 47
    33fc:	f8 4f       	sbci	r31, 0xF8	; 248
    33fe:	a1 81       	ldd	r26, Z+1	; 0x01
    3400:	b2 81       	ldd	r27, Z+2	; 0x02
    3402:	bd 83       	std	Y+5, r27	; 0x05
    3404:	ac 83       	std	Y+4, r26	; 0x04
    3406:	14 96       	adiw	r26, 0x04	; 4
    3408:	8d 91       	ld	r24, X+
    340a:	9c 91       	ld	r25, X
    340c:	15 97       	sbiw	r26, 0x05	; 5
    340e:	9f 83       	std	Y+7, r25	; 0x07
    3410:	8e 83       	std	Y+6, r24	; 0x06
    3412:	14 96       	adiw	r26, 0x04	; 4
    3414:	ed 91       	ld	r30, X+
    3416:	fc 91       	ld	r31, X
    3418:	15 97       	sbiw	r26, 0x05	; 5
    341a:	73 83       	std	Z+3, r23	; 0x03
    341c:	62 83       	std	Z+2, r22	; 0x02
    341e:	15 96       	adiw	r26, 0x05	; 5
    3420:	7c 93       	st	X, r23
    3422:	6e 93       	st	-X, r22
    3424:	14 97       	sbiw	r26, 0x04	; 4
    3426:	ee 89       	ldd	r30, Y+22	; 0x16
    3428:	ee 9d       	mul	r30, r14
    342a:	f0 01       	movw	r30, r0
    342c:	11 24       	eor	r1, r1
    342e:	ef 52       	subi	r30, 0x2F	; 47
    3430:	f8 4f       	sbci	r31, 0xF8	; 248
    3432:	fb 87       	std	Y+11, r31	; 0x0b
    3434:	ea 87       	std	Y+10, r30	; 0x0a
    3436:	80 81       	ld	r24, Z
    3438:	8f 5f       	subi	r24, 0xFF	; 255
    343a:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    343c:	e0 91 bf 07 	lds	r30, 0x07BF
    3440:	f0 91 c0 07 	lds	r31, 0x07C0
    3444:	9e 89       	ldd	r25, Y+22	; 0x16
    3446:	86 89       	ldd	r24, Z+22	; 0x16
    3448:	89 17       	cp	r24, r25
    344a:	08 f0       	brcs	.+2      	; 0x344e <xTaskIncrementTick+0x1d6>
    344c:	64 cf       	rjmp	.-312    	; 0x3316 <xTaskIncrementTick+0x9e>
    344e:	ff 24       	eor	r15, r15
    3450:	f3 94       	inc	r15
    3452:	61 cf       	rjmp	.-318    	; 0x3316 <xTaskIncrementTick+0x9e>
    3454:	ff 24       	eor	r15, r15
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3456:	e0 91 bf 07 	lds	r30, 0x07BF
    345a:	f0 91 c0 07 	lds	r31, 0x07C0
    345e:	e6 89       	ldd	r30, Z+22	; 0x16
    3460:	89 e0       	ldi	r24, 0x09	; 9
    3462:	e8 9f       	mul	r30, r24
    3464:	f0 01       	movw	r30, r0
    3466:	11 24       	eor	r1, r1
    3468:	ef 52       	subi	r30, 0x2F	; 47
    346a:	f8 4f       	sbci	r31, 0xF8	; 248
    346c:	80 81       	ld	r24, Z
    346e:	82 30       	cpi	r24, 0x02	; 2
    3470:	10 f0       	brcs	.+4      	; 0x3476 <xTaskIncrementTick+0x1fe>
    3472:	ff 24       	eor	r15, r15
    3474:	f3 94       	inc	r15
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    3476:	80 91 c3 07 	lds	r24, 0x07C3
    347a:	88 23       	and	r24, r24
    347c:	69 f0       	breq	.+26     	; 0x3498 <xTaskIncrementTick+0x220>
    347e:	ff 24       	eor	r15, r15
    3480:	f3 94       	inc	r15
    3482:	0a c0       	rjmp	.+20     	; 0x3498 <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    3484:	80 91 c9 07 	lds	r24, 0x07C9
    3488:	90 91 ca 07 	lds	r25, 0x07CA
    348c:	01 96       	adiw	r24, 0x01	; 1
    348e:	90 93 ca 07 	sts	0x07CA, r25
    3492:	80 93 c9 07 	sts	0x07C9, r24
    3496:	ff 24       	eor	r15, r15
        }
        #endif
    }

    return xSwitchRequired;
}
    3498:	8f 2d       	mov	r24, r15
    349a:	df 91       	pop	r29
    349c:	cf 91       	pop	r28
    349e:	1f 91       	pop	r17
    34a0:	0f 91       	pop	r16
    34a2:	ff 90       	pop	r15
    34a4:	ef 90       	pop	r14
    34a6:	08 95       	ret

000034a8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    34a8:	80 91 c1 07 	lds	r24, 0x07C1
    34ac:	88 23       	and	r24, r24
    34ae:	21 f0       	breq	.+8      	; 0x34b8 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    34b0:	81 e0       	ldi	r24, 0x01	; 1
    34b2:	80 93 c3 07 	sts	0x07C3, r24
    34b6:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    34b8:	10 92 c3 07 	sts	0x07C3, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    34bc:	20 91 c2 07 	lds	r18, 0x07C2
    34c0:	99 e0       	ldi	r25, 0x09	; 9
    34c2:	01 c0       	rjmp	.+2      	; 0x34c6 <vTaskSwitchContext+0x1e>
    34c4:	21 50       	subi	r18, 0x01	; 1
    34c6:	29 9f       	mul	r18, r25
    34c8:	d0 01       	movw	r26, r0
    34ca:	11 24       	eor	r1, r1
    34cc:	af 52       	subi	r26, 0x2F	; 47
    34ce:	b8 4f       	sbci	r27, 0xF8	; 248
    34d0:	8c 91       	ld	r24, X
    34d2:	88 23       	and	r24, r24
    34d4:	b9 f3       	breq	.-18     	; 0x34c4 <vTaskSwitchContext+0x1c>
    34d6:	11 96       	adiw	r26, 0x01	; 1
    34d8:	ed 91       	ld	r30, X+
    34da:	fc 91       	ld	r31, X
    34dc:	12 97       	sbiw	r26, 0x02	; 2
    34de:	02 80       	ldd	r0, Z+2	; 0x02
    34e0:	f3 81       	ldd	r31, Z+3	; 0x03
    34e2:	e0 2d       	mov	r30, r0
    34e4:	12 96       	adiw	r26, 0x02	; 2
    34e6:	fc 93       	st	X, r31
    34e8:	ee 93       	st	-X, r30
    34ea:	11 97       	sbiw	r26, 0x01	; 1
    34ec:	cd 01       	movw	r24, r26
    34ee:	03 96       	adiw	r24, 0x03	; 3
    34f0:	e8 17       	cp	r30, r24
    34f2:	f9 07       	cpc	r31, r25
    34f4:	31 f4       	brne	.+12     	; 0x3502 <vTaskSwitchContext+0x5a>
    34f6:	82 81       	ldd	r24, Z+2	; 0x02
    34f8:	93 81       	ldd	r25, Z+3	; 0x03
    34fa:	12 96       	adiw	r26, 0x02	; 2
    34fc:	9c 93       	st	X, r25
    34fe:	8e 93       	st	-X, r24
    3500:	11 97       	sbiw	r26, 0x01	; 1
    3502:	11 96       	adiw	r26, 0x01	; 1
    3504:	ed 91       	ld	r30, X+
    3506:	fc 91       	ld	r31, X
    3508:	12 97       	sbiw	r26, 0x02	; 2
    350a:	86 81       	ldd	r24, Z+6	; 0x06
    350c:	97 81       	ldd	r25, Z+7	; 0x07
    350e:	90 93 c0 07 	sts	0x07C0, r25
    3512:	80 93 bf 07 	sts	0x07BF, r24
    3516:	20 93 c2 07 	sts	0x07C2, r18
    351a:	08 95       	ret

0000351c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    351c:	cf 93       	push	r28
    351e:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3520:	dc 01       	movw	r26, r24
    3522:	15 96       	adiw	r26, 0x05	; 5
    3524:	ed 91       	ld	r30, X+
    3526:	fc 91       	ld	r31, X
    3528:	16 97       	sbiw	r26, 0x06	; 6
    352a:	c6 81       	ldd	r28, Z+6	; 0x06
    352c:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    352e:	ac 89       	ldd	r26, Y+20	; 0x14
    3530:	bd 89       	ldd	r27, Y+21	; 0x15
    3532:	4e 85       	ldd	r20, Y+14	; 0x0e
    3534:	5f 85       	ldd	r21, Y+15	; 0x0f
    3536:	88 89       	ldd	r24, Y+16	; 0x10
    3538:	99 89       	ldd	r25, Y+17	; 0x11
    353a:	fa 01       	movw	r30, r20
    353c:	95 83       	std	Z+5, r25	; 0x05
    353e:	84 83       	std	Z+4, r24	; 0x04
    3540:	28 89       	ldd	r18, Y+16	; 0x10
    3542:	39 89       	ldd	r19, Y+17	; 0x11
    3544:	f9 01       	movw	r30, r18
    3546:	53 83       	std	Z+3, r21	; 0x03
    3548:	42 83       	std	Z+2, r20	; 0x02
    354a:	ae 01       	movw	r20, r28
    354c:	44 5f       	subi	r20, 0xF4	; 244
    354e:	5f 4f       	sbci	r21, 0xFF	; 255
    3550:	11 96       	adiw	r26, 0x01	; 1
    3552:	8d 91       	ld	r24, X+
    3554:	9c 91       	ld	r25, X
    3556:	12 97       	sbiw	r26, 0x02	; 2
    3558:	84 17       	cp	r24, r20
    355a:	95 07       	cpc	r25, r21
    355c:	21 f4       	brne	.+8      	; 0x3566 <xTaskRemoveFromEventList+0x4a>
    355e:	12 96       	adiw	r26, 0x02	; 2
    3560:	3c 93       	st	X, r19
    3562:	2e 93       	st	-X, r18
    3564:	11 97       	sbiw	r26, 0x01	; 1
    3566:	1d 8a       	std	Y+21, r1	; 0x15
    3568:	1c 8a       	std	Y+20, r1	; 0x14
    356a:	8c 91       	ld	r24, X
    356c:	81 50       	subi	r24, 0x01	; 1
    356e:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3570:	80 91 c1 07 	lds	r24, 0x07C1
    3574:	88 23       	and	r24, r24
    3576:	09 f0       	breq	.+2      	; 0x357a <xTaskRemoveFromEventList+0x5e>
    3578:	55 c0       	rjmp	.+170    	; 0x3624 <xTaskRemoveFromEventList+0x108>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    357a:	aa 85       	ldd	r26, Y+10	; 0x0a
    357c:	bb 85       	ldd	r27, Y+11	; 0x0b
    357e:	4c 81       	ldd	r20, Y+4	; 0x04
    3580:	5d 81       	ldd	r21, Y+5	; 0x05
    3582:	8e 81       	ldd	r24, Y+6	; 0x06
    3584:	9f 81       	ldd	r25, Y+7	; 0x07
    3586:	fa 01       	movw	r30, r20
    3588:	95 83       	std	Z+5, r25	; 0x05
    358a:	84 83       	std	Z+4, r24	; 0x04
    358c:	2e 81       	ldd	r18, Y+6	; 0x06
    358e:	3f 81       	ldd	r19, Y+7	; 0x07
    3590:	f9 01       	movw	r30, r18
    3592:	53 83       	std	Z+3, r21	; 0x03
    3594:	42 83       	std	Z+2, r20	; 0x02
    3596:	ae 01       	movw	r20, r28
    3598:	4e 5f       	subi	r20, 0xFE	; 254
    359a:	5f 4f       	sbci	r21, 0xFF	; 255
    359c:	11 96       	adiw	r26, 0x01	; 1
    359e:	8d 91       	ld	r24, X+
    35a0:	9c 91       	ld	r25, X
    35a2:	12 97       	sbiw	r26, 0x02	; 2
    35a4:	84 17       	cp	r24, r20
    35a6:	95 07       	cpc	r25, r21
    35a8:	21 f4       	brne	.+8      	; 0x35b2 <xTaskRemoveFromEventList+0x96>
    35aa:	12 96       	adiw	r26, 0x02	; 2
    35ac:	3c 93       	st	X, r19
    35ae:	2e 93       	st	-X, r18
    35b0:	11 97       	sbiw	r26, 0x01	; 1
    35b2:	1b 86       	std	Y+11, r1	; 0x0b
    35b4:	1a 86       	std	Y+10, r1	; 0x0a
    35b6:	8c 91       	ld	r24, X
    35b8:	81 50       	subi	r24, 0x01	; 1
    35ba:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    35bc:	9e 89       	ldd	r25, Y+22	; 0x16
    35be:	80 91 c2 07 	lds	r24, 0x07C2
    35c2:	89 17       	cp	r24, r25
    35c4:	10 f4       	brcc	.+4      	; 0x35ca <xTaskRemoveFromEventList+0xae>
    35c6:	90 93 c2 07 	sts	0x07C2, r25
    35ca:	89 2f       	mov	r24, r25
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	fc 01       	movw	r30, r24
    35d0:	63 e0       	ldi	r22, 0x03	; 3
    35d2:	ee 0f       	add	r30, r30
    35d4:	ff 1f       	adc	r31, r31
    35d6:	6a 95       	dec	r22
    35d8:	e1 f7       	brne	.-8      	; 0x35d2 <xTaskRemoveFromEventList+0xb6>
    35da:	e8 0f       	add	r30, r24
    35dc:	f9 1f       	adc	r31, r25
    35de:	ef 52       	subi	r30, 0x2F	; 47
    35e0:	f8 4f       	sbci	r31, 0xF8	; 248
    35e2:	a1 81       	ldd	r26, Z+1	; 0x01
    35e4:	b2 81       	ldd	r27, Z+2	; 0x02
    35e6:	bd 83       	std	Y+5, r27	; 0x05
    35e8:	ac 83       	std	Y+4, r26	; 0x04
    35ea:	14 96       	adiw	r26, 0x04	; 4
    35ec:	8d 91       	ld	r24, X+
    35ee:	9c 91       	ld	r25, X
    35f0:	15 97       	sbiw	r26, 0x05	; 5
    35f2:	9f 83       	std	Y+7, r25	; 0x07
    35f4:	8e 83       	std	Y+6, r24	; 0x06
    35f6:	14 96       	adiw	r26, 0x04	; 4
    35f8:	ed 91       	ld	r30, X+
    35fa:	fc 91       	ld	r31, X
    35fc:	15 97       	sbiw	r26, 0x05	; 5
    35fe:	53 83       	std	Z+3, r21	; 0x03
    3600:	42 83       	std	Z+2, r20	; 0x02
    3602:	15 96       	adiw	r26, 0x05	; 5
    3604:	5c 93       	st	X, r21
    3606:	4e 93       	st	-X, r20
    3608:	14 97       	sbiw	r26, 0x04	; 4
    360a:	ee 89       	ldd	r30, Y+22	; 0x16
    360c:	89 e0       	ldi	r24, 0x09	; 9
    360e:	e8 9f       	mul	r30, r24
    3610:	f0 01       	movw	r30, r0
    3612:	11 24       	eor	r1, r1
    3614:	ef 52       	subi	r30, 0x2F	; 47
    3616:	f8 4f       	sbci	r31, 0xF8	; 248
    3618:	fb 87       	std	Y+11, r31	; 0x0b
    361a:	ea 87       	std	Y+10, r30	; 0x0a
    361c:	80 81       	ld	r24, Z
    361e:	8f 5f       	subi	r24, 0xFF	; 255
    3620:	80 83       	st	Z, r24
    3622:	1f c0       	rjmp	.+62     	; 0x3662 <xTaskRemoveFromEventList+0x146>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3624:	a0 91 1e 08 	lds	r26, 0x081E
    3628:	b0 91 1f 08 	lds	r27, 0x081F
    362c:	bf 87       	std	Y+15, r27	; 0x0f
    362e:	ae 87       	std	Y+14, r26	; 0x0e
    3630:	14 96       	adiw	r26, 0x04	; 4
    3632:	8d 91       	ld	r24, X+
    3634:	9c 91       	ld	r25, X
    3636:	15 97       	sbiw	r26, 0x05	; 5
    3638:	99 8b       	std	Y+17, r25	; 0x11
    363a:	88 8b       	std	Y+16, r24	; 0x10
    363c:	14 96       	adiw	r26, 0x04	; 4
    363e:	ed 91       	ld	r30, X+
    3640:	fc 91       	ld	r31, X
    3642:	15 97       	sbiw	r26, 0x05	; 5
    3644:	53 83       	std	Z+3, r21	; 0x03
    3646:	42 83       	std	Z+2, r20	; 0x02
    3648:	15 96       	adiw	r26, 0x05	; 5
    364a:	5c 93       	st	X, r21
    364c:	4e 93       	st	-X, r20
    364e:	14 97       	sbiw	r26, 0x04	; 4
    3650:	8d e1       	ldi	r24, 0x1D	; 29
    3652:	98 e0       	ldi	r25, 0x08	; 8
    3654:	9d 8b       	std	Y+21, r25	; 0x15
    3656:	8c 8b       	std	Y+20, r24	; 0x14
    3658:	80 91 1d 08 	lds	r24, 0x081D
    365c:	8f 5f       	subi	r24, 0xFF	; 255
    365e:	80 93 1d 08 	sts	0x081D, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3662:	e0 91 bf 07 	lds	r30, 0x07BF
    3666:	f0 91 c0 07 	lds	r31, 0x07C0
    366a:	9e 89       	ldd	r25, Y+22	; 0x16
    366c:	86 89       	ldd	r24, Z+22	; 0x16
    366e:	89 17       	cp	r24, r25
    3670:	10 f0       	brcs	.+4      	; 0x3676 <xTaskRemoveFromEventList+0x15a>
    3672:	80 e0       	ldi	r24, 0x00	; 0
    3674:	03 c0       	rjmp	.+6      	; 0x367c <xTaskRemoveFromEventList+0x160>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    3676:	81 e0       	ldi	r24, 0x01	; 1
    3678:	80 93 c3 07 	sts	0x07C3, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    367c:	df 91       	pop	r29
    367e:	cf 91       	pop	r28
    3680:	08 95       	ret

00003682 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    3682:	cf 93       	push	r28
    3684:	df 93       	push	r29
    3686:	dc 01       	movw	r26, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3688:	70 68       	ori	r23, 0x80	; 128
    368a:	11 96       	adiw	r26, 0x01	; 1
    368c:	7c 93       	st	X, r23
    368e:	6e 93       	st	-X, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3690:	16 96       	adiw	r26, 0x06	; 6
    3692:	2d 91       	ld	r18, X+
    3694:	3c 91       	ld	r19, X
    3696:	17 97       	sbiw	r26, 0x07	; 7
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    3698:	18 96       	adiw	r26, 0x08	; 8
    369a:	cd 91       	ld	r28, X+
    369c:	dc 91       	ld	r29, X
    369e:	19 97       	sbiw	r26, 0x09	; 9
    36a0:	12 96       	adiw	r26, 0x02	; 2
    36a2:	6d 91       	ld	r22, X+
    36a4:	7c 91       	ld	r23, X
    36a6:	13 97       	sbiw	r26, 0x03	; 3
    36a8:	14 96       	adiw	r26, 0x04	; 4
    36aa:	8d 91       	ld	r24, X+
    36ac:	9c 91       	ld	r25, X
    36ae:	15 97       	sbiw	r26, 0x05	; 5
    36b0:	fb 01       	movw	r30, r22
    36b2:	95 83       	std	Z+5, r25	; 0x05
    36b4:	84 83       	std	Z+4, r24	; 0x04
    36b6:	14 96       	adiw	r26, 0x04	; 4
    36b8:	4d 91       	ld	r20, X+
    36ba:	5c 91       	ld	r21, X
    36bc:	15 97       	sbiw	r26, 0x05	; 5
    36be:	fa 01       	movw	r30, r20
    36c0:	73 83       	std	Z+3, r23	; 0x03
    36c2:	62 83       	std	Z+2, r22	; 0x02
    36c4:	89 81       	ldd	r24, Y+1	; 0x01
    36c6:	9a 81       	ldd	r25, Y+2	; 0x02
    36c8:	8a 17       	cp	r24, r26
    36ca:	9b 07       	cpc	r25, r27
    36cc:	11 f4       	brne	.+4      	; 0x36d2 <vTaskRemoveFromUnorderedEventList+0x50>
    36ce:	5a 83       	std	Y+2, r21	; 0x02
    36d0:	49 83       	std	Y+1, r20	; 0x01
    36d2:	19 96       	adiw	r26, 0x09	; 9
    36d4:	1c 92       	st	X, r1
    36d6:	1e 92       	st	-X, r1
    36d8:	18 97       	sbiw	r26, 0x08	; 8
    36da:	88 81       	ld	r24, Y
    36dc:	81 50       	subi	r24, 0x01	; 1
    36de:	88 83       	st	Y, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    36e0:	e9 01       	movw	r28, r18
    36e2:	aa 85       	ldd	r26, Y+10	; 0x0a
    36e4:	bb 85       	ldd	r27, Y+11	; 0x0b
    36e6:	4c 81       	ldd	r20, Y+4	; 0x04
    36e8:	5d 81       	ldd	r21, Y+5	; 0x05
    36ea:	8e 81       	ldd	r24, Y+6	; 0x06
    36ec:	9f 81       	ldd	r25, Y+7	; 0x07
    36ee:	fa 01       	movw	r30, r20
    36f0:	95 83       	std	Z+5, r25	; 0x05
    36f2:	84 83       	std	Z+4, r24	; 0x04
    36f4:	0e 80       	ldd	r0, Y+6	; 0x06
    36f6:	df 81       	ldd	r29, Y+7	; 0x07
    36f8:	c0 2d       	mov	r28, r0
    36fa:	5b 83       	std	Y+3, r21	; 0x03
    36fc:	4a 83       	std	Y+2, r20	; 0x02
    36fe:	a9 01       	movw	r20, r18
    3700:	4e 5f       	subi	r20, 0xFE	; 254
    3702:	5f 4f       	sbci	r21, 0xFF	; 255
    3704:	11 96       	adiw	r26, 0x01	; 1
    3706:	8d 91       	ld	r24, X+
    3708:	9c 91       	ld	r25, X
    370a:	12 97       	sbiw	r26, 0x02	; 2
    370c:	84 17       	cp	r24, r20
    370e:	95 07       	cpc	r25, r21
    3710:	21 f4       	brne	.+8      	; 0x371a <vTaskRemoveFromUnorderedEventList+0x98>
    3712:	12 96       	adiw	r26, 0x02	; 2
    3714:	dc 93       	st	X, r29
    3716:	ce 93       	st	-X, r28
    3718:	11 97       	sbiw	r26, 0x01	; 1
    371a:	e9 01       	movw	r28, r18
    371c:	1b 86       	std	Y+11, r1	; 0x0b
    371e:	1a 86       	std	Y+10, r1	; 0x0a
    3720:	8c 91       	ld	r24, X
    3722:	81 50       	subi	r24, 0x01	; 1
    3724:	8c 93       	st	X, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    3726:	9e 89       	ldd	r25, Y+22	; 0x16
    3728:	80 91 c2 07 	lds	r24, 0x07C2
    372c:	89 17       	cp	r24, r25
    372e:	10 f4       	brcc	.+4      	; 0x3734 <vTaskRemoveFromUnorderedEventList+0xb2>
    3730:	90 93 c2 07 	sts	0x07C2, r25
    3734:	89 2f       	mov	r24, r25
    3736:	90 e0       	ldi	r25, 0x00	; 0
    3738:	fc 01       	movw	r30, r24
    373a:	73 e0       	ldi	r23, 0x03	; 3
    373c:	ee 0f       	add	r30, r30
    373e:	ff 1f       	adc	r31, r31
    3740:	7a 95       	dec	r23
    3742:	e1 f7       	brne	.-8      	; 0x373c <vTaskRemoveFromUnorderedEventList+0xba>
    3744:	e8 0f       	add	r30, r24
    3746:	f9 1f       	adc	r31, r25
    3748:	ef 52       	subi	r30, 0x2F	; 47
    374a:	f8 4f       	sbci	r31, 0xF8	; 248
    374c:	a1 81       	ldd	r26, Z+1	; 0x01
    374e:	b2 81       	ldd	r27, Z+2	; 0x02
    3750:	f9 01       	movw	r30, r18
    3752:	b5 83       	std	Z+5, r27	; 0x05
    3754:	a4 83       	std	Z+4, r26	; 0x04
    3756:	14 96       	adiw	r26, 0x04	; 4
    3758:	8d 91       	ld	r24, X+
    375a:	9c 91       	ld	r25, X
    375c:	15 97       	sbiw	r26, 0x05	; 5
    375e:	97 83       	std	Z+7, r25	; 0x07
    3760:	86 83       	std	Z+6, r24	; 0x06
    3762:	14 96       	adiw	r26, 0x04	; 4
    3764:	ed 91       	ld	r30, X+
    3766:	fc 91       	ld	r31, X
    3768:	15 97       	sbiw	r26, 0x05	; 5
    376a:	53 83       	std	Z+3, r21	; 0x03
    376c:	42 83       	std	Z+2, r20	; 0x02
    376e:	15 96       	adiw	r26, 0x05	; 5
    3770:	5c 93       	st	X, r21
    3772:	4e 93       	st	-X, r20
    3774:	14 97       	sbiw	r26, 0x04	; 4
    3776:	d9 01       	movw	r26, r18
    3778:	56 96       	adiw	r26, 0x16	; 22
    377a:	ec 91       	ld	r30, X
    377c:	56 97       	sbiw	r26, 0x16	; 22
    377e:	89 e0       	ldi	r24, 0x09	; 9
    3780:	e8 9f       	mul	r30, r24
    3782:	f0 01       	movw	r30, r0
    3784:	11 24       	eor	r1, r1
    3786:	ef 52       	subi	r30, 0x2F	; 47
    3788:	f8 4f       	sbci	r31, 0xF8	; 248
    378a:	1b 96       	adiw	r26, 0x0b	; 11
    378c:	fc 93       	st	X, r31
    378e:	ee 93       	st	-X, r30
    3790:	1a 97       	sbiw	r26, 0x0a	; 10
    3792:	80 81       	ld	r24, Z
    3794:	8f 5f       	subi	r24, 0xFF	; 255
    3796:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3798:	e0 91 bf 07 	lds	r30, 0x07BF
    379c:	f0 91 c0 07 	lds	r31, 0x07C0
    37a0:	56 96       	adiw	r26, 0x16	; 22
    37a2:	9c 91       	ld	r25, X
    37a4:	86 89       	ldd	r24, Z+22	; 0x16
    37a6:	89 17       	cp	r24, r25
    37a8:	18 f4       	brcc	.+6      	; 0x37b0 <vTaskRemoveFromUnorderedEventList+0x12e>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    37aa:	81 e0       	ldi	r24, 0x01	; 1
    37ac:	80 93 c3 07 	sts	0x07C3, r24
    }
}
    37b0:	df 91       	pop	r29
    37b2:	cf 91       	pop	r28
    37b4:	08 95       	ret

000037b6 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    37b6:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    37b8:	0f b6       	in	r0, 0x3f	; 63
    37ba:	f8 94       	cli
    37bc:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    37be:	80 91 c8 07 	lds	r24, 0x07C8
    37c2:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    37c4:	80 91 c4 07 	lds	r24, 0x07C4
    37c8:	90 91 c5 07 	lds	r25, 0x07C5
    37cc:	92 83       	std	Z+2, r25	; 0x02
    37ce:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    37d0:	0f 90       	pop	r0
    37d2:	0f be       	out	0x3f, r0	; 63
}
    37d4:	08 95       	ret

000037d6 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    37d6:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    37d8:	80 91 c8 07 	lds	r24, 0x07C8
    37dc:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    37de:	80 91 c4 07 	lds	r24, 0x07C4
    37e2:	90 91 c5 07 	lds	r25, 0x07C5
    37e6:	92 83       	std	Z+2, r25	; 0x02
    37e8:	81 83       	std	Z+1, r24	; 0x01
}
    37ea:	08 95       	ret

000037ec <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    37ec:	dc 01       	movw	r26, r24
    37ee:	fb 01       	movw	r30, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    37f0:	0f b6       	in	r0, 0x3f	; 63
    37f2:	f8 94       	cli
    37f4:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    37f6:	40 91 c4 07 	lds	r20, 0x07C4
    37fa:	50 91 c5 07 	lds	r21, 0x07C5
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    37fe:	11 96       	adiw	r26, 0x01	; 1
    3800:	2d 91       	ld	r18, X+
    3802:	3c 91       	ld	r19, X
    3804:	12 97       	sbiw	r26, 0x02	; 2
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3806:	90 91 c8 07 	lds	r25, 0x07C8
    380a:	8c 91       	ld	r24, X
    380c:	98 17       	cp	r25, r24
    380e:	19 f0       	breq	.+6      	; 0x3816 <xTaskCheckForTimeOut+0x2a>
    3810:	42 17       	cp	r20, r18
    3812:	53 07       	cpc	r21, r19
    3814:	d0 f4       	brcc	.+52     	; 0x384a <xTaskCheckForTimeOut+0x5e>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3816:	ca 01       	movw	r24, r20
    3818:	82 1b       	sub	r24, r18
    381a:	93 0b       	sbc	r25, r19
    381c:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    381e:	80 81       	ld	r24, Z
    3820:	91 81       	ldd	r25, Z+1	; 0x01
    3822:	28 17       	cp	r18, r24
    3824:	39 07       	cpc	r19, r25
    3826:	88 f4       	brcc	.+34     	; 0x384a <xTaskCheckForTimeOut+0x5e>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    3828:	82 1b       	sub	r24, r18
    382a:	93 0b       	sbc	r25, r19
    382c:	91 83       	std	Z+1, r25	; 0x01
    382e:	80 83       	st	Z, r24
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    3830:	80 91 c8 07 	lds	r24, 0x07C8
    3834:	8c 93       	st	X, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    3836:	80 91 c4 07 	lds	r24, 0x07C4
    383a:	90 91 c5 07 	lds	r25, 0x07C5
    383e:	12 96       	adiw	r26, 0x02	; 2
    3840:	9c 93       	st	X, r25
    3842:	8e 93       	st	-X, r24
    3844:	11 97       	sbiw	r26, 0x01	; 1
    3846:	80 e0       	ldi	r24, 0x00	; 0
    3848:	03 c0       	rjmp	.+6      	; 0x3850 <xTaskCheckForTimeOut+0x64>
            vTaskInternalSetTimeOutState( pxTimeOut );
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    384a:	11 82       	std	Z+1, r1	; 0x01
    384c:	10 82       	st	Z, r1
    384e:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    3850:	0f 90       	pop	r0
    3852:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    3854:	08 95       	ret

00003856 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    3856:	81 e0       	ldi	r24, 0x01	; 1
    3858:	80 93 c3 07 	sts	0x07C3, r24
}
    385c:	08 95       	ret

0000385e <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    385e:	20 91 bf 07 	lds	r18, 0x07BF
    3862:	30 91 c0 07 	lds	r19, 0x07C0

        return xReturn;
    }
    3866:	c9 01       	movw	r24, r18
    3868:	08 95       	ret

0000386a <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    386a:	e0 91 bf 07 	lds	r30, 0x07BF
    386e:	f0 91 c0 07 	lds	r31, 0x07C0
    3872:	84 85       	ldd	r24, Z+12	; 0x0c
    3874:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3876:	a0 91 bf 07 	lds	r26, 0x07BF
    387a:	b0 91 c0 07 	lds	r27, 0x07C0
    387e:	e0 91 bf 07 	lds	r30, 0x07BF
    3882:	f0 91 c0 07 	lds	r31, 0x07C0
    3886:	46 89       	ldd	r20, Z+22	; 0x16
    3888:	26 e0       	ldi	r18, 0x06	; 6
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	24 1b       	sub	r18, r20
    388e:	31 09       	sbc	r19, r1
    3890:	1d 96       	adiw	r26, 0x0d	; 13
    3892:	3c 93       	st	X, r19
    3894:	2e 93       	st	-X, r18
    3896:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    3898:	08 95       	ret

0000389a <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    389a:	cf 92       	push	r12
    389c:	df 92       	push	r13
    389e:	ef 92       	push	r14
    38a0:	ff 92       	push	r15
    38a2:	0f 93       	push	r16
    38a4:	cf 93       	push	r28
    38a6:	df 93       	push	r29
    38a8:	ec 01       	movw	r28, r24

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    38aa:	e1 14       	cp	r14, r1
    38ac:	f1 04       	cpc	r15, r1
    38ae:	89 f0       	breq	.+34     	; 0x38d2 <xTaskGenericNotifyFromISR+0x38>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    38b0:	e6 2f       	mov	r30, r22
    38b2:	f0 e0       	ldi	r31, 0x00	; 0
    38b4:	ee 0f       	add	r30, r30
    38b6:	ff 1f       	adc	r31, r31
    38b8:	ee 0f       	add	r30, r30
    38ba:	ff 1f       	adc	r31, r31
    38bc:	e8 0f       	add	r30, r24
    38be:	f9 1f       	adc	r31, r25
    38c0:	81 a1       	ldd	r24, Z+33	; 0x21
    38c2:	92 a1       	ldd	r25, Z+34	; 0x22
    38c4:	a3 a1       	ldd	r26, Z+35	; 0x23
    38c6:	b4 a1       	ldd	r27, Z+36	; 0x24
    38c8:	f7 01       	movw	r30, r14
    38ca:	80 83       	st	Z, r24
    38cc:	91 83       	std	Z+1, r25	; 0x01
    38ce:	a2 83       	std	Z+2, r26	; 0x02
    38d0:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    38d2:	a6 2f       	mov	r26, r22
    38d4:	b0 e0       	ldi	r27, 0x00	; 0
    38d6:	fe 01       	movw	r30, r28
    38d8:	ea 0f       	add	r30, r26
    38da:	fb 1f       	adc	r31, r27
    38dc:	65 a1       	ldd	r22, Z+37	; 0x25
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    38de:	82 e0       	ldi	r24, 0x02	; 2
    38e0:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    38e2:	02 30       	cpi	r16, 0x02	; 2
    38e4:	d1 f0       	breq	.+52     	; 0x391a <xTaskGenericNotifyFromISR+0x80>
    38e6:	03 30       	cpi	r16, 0x03	; 3
    38e8:	18 f4       	brcc	.+6      	; 0x38f0 <xTaskGenericNotifyFromISR+0x56>
    38ea:	01 30       	cpi	r16, 0x01	; 1
    38ec:	c9 f5       	brne	.+114    	; 0x3960 <xTaskGenericNotifyFromISR+0xc6>
    38ee:	05 c0       	rjmp	.+10     	; 0x38fa <xTaskGenericNotifyFromISR+0x60>
    38f0:	03 30       	cpi	r16, 0x03	; 3
    38f2:	51 f1       	breq	.+84     	; 0x3948 <xTaskGenericNotifyFromISR+0xae>
    38f4:	04 30       	cpi	r16, 0x04	; 4
    38f6:	a1 f5       	brne	.+104    	; 0x3960 <xTaskGenericNotifyFromISR+0xc6>
    38f8:	23 c0       	rjmp	.+70     	; 0x3940 <xTaskGenericNotifyFromISR+0xa6>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    38fa:	fd 01       	movw	r30, r26
    38fc:	ee 0f       	add	r30, r30
    38fe:	ff 1f       	adc	r31, r31
    3900:	ee 0f       	add	r30, r30
    3902:	ff 1f       	adc	r31, r31
    3904:	ec 0f       	add	r30, r28
    3906:	fd 1f       	adc	r31, r29
    3908:	81 a1       	ldd	r24, Z+33	; 0x21
    390a:	92 a1       	ldd	r25, Z+34	; 0x22
    390c:	a3 a1       	ldd	r26, Z+35	; 0x23
    390e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3910:	82 2b       	or	r24, r18
    3912:	93 2b       	or	r25, r19
    3914:	a4 2b       	or	r26, r20
    3916:	b5 2b       	or	r27, r21
    3918:	0e c0       	rjmp	.+28     	; 0x3936 <xTaskGenericNotifyFromISR+0x9c>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    391a:	fd 01       	movw	r30, r26
    391c:	ee 0f       	add	r30, r30
    391e:	ff 1f       	adc	r31, r31
    3920:	ee 0f       	add	r30, r30
    3922:	ff 1f       	adc	r31, r31
    3924:	ec 0f       	add	r30, r28
    3926:	fd 1f       	adc	r31, r29
    3928:	81 a1       	ldd	r24, Z+33	; 0x21
    392a:	92 a1       	ldd	r25, Z+34	; 0x22
    392c:	a3 a1       	ldd	r26, Z+35	; 0x23
    392e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3930:	01 96       	adiw	r24, 0x01	; 1
    3932:	a1 1d       	adc	r26, r1
    3934:	b1 1d       	adc	r27, r1
    3936:	81 a3       	std	Z+33, r24	; 0x21
    3938:	92 a3       	std	Z+34, r25	; 0x22
    393a:	a3 a3       	std	Z+35, r26	; 0x23
    393c:	b4 a3       	std	Z+36, r27	; 0x24
    393e:	10 c0       	rjmp	.+32     	; 0x3960 <xTaskGenericNotifyFromISR+0xc6>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3940:	62 30       	cpi	r22, 0x02	; 2
    3942:	11 f4       	brne	.+4      	; 0x3948 <xTaskGenericNotifyFromISR+0xae>
    3944:	80 e0       	ldi	r24, 0x00	; 0
    3946:	9d c0       	rjmp	.+314    	; 0x3a82 <xTaskGenericNotifyFromISR+0x1e8>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    3948:	aa 0f       	add	r26, r26
    394a:	bb 1f       	adc	r27, r27
    394c:	aa 0f       	add	r26, r26
    394e:	bb 1f       	adc	r27, r27
    3950:	ac 0f       	add	r26, r28
    3952:	bd 1f       	adc	r27, r29
    3954:	91 96       	adiw	r26, 0x21	; 33
    3956:	2d 93       	st	X+, r18
    3958:	3d 93       	st	X+, r19
    395a:	4d 93       	st	X+, r20
    395c:	5c 93       	st	X, r21
    395e:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3960:	61 30       	cpi	r22, 0x01	; 1
    3962:	09 f0       	breq	.+2      	; 0x3966 <xTaskGenericNotifyFromISR+0xcc>
    3964:	8d c0       	rjmp	.+282    	; 0x3a80 <xTaskGenericNotifyFromISR+0x1e6>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3966:	80 91 c1 07 	lds	r24, 0x07C1
    396a:	88 23       	and	r24, r24
    396c:	09 f0       	breq	.+2      	; 0x3970 <xTaskGenericNotifyFromISR+0xd6>
    396e:	55 c0       	rjmp	.+170    	; 0x3a1a <xTaskGenericNotifyFromISR+0x180>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3970:	aa 85       	ldd	r26, Y+10	; 0x0a
    3972:	bb 85       	ldd	r27, Y+11	; 0x0b
    3974:	4c 81       	ldd	r20, Y+4	; 0x04
    3976:	5d 81       	ldd	r21, Y+5	; 0x05
    3978:	8e 81       	ldd	r24, Y+6	; 0x06
    397a:	9f 81       	ldd	r25, Y+7	; 0x07
    397c:	fa 01       	movw	r30, r20
    397e:	95 83       	std	Z+5, r25	; 0x05
    3980:	84 83       	std	Z+4, r24	; 0x04
    3982:	2e 81       	ldd	r18, Y+6	; 0x06
    3984:	3f 81       	ldd	r19, Y+7	; 0x07
    3986:	f9 01       	movw	r30, r18
    3988:	53 83       	std	Z+3, r21	; 0x03
    398a:	42 83       	std	Z+2, r20	; 0x02
    398c:	ae 01       	movw	r20, r28
    398e:	4e 5f       	subi	r20, 0xFE	; 254
    3990:	5f 4f       	sbci	r21, 0xFF	; 255
    3992:	11 96       	adiw	r26, 0x01	; 1
    3994:	8d 91       	ld	r24, X+
    3996:	9c 91       	ld	r25, X
    3998:	12 97       	sbiw	r26, 0x02	; 2
    399a:	84 17       	cp	r24, r20
    399c:	95 07       	cpc	r25, r21
    399e:	21 f4       	brne	.+8      	; 0x39a8 <xTaskGenericNotifyFromISR+0x10e>
    39a0:	12 96       	adiw	r26, 0x02	; 2
    39a2:	3c 93       	st	X, r19
    39a4:	2e 93       	st	-X, r18
    39a6:	11 97       	sbiw	r26, 0x01	; 1
    39a8:	1b 86       	std	Y+11, r1	; 0x0b
    39aa:	1a 86       	std	Y+10, r1	; 0x0a
    39ac:	8c 91       	ld	r24, X
    39ae:	81 50       	subi	r24, 0x01	; 1
    39b0:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    39b2:	9e 89       	ldd	r25, Y+22	; 0x16
    39b4:	80 91 c2 07 	lds	r24, 0x07C2
    39b8:	89 17       	cp	r24, r25
    39ba:	10 f4       	brcc	.+4      	; 0x39c0 <xTaskGenericNotifyFromISR+0x126>
    39bc:	90 93 c2 07 	sts	0x07C2, r25
    39c0:	89 2f       	mov	r24, r25
    39c2:	90 e0       	ldi	r25, 0x00	; 0
    39c4:	fc 01       	movw	r30, r24
    39c6:	a3 e0       	ldi	r26, 0x03	; 3
    39c8:	ee 0f       	add	r30, r30
    39ca:	ff 1f       	adc	r31, r31
    39cc:	aa 95       	dec	r26
    39ce:	e1 f7       	brne	.-8      	; 0x39c8 <xTaskGenericNotifyFromISR+0x12e>
    39d0:	e8 0f       	add	r30, r24
    39d2:	f9 1f       	adc	r31, r25
    39d4:	ef 52       	subi	r30, 0x2F	; 47
    39d6:	f8 4f       	sbci	r31, 0xF8	; 248
    39d8:	a1 81       	ldd	r26, Z+1	; 0x01
    39da:	b2 81       	ldd	r27, Z+2	; 0x02
    39dc:	bd 83       	std	Y+5, r27	; 0x05
    39de:	ac 83       	std	Y+4, r26	; 0x04
    39e0:	14 96       	adiw	r26, 0x04	; 4
    39e2:	8d 91       	ld	r24, X+
    39e4:	9c 91       	ld	r25, X
    39e6:	15 97       	sbiw	r26, 0x05	; 5
    39e8:	9f 83       	std	Y+7, r25	; 0x07
    39ea:	8e 83       	std	Y+6, r24	; 0x06
    39ec:	14 96       	adiw	r26, 0x04	; 4
    39ee:	ed 91       	ld	r30, X+
    39f0:	fc 91       	ld	r31, X
    39f2:	15 97       	sbiw	r26, 0x05	; 5
    39f4:	53 83       	std	Z+3, r21	; 0x03
    39f6:	42 83       	std	Z+2, r20	; 0x02
    39f8:	15 96       	adiw	r26, 0x05	; 5
    39fa:	5c 93       	st	X, r21
    39fc:	4e 93       	st	-X, r20
    39fe:	14 97       	sbiw	r26, 0x04	; 4
    3a00:	ee 89       	ldd	r30, Y+22	; 0x16
    3a02:	89 e0       	ldi	r24, 0x09	; 9
    3a04:	e8 9f       	mul	r30, r24
    3a06:	f0 01       	movw	r30, r0
    3a08:	11 24       	eor	r1, r1
    3a0a:	ef 52       	subi	r30, 0x2F	; 47
    3a0c:	f8 4f       	sbci	r31, 0xF8	; 248
    3a0e:	fb 87       	std	Y+11, r31	; 0x0b
    3a10:	ea 87       	std	Y+10, r30	; 0x0a
    3a12:	80 81       	ld	r24, Z
    3a14:	8f 5f       	subi	r24, 0xFF	; 255
    3a16:	80 83       	st	Z, r24
    3a18:	21 c0       	rjmp	.+66     	; 0x3a5c <xTaskGenericNotifyFromISR+0x1c2>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3a1a:	a0 91 1e 08 	lds	r26, 0x081E
    3a1e:	b0 91 1f 08 	lds	r27, 0x081F
    3a22:	bf 87       	std	Y+15, r27	; 0x0f
    3a24:	ae 87       	std	Y+14, r26	; 0x0e
    3a26:	14 96       	adiw	r26, 0x04	; 4
    3a28:	8d 91       	ld	r24, X+
    3a2a:	9c 91       	ld	r25, X
    3a2c:	15 97       	sbiw	r26, 0x05	; 5
    3a2e:	99 8b       	std	Y+17, r25	; 0x11
    3a30:	88 8b       	std	Y+16, r24	; 0x10
    3a32:	ce 01       	movw	r24, r28
    3a34:	0c 96       	adiw	r24, 0x0c	; 12
    3a36:	14 96       	adiw	r26, 0x04	; 4
    3a38:	ed 91       	ld	r30, X+
    3a3a:	fc 91       	ld	r31, X
    3a3c:	15 97       	sbiw	r26, 0x05	; 5
    3a3e:	93 83       	std	Z+3, r25	; 0x03
    3a40:	82 83       	std	Z+2, r24	; 0x02
    3a42:	15 96       	adiw	r26, 0x05	; 5
    3a44:	9c 93       	st	X, r25
    3a46:	8e 93       	st	-X, r24
    3a48:	14 97       	sbiw	r26, 0x04	; 4
    3a4a:	8d e1       	ldi	r24, 0x1D	; 29
    3a4c:	98 e0       	ldi	r25, 0x08	; 8
    3a4e:	9d 8b       	std	Y+21, r25	; 0x15
    3a50:	8c 8b       	std	Y+20, r24	; 0x14
    3a52:	80 91 1d 08 	lds	r24, 0x081D
    3a56:	8f 5f       	subi	r24, 0xFF	; 255
    3a58:	80 93 1d 08 	sts	0x081D, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3a5c:	e0 91 bf 07 	lds	r30, 0x07BF
    3a60:	f0 91 c0 07 	lds	r31, 0x07C0
    3a64:	9e 89       	ldd	r25, Y+22	; 0x16
    3a66:	86 89       	ldd	r24, Z+22	; 0x16
    3a68:	89 17       	cp	r24, r25
    3a6a:	50 f4       	brcc	.+20     	; 0x3a80 <xTaskGenericNotifyFromISR+0x1e6>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    3a6c:	c1 14       	cp	r12, r1
    3a6e:	d1 04       	cpc	r13, r1
    3a70:	19 f0       	breq	.+6      	; 0x3a78 <xTaskGenericNotifyFromISR+0x1de>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    3a72:	81 e0       	ldi	r24, 0x01	; 1
    3a74:	f6 01       	movw	r30, r12
    3a76:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    3a78:	81 e0       	ldi	r24, 0x01	; 1
    3a7a:	80 93 c3 07 	sts	0x07C3, r24
    3a7e:	01 c0       	rjmp	.+2      	; 0x3a82 <xTaskGenericNotifyFromISR+0x1e8>
    3a80:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    3a82:	df 91       	pop	r29
    3a84:	cf 91       	pop	r28
    3a86:	0f 91       	pop	r16
    3a88:	ff 90       	pop	r15
    3a8a:	ef 90       	pop	r14
    3a8c:	df 90       	pop	r13
    3a8e:	cf 90       	pop	r12
    3a90:	08 95       	ret

00003a92 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    3a92:	cf 93       	push	r28
    3a94:	df 93       	push	r29
    3a96:	ec 01       	movw	r28, r24
    3a98:	e6 2f       	mov	r30, r22
    3a9a:	ba 01       	movw	r22, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    3a9c:	f0 e0       	ldi	r31, 0x00	; 0
    3a9e:	dc 01       	movw	r26, r24
    3aa0:	ae 0f       	add	r26, r30
    3aa2:	bf 1f       	adc	r27, r31
    3aa4:	95 96       	adiw	r26, 0x25	; 37
    3aa6:	2c 91       	ld	r18, X
    3aa8:	95 97       	sbiw	r26, 0x25	; 37
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    3aaa:	82 e0       	ldi	r24, 0x02	; 2
    3aac:	95 96       	adiw	r26, 0x25	; 37
    3aae:	8c 93       	st	X, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    3ab0:	ee 0f       	add	r30, r30
    3ab2:	ff 1f       	adc	r31, r31
    3ab4:	ee 0f       	add	r30, r30
    3ab6:	ff 1f       	adc	r31, r31
    3ab8:	ec 0f       	add	r30, r28
    3aba:	fd 1f       	adc	r31, r29
    3abc:	81 a1       	ldd	r24, Z+33	; 0x21
    3abe:	92 a1       	ldd	r25, Z+34	; 0x22
    3ac0:	a3 a1       	ldd	r26, Z+35	; 0x23
    3ac2:	b4 a1       	ldd	r27, Z+36	; 0x24
    3ac4:	01 96       	adiw	r24, 0x01	; 1
    3ac6:	a1 1d       	adc	r26, r1
    3ac8:	b1 1d       	adc	r27, r1
    3aca:	81 a3       	std	Z+33, r24	; 0x21
    3acc:	92 a3       	std	Z+34, r25	; 0x22
    3ace:	a3 a3       	std	Z+35, r26	; 0x23
    3ad0:	b4 a3       	std	Z+36, r27	; 0x24

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3ad2:	21 30       	cpi	r18, 0x01	; 1
    3ad4:	09 f0       	breq	.+2      	; 0x3ad8 <vTaskGenericNotifyGiveFromISR+0x46>
    3ad6:	8c c0       	rjmp	.+280    	; 0x3bf0 <vTaskGenericNotifyGiveFromISR+0x15e>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3ad8:	80 91 c1 07 	lds	r24, 0x07C1
    3adc:	88 23       	and	r24, r24
    3ade:	09 f0       	breq	.+2      	; 0x3ae2 <vTaskGenericNotifyGiveFromISR+0x50>
    3ae0:	55 c0       	rjmp	.+170    	; 0x3b8c <vTaskGenericNotifyGiveFromISR+0xfa>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3ae2:	aa 85       	ldd	r26, Y+10	; 0x0a
    3ae4:	bb 85       	ldd	r27, Y+11	; 0x0b
    3ae6:	4c 81       	ldd	r20, Y+4	; 0x04
    3ae8:	5d 81       	ldd	r21, Y+5	; 0x05
    3aea:	8e 81       	ldd	r24, Y+6	; 0x06
    3aec:	9f 81       	ldd	r25, Y+7	; 0x07
    3aee:	fa 01       	movw	r30, r20
    3af0:	95 83       	std	Z+5, r25	; 0x05
    3af2:	84 83       	std	Z+4, r24	; 0x04
    3af4:	2e 81       	ldd	r18, Y+6	; 0x06
    3af6:	3f 81       	ldd	r19, Y+7	; 0x07
    3af8:	f9 01       	movw	r30, r18
    3afa:	53 83       	std	Z+3, r21	; 0x03
    3afc:	42 83       	std	Z+2, r20	; 0x02
    3afe:	ae 01       	movw	r20, r28
    3b00:	4e 5f       	subi	r20, 0xFE	; 254
    3b02:	5f 4f       	sbci	r21, 0xFF	; 255
    3b04:	11 96       	adiw	r26, 0x01	; 1
    3b06:	8d 91       	ld	r24, X+
    3b08:	9c 91       	ld	r25, X
    3b0a:	12 97       	sbiw	r26, 0x02	; 2
    3b0c:	84 17       	cp	r24, r20
    3b0e:	95 07       	cpc	r25, r21
    3b10:	21 f4       	brne	.+8      	; 0x3b1a <vTaskGenericNotifyGiveFromISR+0x88>
    3b12:	12 96       	adiw	r26, 0x02	; 2
    3b14:	3c 93       	st	X, r19
    3b16:	2e 93       	st	-X, r18
    3b18:	11 97       	sbiw	r26, 0x01	; 1
    3b1a:	1b 86       	std	Y+11, r1	; 0x0b
    3b1c:	1a 86       	std	Y+10, r1	; 0x0a
    3b1e:	8c 91       	ld	r24, X
    3b20:	81 50       	subi	r24, 0x01	; 1
    3b22:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    3b24:	9e 89       	ldd	r25, Y+22	; 0x16
    3b26:	80 91 c2 07 	lds	r24, 0x07C2
    3b2a:	89 17       	cp	r24, r25
    3b2c:	10 f4       	brcc	.+4      	; 0x3b32 <vTaskGenericNotifyGiveFromISR+0xa0>
    3b2e:	90 93 c2 07 	sts	0x07C2, r25
    3b32:	89 2f       	mov	r24, r25
    3b34:	90 e0       	ldi	r25, 0x00	; 0
    3b36:	fc 01       	movw	r30, r24
    3b38:	a3 e0       	ldi	r26, 0x03	; 3
    3b3a:	ee 0f       	add	r30, r30
    3b3c:	ff 1f       	adc	r31, r31
    3b3e:	aa 95       	dec	r26
    3b40:	e1 f7       	brne	.-8      	; 0x3b3a <vTaskGenericNotifyGiveFromISR+0xa8>
    3b42:	e8 0f       	add	r30, r24
    3b44:	f9 1f       	adc	r31, r25
    3b46:	ef 52       	subi	r30, 0x2F	; 47
    3b48:	f8 4f       	sbci	r31, 0xF8	; 248
    3b4a:	a1 81       	ldd	r26, Z+1	; 0x01
    3b4c:	b2 81       	ldd	r27, Z+2	; 0x02
    3b4e:	bd 83       	std	Y+5, r27	; 0x05
    3b50:	ac 83       	std	Y+4, r26	; 0x04
    3b52:	14 96       	adiw	r26, 0x04	; 4
    3b54:	8d 91       	ld	r24, X+
    3b56:	9c 91       	ld	r25, X
    3b58:	15 97       	sbiw	r26, 0x05	; 5
    3b5a:	9f 83       	std	Y+7, r25	; 0x07
    3b5c:	8e 83       	std	Y+6, r24	; 0x06
    3b5e:	14 96       	adiw	r26, 0x04	; 4
    3b60:	ed 91       	ld	r30, X+
    3b62:	fc 91       	ld	r31, X
    3b64:	15 97       	sbiw	r26, 0x05	; 5
    3b66:	53 83       	std	Z+3, r21	; 0x03
    3b68:	42 83       	std	Z+2, r20	; 0x02
    3b6a:	15 96       	adiw	r26, 0x05	; 5
    3b6c:	5c 93       	st	X, r21
    3b6e:	4e 93       	st	-X, r20
    3b70:	14 97       	sbiw	r26, 0x04	; 4
    3b72:	ee 89       	ldd	r30, Y+22	; 0x16
    3b74:	89 e0       	ldi	r24, 0x09	; 9
    3b76:	e8 9f       	mul	r30, r24
    3b78:	f0 01       	movw	r30, r0
    3b7a:	11 24       	eor	r1, r1
    3b7c:	ef 52       	subi	r30, 0x2F	; 47
    3b7e:	f8 4f       	sbci	r31, 0xF8	; 248
    3b80:	fb 87       	std	Y+11, r31	; 0x0b
    3b82:	ea 87       	std	Y+10, r30	; 0x0a
    3b84:	80 81       	ld	r24, Z
    3b86:	8f 5f       	subi	r24, 0xFF	; 255
    3b88:	80 83       	st	Z, r24
    3b8a:	21 c0       	rjmp	.+66     	; 0x3bce <vTaskGenericNotifyGiveFromISR+0x13c>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3b8c:	a0 91 1e 08 	lds	r26, 0x081E
    3b90:	b0 91 1f 08 	lds	r27, 0x081F
    3b94:	bf 87       	std	Y+15, r27	; 0x0f
    3b96:	ae 87       	std	Y+14, r26	; 0x0e
    3b98:	14 96       	adiw	r26, 0x04	; 4
    3b9a:	8d 91       	ld	r24, X+
    3b9c:	9c 91       	ld	r25, X
    3b9e:	15 97       	sbiw	r26, 0x05	; 5
    3ba0:	99 8b       	std	Y+17, r25	; 0x11
    3ba2:	88 8b       	std	Y+16, r24	; 0x10
    3ba4:	ce 01       	movw	r24, r28
    3ba6:	0c 96       	adiw	r24, 0x0c	; 12
    3ba8:	14 96       	adiw	r26, 0x04	; 4
    3baa:	ed 91       	ld	r30, X+
    3bac:	fc 91       	ld	r31, X
    3bae:	15 97       	sbiw	r26, 0x05	; 5
    3bb0:	93 83       	std	Z+3, r25	; 0x03
    3bb2:	82 83       	std	Z+2, r24	; 0x02
    3bb4:	15 96       	adiw	r26, 0x05	; 5
    3bb6:	9c 93       	st	X, r25
    3bb8:	8e 93       	st	-X, r24
    3bba:	14 97       	sbiw	r26, 0x04	; 4
    3bbc:	8d e1       	ldi	r24, 0x1D	; 29
    3bbe:	98 e0       	ldi	r25, 0x08	; 8
    3bc0:	9d 8b       	std	Y+21, r25	; 0x15
    3bc2:	8c 8b       	std	Y+20, r24	; 0x14
    3bc4:	80 91 1d 08 	lds	r24, 0x081D
    3bc8:	8f 5f       	subi	r24, 0xFF	; 255
    3bca:	80 93 1d 08 	sts	0x081D, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3bce:	e0 91 bf 07 	lds	r30, 0x07BF
    3bd2:	f0 91 c0 07 	lds	r31, 0x07C0
    3bd6:	9e 89       	ldd	r25, Y+22	; 0x16
    3bd8:	86 89       	ldd	r24, Z+22	; 0x16
    3bda:	89 17       	cp	r24, r25
    3bdc:	48 f4       	brcc	.+18     	; 0x3bf0 <vTaskGenericNotifyGiveFromISR+0x15e>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    3bde:	61 15       	cp	r22, r1
    3be0:	71 05       	cpc	r23, r1
    3be2:	19 f0       	breq	.+6      	; 0x3bea <vTaskGenericNotifyGiveFromISR+0x158>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	fb 01       	movw	r30, r22
    3be8:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    3bea:	81 e0       	ldi	r24, 0x01	; 1
    3bec:	80 93 c3 07 	sts	0x07C3, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    3bf0:	df 91       	pop	r29
    3bf2:	cf 91       	pop	r28
    3bf4:	08 95       	ret

00003bf6 <xTaskGenericNotifyStateClear>:

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    3bf6:	00 97       	sbiw	r24, 0x00	; 0
    3bf8:	21 f4       	brne	.+8      	; 0x3c02 <xTaskGenericNotifyStateClear+0xc>
    3bfa:	80 91 bf 07 	lds	r24, 0x07BF
    3bfe:	90 91 c0 07 	lds	r25, 0x07C0

        taskENTER_CRITICAL();
    3c02:	0f b6       	in	r0, 0x3f	; 63
    3c04:	f8 94       	cli
    3c06:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    3c08:	fc 01       	movw	r30, r24
    3c0a:	e6 0f       	add	r30, r22
    3c0c:	f1 1d       	adc	r31, r1
    3c0e:	85 a1       	ldd	r24, Z+37	; 0x25
    3c10:	82 30       	cpi	r24, 0x02	; 2
    3c12:	11 f0       	breq	.+4      	; 0x3c18 <xTaskGenericNotifyStateClear+0x22>
    3c14:	80 e0       	ldi	r24, 0x00	; 0
    3c16:	02 c0       	rjmp	.+4      	; 0x3c1c <xTaskGenericNotifyStateClear+0x26>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    3c18:	15 a2       	std	Z+37, r1	; 0x25
    3c1a:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    3c1c:	0f 90       	pop	r0
    3c1e:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    3c20:	08 95       	ret

00003c22 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    3c22:	ef 92       	push	r14
    3c24:	ff 92       	push	r15
    3c26:	0f 93       	push	r16
    3c28:	1f 93       	push	r17
    3c2a:	79 01       	movw	r14, r18
    3c2c:	8a 01       	movw	r16, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	21 f4       	brne	.+8      	; 0x3c3a <ulTaskGenericNotifyValueClear+0x18>
    3c32:	80 91 bf 07 	lds	r24, 0x07BF
    3c36:	90 91 c0 07 	lds	r25, 0x07C0

        taskENTER_CRITICAL();
    3c3a:	0f b6       	in	r0, 0x3f	; 63
    3c3c:	f8 94       	cli
    3c3e:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    3c40:	e6 2f       	mov	r30, r22
    3c42:	f0 e0       	ldi	r31, 0x00	; 0
    3c44:	ee 0f       	add	r30, r30
    3c46:	ff 1f       	adc	r31, r31
    3c48:	ee 0f       	add	r30, r30
    3c4a:	ff 1f       	adc	r31, r31
    3c4c:	e8 0f       	add	r30, r24
    3c4e:	f9 1f       	adc	r31, r25
    3c50:	21 a1       	ldd	r18, Z+33	; 0x21
    3c52:	32 a1       	ldd	r19, Z+34	; 0x22
    3c54:	43 a1       	ldd	r20, Z+35	; 0x23
    3c56:	54 a1       	ldd	r21, Z+36	; 0x24
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    3c58:	81 a1       	ldd	r24, Z+33	; 0x21
    3c5a:	92 a1       	ldd	r25, Z+34	; 0x22
    3c5c:	a3 a1       	ldd	r26, Z+35	; 0x23
    3c5e:	b4 a1       	ldd	r27, Z+36	; 0x24
    3c60:	e0 94       	com	r14
    3c62:	f0 94       	com	r15
    3c64:	00 95       	com	r16
    3c66:	10 95       	com	r17
    3c68:	8e 21       	and	r24, r14
    3c6a:	9f 21       	and	r25, r15
    3c6c:	a0 23       	and	r26, r16
    3c6e:	b1 23       	and	r27, r17
    3c70:	81 a3       	std	Z+33, r24	; 0x21
    3c72:	92 a3       	std	Z+34, r25	; 0x22
    3c74:	a3 a3       	std	Z+35, r26	; 0x23
    3c76:	b4 a3       	std	Z+36, r27	; 0x24
        }
        taskEXIT_CRITICAL();
    3c78:	0f 90       	pop	r0
    3c7a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    3c7c:	b9 01       	movw	r22, r18
    3c7e:	ca 01       	movw	r24, r20
    3c80:	1f 91       	pop	r17
    3c82:	0f 91       	pop	r16
    3c84:	ff 90       	pop	r15
    3c86:	ef 90       	pop	r14
    3c88:	08 95       	ret

00003c8a <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    3c8a:	ef 92       	push	r14
    3c8c:	ff 92       	push	r15
    3c8e:	0f 93       	push	r16
    3c90:	cf 93       	push	r28
    3c92:	df 93       	push	r29
    3c94:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    3c96:	0f b6       	in	r0, 0x3f	; 63
    3c98:	f8 94       	cli
    3c9a:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    3c9c:	e1 14       	cp	r14, r1
    3c9e:	f1 04       	cpc	r15, r1
    3ca0:	89 f0       	breq	.+34     	; 0x3cc4 <xTaskGenericNotify+0x3a>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    3ca2:	e6 2f       	mov	r30, r22
    3ca4:	f0 e0       	ldi	r31, 0x00	; 0
    3ca6:	ee 0f       	add	r30, r30
    3ca8:	ff 1f       	adc	r31, r31
    3caa:	ee 0f       	add	r30, r30
    3cac:	ff 1f       	adc	r31, r31
    3cae:	ec 0f       	add	r30, r28
    3cb0:	fd 1f       	adc	r31, r29
    3cb2:	81 a1       	ldd	r24, Z+33	; 0x21
    3cb4:	92 a1       	ldd	r25, Z+34	; 0x22
    3cb6:	a3 a1       	ldd	r26, Z+35	; 0x23
    3cb8:	b4 a1       	ldd	r27, Z+36	; 0x24
    3cba:	f7 01       	movw	r30, r14
    3cbc:	80 83       	st	Z, r24
    3cbe:	91 83       	std	Z+1, r25	; 0x01
    3cc0:	a2 83       	std	Z+2, r26	; 0x02
    3cc2:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    3cc4:	a6 2f       	mov	r26, r22
    3cc6:	b0 e0       	ldi	r27, 0x00	; 0
    3cc8:	fe 01       	movw	r30, r28
    3cca:	ea 0f       	add	r30, r26
    3ccc:	fb 1f       	adc	r31, r27
    3cce:	65 a1       	ldd	r22, Z+37	; 0x25

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    3cd0:	82 e0       	ldi	r24, 0x02	; 2
    3cd2:	85 a3       	std	Z+37, r24	; 0x25

            switch( eAction )
    3cd4:	02 30       	cpi	r16, 0x02	; 2
    3cd6:	d1 f0       	breq	.+52     	; 0x3d0c <xTaskGenericNotify+0x82>
    3cd8:	03 30       	cpi	r16, 0x03	; 3
    3cda:	18 f4       	brcc	.+6      	; 0x3ce2 <xTaskGenericNotify+0x58>
    3cdc:	01 30       	cpi	r16, 0x01	; 1
    3cde:	c9 f5       	brne	.+114    	; 0x3d52 <xTaskGenericNotify+0xc8>
    3ce0:	05 c0       	rjmp	.+10     	; 0x3cec <xTaskGenericNotify+0x62>
    3ce2:	03 30       	cpi	r16, 0x03	; 3
    3ce4:	51 f1       	breq	.+84     	; 0x3d3a <xTaskGenericNotify+0xb0>
    3ce6:	04 30       	cpi	r16, 0x04	; 4
    3ce8:	a1 f5       	brne	.+104    	; 0x3d52 <xTaskGenericNotify+0xc8>
    3cea:	23 c0       	rjmp	.+70     	; 0x3d32 <xTaskGenericNotify+0xa8>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    3cec:	fd 01       	movw	r30, r26
    3cee:	ee 0f       	add	r30, r30
    3cf0:	ff 1f       	adc	r31, r31
    3cf2:	ee 0f       	add	r30, r30
    3cf4:	ff 1f       	adc	r31, r31
    3cf6:	ec 0f       	add	r30, r28
    3cf8:	fd 1f       	adc	r31, r29
    3cfa:	81 a1       	ldd	r24, Z+33	; 0x21
    3cfc:	92 a1       	ldd	r25, Z+34	; 0x22
    3cfe:	a3 a1       	ldd	r26, Z+35	; 0x23
    3d00:	b4 a1       	ldd	r27, Z+36	; 0x24
    3d02:	82 2b       	or	r24, r18
    3d04:	93 2b       	or	r25, r19
    3d06:	a4 2b       	or	r26, r20
    3d08:	b5 2b       	or	r27, r21
    3d0a:	0e c0       	rjmp	.+28     	; 0x3d28 <xTaskGenericNotify+0x9e>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    3d0c:	fd 01       	movw	r30, r26
    3d0e:	ee 0f       	add	r30, r30
    3d10:	ff 1f       	adc	r31, r31
    3d12:	ee 0f       	add	r30, r30
    3d14:	ff 1f       	adc	r31, r31
    3d16:	ec 0f       	add	r30, r28
    3d18:	fd 1f       	adc	r31, r29
    3d1a:	81 a1       	ldd	r24, Z+33	; 0x21
    3d1c:	92 a1       	ldd	r25, Z+34	; 0x22
    3d1e:	a3 a1       	ldd	r26, Z+35	; 0x23
    3d20:	b4 a1       	ldd	r27, Z+36	; 0x24
    3d22:	01 96       	adiw	r24, 0x01	; 1
    3d24:	a1 1d       	adc	r26, r1
    3d26:	b1 1d       	adc	r27, r1
    3d28:	81 a3       	std	Z+33, r24	; 0x21
    3d2a:	92 a3       	std	Z+34, r25	; 0x22
    3d2c:	a3 a3       	std	Z+35, r26	; 0x23
    3d2e:	b4 a3       	std	Z+36, r27	; 0x24
    3d30:	10 c0       	rjmp	.+32     	; 0x3d52 <xTaskGenericNotify+0xc8>
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    3d32:	62 30       	cpi	r22, 0x02	; 2
    3d34:	11 f4       	brne	.+4      	; 0x3d3a <xTaskGenericNotify+0xb0>
    3d36:	80 e0       	ldi	r24, 0x00	; 0
    3d38:	6e c0       	rjmp	.+220    	; 0x3e16 <xTaskGenericNotify+0x18c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    3d3a:	aa 0f       	add	r26, r26
    3d3c:	bb 1f       	adc	r27, r27
    3d3e:	aa 0f       	add	r26, r26
    3d40:	bb 1f       	adc	r27, r27
    3d42:	ac 0f       	add	r26, r28
    3d44:	bd 1f       	adc	r27, r29
    3d46:	91 96       	adiw	r26, 0x21	; 33
    3d48:	2d 93       	st	X+, r18
    3d4a:	3d 93       	st	X+, r19
    3d4c:	4d 93       	st	X+, r20
    3d4e:	5c 93       	st	X, r21
    3d50:	94 97       	sbiw	r26, 0x24	; 36

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    3d52:	61 30       	cpi	r22, 0x01	; 1
    3d54:	09 f0       	breq	.+2      	; 0x3d58 <xTaskGenericNotify+0xce>
    3d56:	5e c0       	rjmp	.+188    	; 0x3e14 <xTaskGenericNotify+0x18a>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3d58:	aa 85       	ldd	r26, Y+10	; 0x0a
    3d5a:	bb 85       	ldd	r27, Y+11	; 0x0b
    3d5c:	4c 81       	ldd	r20, Y+4	; 0x04
    3d5e:	5d 81       	ldd	r21, Y+5	; 0x05
    3d60:	8e 81       	ldd	r24, Y+6	; 0x06
    3d62:	9f 81       	ldd	r25, Y+7	; 0x07
    3d64:	fa 01       	movw	r30, r20
    3d66:	95 83       	std	Z+5, r25	; 0x05
    3d68:	84 83       	std	Z+4, r24	; 0x04
    3d6a:	2e 81       	ldd	r18, Y+6	; 0x06
    3d6c:	3f 81       	ldd	r19, Y+7	; 0x07
    3d6e:	f9 01       	movw	r30, r18
    3d70:	53 83       	std	Z+3, r21	; 0x03
    3d72:	42 83       	std	Z+2, r20	; 0x02
    3d74:	ae 01       	movw	r20, r28
    3d76:	4e 5f       	subi	r20, 0xFE	; 254
    3d78:	5f 4f       	sbci	r21, 0xFF	; 255
    3d7a:	11 96       	adiw	r26, 0x01	; 1
    3d7c:	8d 91       	ld	r24, X+
    3d7e:	9c 91       	ld	r25, X
    3d80:	12 97       	sbiw	r26, 0x02	; 2
    3d82:	84 17       	cp	r24, r20
    3d84:	95 07       	cpc	r25, r21
    3d86:	21 f4       	brne	.+8      	; 0x3d90 <xTaskGenericNotify+0x106>
    3d88:	12 96       	adiw	r26, 0x02	; 2
    3d8a:	3c 93       	st	X, r19
    3d8c:	2e 93       	st	-X, r18
    3d8e:	11 97       	sbiw	r26, 0x01	; 1
    3d90:	1b 86       	std	Y+11, r1	; 0x0b
    3d92:	1a 86       	std	Y+10, r1	; 0x0a
    3d94:	8c 91       	ld	r24, X
    3d96:	81 50       	subi	r24, 0x01	; 1
    3d98:	8c 93       	st	X, r24
                prvAddTaskToReadyList( pxTCB );
    3d9a:	9e 89       	ldd	r25, Y+22	; 0x16
    3d9c:	80 91 c2 07 	lds	r24, 0x07C2
    3da0:	89 17       	cp	r24, r25
    3da2:	10 f4       	brcc	.+4      	; 0x3da8 <xTaskGenericNotify+0x11e>
    3da4:	90 93 c2 07 	sts	0x07C2, r25
    3da8:	89 2f       	mov	r24, r25
    3daa:	90 e0       	ldi	r25, 0x00	; 0
    3dac:	fc 01       	movw	r30, r24
    3dae:	33 e0       	ldi	r19, 0x03	; 3
    3db0:	ee 0f       	add	r30, r30
    3db2:	ff 1f       	adc	r31, r31
    3db4:	3a 95       	dec	r19
    3db6:	e1 f7       	brne	.-8      	; 0x3db0 <xTaskGenericNotify+0x126>
    3db8:	e8 0f       	add	r30, r24
    3dba:	f9 1f       	adc	r31, r25
    3dbc:	ef 52       	subi	r30, 0x2F	; 47
    3dbe:	f8 4f       	sbci	r31, 0xF8	; 248
    3dc0:	a1 81       	ldd	r26, Z+1	; 0x01
    3dc2:	b2 81       	ldd	r27, Z+2	; 0x02
    3dc4:	bd 83       	std	Y+5, r27	; 0x05
    3dc6:	ac 83       	std	Y+4, r26	; 0x04
    3dc8:	14 96       	adiw	r26, 0x04	; 4
    3dca:	8d 91       	ld	r24, X+
    3dcc:	9c 91       	ld	r25, X
    3dce:	15 97       	sbiw	r26, 0x05	; 5
    3dd0:	9f 83       	std	Y+7, r25	; 0x07
    3dd2:	8e 83       	std	Y+6, r24	; 0x06
    3dd4:	14 96       	adiw	r26, 0x04	; 4
    3dd6:	ed 91       	ld	r30, X+
    3dd8:	fc 91       	ld	r31, X
    3dda:	15 97       	sbiw	r26, 0x05	; 5
    3ddc:	53 83       	std	Z+3, r21	; 0x03
    3dde:	42 83       	std	Z+2, r20	; 0x02
    3de0:	15 96       	adiw	r26, 0x05	; 5
    3de2:	5c 93       	st	X, r21
    3de4:	4e 93       	st	-X, r20
    3de6:	14 97       	sbiw	r26, 0x04	; 4
    3de8:	ee 89       	ldd	r30, Y+22	; 0x16
    3dea:	89 e0       	ldi	r24, 0x09	; 9
    3dec:	e8 9f       	mul	r30, r24
    3dee:	f0 01       	movw	r30, r0
    3df0:	11 24       	eor	r1, r1
    3df2:	ef 52       	subi	r30, 0x2F	; 47
    3df4:	f8 4f       	sbci	r31, 0xF8	; 248
    3df6:	fb 87       	std	Y+11, r31	; 0x0b
    3df8:	ea 87       	std	Y+10, r30	; 0x0a
    3dfa:	80 81       	ld	r24, Z
    3dfc:	8f 5f       	subi	r24, 0xFF	; 255
    3dfe:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3e00:	e0 91 bf 07 	lds	r30, 0x07BF
    3e04:	f0 91 c0 07 	lds	r31, 0x07C0
    3e08:	9e 89       	ldd	r25, Y+22	; 0x16
    3e0a:	86 89       	ldd	r24, Z+22	; 0x16
    3e0c:	89 17       	cp	r24, r25
    3e0e:	10 f4       	brcc	.+4      	; 0x3e14 <xTaskGenericNotify+0x18a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    3e10:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    3e14:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    3e16:	0f 90       	pop	r0
    3e18:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    3e1a:	df 91       	pop	r29
    3e1c:	cf 91       	pop	r28
    3e1e:	0f 91       	pop	r16
    3e20:	ff 90       	pop	r15
    3e22:	ef 90       	pop	r14
    3e24:	08 95       	ret

00003e26 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3e26:	1f 93       	push	r17
    3e28:	cf 93       	push	r28
    3e2a:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    3e2c:	0f b6       	in	r0, 0x3f	; 63
    3e2e:	f8 94       	cli
    3e30:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    3e32:	80 91 c1 07 	lds	r24, 0x07C1
    3e36:	81 50       	subi	r24, 0x01	; 1
    3e38:	80 93 c1 07 	sts	0x07C1, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3e3c:	80 91 c1 07 	lds	r24, 0x07C1
    3e40:	88 23       	and	r24, r24
    3e42:	09 f0       	breq	.+2      	; 0x3e46 <xTaskResumeAll+0x20>
    3e44:	c7 c0       	rjmp	.+398    	; 0x3fd4 <xTaskResumeAll+0x1ae>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3e46:	80 91 cb 07 	lds	r24, 0x07CB
    3e4a:	88 23       	and	r24, r24
    3e4c:	09 f4       	brne	.+2      	; 0x3e50 <xTaskResumeAll+0x2a>
    3e4e:	c2 c0       	rjmp	.+388    	; 0x3fd4 <xTaskResumeAll+0x1ae>
    3e50:	c0 e0       	ldi	r28, 0x00	; 0
    3e52:	d0 e0       	ldi	r29, 0x00	; 0
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    3e54:	79 e0       	ldi	r23, 0x09	; 9

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    3e56:	61 e0       	ldi	r22, 0x01	; 1
    3e58:	84 c0       	rjmp	.+264    	; 0x3f62 <xTaskResumeAll+0x13c>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3e5a:	e0 91 22 08 	lds	r30, 0x0822
    3e5e:	f0 91 23 08 	lds	r31, 0x0823
    3e62:	c6 81       	ldd	r28, Z+6	; 0x06
    3e64:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    3e66:	ac 89       	ldd	r26, Y+20	; 0x14
    3e68:	bd 89       	ldd	r27, Y+21	; 0x15
    3e6a:	2e 85       	ldd	r18, Y+14	; 0x0e
    3e6c:	3f 85       	ldd	r19, Y+15	; 0x0f
    3e6e:	88 89       	ldd	r24, Y+16	; 0x10
    3e70:	99 89       	ldd	r25, Y+17	; 0x11
    3e72:	f9 01       	movw	r30, r18
    3e74:	95 83       	std	Z+5, r25	; 0x05
    3e76:	84 83       	std	Z+4, r24	; 0x04
    3e78:	48 89       	ldd	r20, Y+16	; 0x10
    3e7a:	59 89       	ldd	r21, Y+17	; 0x11
    3e7c:	fa 01       	movw	r30, r20
    3e7e:	33 83       	std	Z+3, r19	; 0x03
    3e80:	22 83       	std	Z+2, r18	; 0x02
    3e82:	9e 01       	movw	r18, r28
    3e84:	24 5f       	subi	r18, 0xF4	; 244
    3e86:	3f 4f       	sbci	r19, 0xFF	; 255
    3e88:	11 96       	adiw	r26, 0x01	; 1
    3e8a:	8d 91       	ld	r24, X+
    3e8c:	9c 91       	ld	r25, X
    3e8e:	12 97       	sbiw	r26, 0x02	; 2
    3e90:	82 17       	cp	r24, r18
    3e92:	93 07       	cpc	r25, r19
    3e94:	21 f4       	brne	.+8      	; 0x3e9e <xTaskResumeAll+0x78>
    3e96:	12 96       	adiw	r26, 0x02	; 2
    3e98:	5c 93       	st	X, r21
    3e9a:	4e 93       	st	-X, r20
    3e9c:	11 97       	sbiw	r26, 0x01	; 1
    3e9e:	1d 8a       	std	Y+21, r1	; 0x15
    3ea0:	1c 8a       	std	Y+20, r1	; 0x14
    3ea2:	8c 91       	ld	r24, X
    3ea4:	81 50       	subi	r24, 0x01	; 1
    3ea6:	8c 93       	st	X, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    3ea8:	aa 85       	ldd	r26, Y+10	; 0x0a
    3eaa:	bb 85       	ldd	r27, Y+11	; 0x0b
    3eac:	4c 81       	ldd	r20, Y+4	; 0x04
    3eae:	5d 81       	ldd	r21, Y+5	; 0x05
    3eb0:	8e 81       	ldd	r24, Y+6	; 0x06
    3eb2:	9f 81       	ldd	r25, Y+7	; 0x07
    3eb4:	fa 01       	movw	r30, r20
    3eb6:	95 83       	std	Z+5, r25	; 0x05
    3eb8:	84 83       	std	Z+4, r24	; 0x04
    3eba:	2e 81       	ldd	r18, Y+6	; 0x06
    3ebc:	3f 81       	ldd	r19, Y+7	; 0x07
    3ebe:	f9 01       	movw	r30, r18
    3ec0:	53 83       	std	Z+3, r21	; 0x03
    3ec2:	42 83       	std	Z+2, r20	; 0x02
    3ec4:	ae 01       	movw	r20, r28
    3ec6:	4e 5f       	subi	r20, 0xFE	; 254
    3ec8:	5f 4f       	sbci	r21, 0xFF	; 255
    3eca:	11 96       	adiw	r26, 0x01	; 1
    3ecc:	8d 91       	ld	r24, X+
    3ece:	9c 91       	ld	r25, X
    3ed0:	12 97       	sbiw	r26, 0x02	; 2
    3ed2:	84 17       	cp	r24, r20
    3ed4:	95 07       	cpc	r25, r21
    3ed6:	21 f4       	brne	.+8      	; 0x3ee0 <xTaskResumeAll+0xba>
    3ed8:	12 96       	adiw	r26, 0x02	; 2
    3eda:	3c 93       	st	X, r19
    3edc:	2e 93       	st	-X, r18
    3ede:	11 97       	sbiw	r26, 0x01	; 1
    3ee0:	1b 86       	std	Y+11, r1	; 0x0b
    3ee2:	1a 86       	std	Y+10, r1	; 0x0a
    3ee4:	8c 91       	ld	r24, X
    3ee6:	81 50       	subi	r24, 0x01	; 1
    3ee8:	8c 93       	st	X, r24
                    prvAddTaskToReadyList( pxTCB );
    3eea:	9e 89       	ldd	r25, Y+22	; 0x16
    3eec:	80 91 c2 07 	lds	r24, 0x07C2
    3ef0:	89 17       	cp	r24, r25
    3ef2:	10 f4       	brcc	.+4      	; 0x3ef8 <xTaskResumeAll+0xd2>
    3ef4:	90 93 c2 07 	sts	0x07C2, r25
    3ef8:	89 2f       	mov	r24, r25
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	fc 01       	movw	r30, r24
    3efe:	23 e0       	ldi	r18, 0x03	; 3
    3f00:	ee 0f       	add	r30, r30
    3f02:	ff 1f       	adc	r31, r31
    3f04:	2a 95       	dec	r18
    3f06:	e1 f7       	brne	.-8      	; 0x3f00 <xTaskResumeAll+0xda>
    3f08:	e8 0f       	add	r30, r24
    3f0a:	f9 1f       	adc	r31, r25
    3f0c:	ef 52       	subi	r30, 0x2F	; 47
    3f0e:	f8 4f       	sbci	r31, 0xF8	; 248
    3f10:	a1 81       	ldd	r26, Z+1	; 0x01
    3f12:	b2 81       	ldd	r27, Z+2	; 0x02
    3f14:	bd 83       	std	Y+5, r27	; 0x05
    3f16:	ac 83       	std	Y+4, r26	; 0x04
    3f18:	14 96       	adiw	r26, 0x04	; 4
    3f1a:	8d 91       	ld	r24, X+
    3f1c:	9c 91       	ld	r25, X
    3f1e:	15 97       	sbiw	r26, 0x05	; 5
    3f20:	9f 83       	std	Y+7, r25	; 0x07
    3f22:	8e 83       	std	Y+6, r24	; 0x06
    3f24:	14 96       	adiw	r26, 0x04	; 4
    3f26:	ed 91       	ld	r30, X+
    3f28:	fc 91       	ld	r31, X
    3f2a:	15 97       	sbiw	r26, 0x05	; 5
    3f2c:	53 83       	std	Z+3, r21	; 0x03
    3f2e:	42 83       	std	Z+2, r20	; 0x02
    3f30:	15 96       	adiw	r26, 0x05	; 5
    3f32:	5c 93       	st	X, r21
    3f34:	4e 93       	st	-X, r20
    3f36:	14 97       	sbiw	r26, 0x04	; 4
    3f38:	ee 89       	ldd	r30, Y+22	; 0x16
    3f3a:	e7 9f       	mul	r30, r23
    3f3c:	f0 01       	movw	r30, r0
    3f3e:	11 24       	eor	r1, r1
    3f40:	ef 52       	subi	r30, 0x2F	; 47
    3f42:	f8 4f       	sbci	r31, 0xF8	; 248
    3f44:	fb 87       	std	Y+11, r31	; 0x0b
    3f46:	ea 87       	std	Y+10, r30	; 0x0a
    3f48:	80 81       	ld	r24, Z
    3f4a:	8f 5f       	subi	r24, 0xFF	; 255
    3f4c:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3f4e:	e0 91 bf 07 	lds	r30, 0x07BF
    3f52:	f0 91 c0 07 	lds	r31, 0x07C0
    3f56:	9e 89       	ldd	r25, Y+22	; 0x16
    3f58:	86 89       	ldd	r24, Z+22	; 0x16
    3f5a:	98 17       	cp	r25, r24
    3f5c:	10 f0       	brcs	.+4      	; 0x3f62 <xTaskResumeAll+0x13c>
                    {
                        xYieldPending = pdTRUE;
    3f5e:	60 93 c3 07 	sts	0x07C3, r22
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    3f62:	80 91 1d 08 	lds	r24, 0x081D
    3f66:	88 23       	and	r24, r24
    3f68:	09 f0       	breq	.+2      	; 0x3f6c <xTaskResumeAll+0x146>
    3f6a:	77 cf       	rjmp	.-274    	; 0x3e5a <xTaskResumeAll+0x34>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    3f6c:	cd 2b       	or	r28, r29
    3f6e:	b9 f0       	breq	.+46     	; 0x3f9e <xTaskResumeAll+0x178>
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3f70:	e0 91 19 08 	lds	r30, 0x0819
    3f74:	f0 91 1a 08 	lds	r31, 0x081A
    3f78:	80 81       	ld	r24, Z
    3f7a:	88 23       	and	r24, r24
    3f7c:	19 f4       	brne	.+6      	; 0x3f84 <xTaskResumeAll+0x15e>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    3f7e:	8f ef       	ldi	r24, 0xFF	; 255
    3f80:	9f ef       	ldi	r25, 0xFF	; 255
    3f82:	09 c0       	rjmp	.+18     	; 0x3f96 <xTaskResumeAll+0x170>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    3f84:	e0 91 19 08 	lds	r30, 0x0819
    3f88:	f0 91 1a 08 	lds	r31, 0x081A
    3f8c:	05 80       	ldd	r0, Z+5	; 0x05
    3f8e:	f6 81       	ldd	r31, Z+6	; 0x06
    3f90:	e0 2d       	mov	r30, r0
    3f92:	80 81       	ld	r24, Z
    3f94:	91 81       	ldd	r25, Z+1	; 0x01
    3f96:	90 93 c7 07 	sts	0x07C7, r25
    3f9a:	80 93 c6 07 	sts	0x07C6, r24
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3f9e:	c0 91 c9 07 	lds	r28, 0x07C9
    3fa2:	d0 91 ca 07 	lds	r29, 0x07CA

                    if( xPendedCounts > ( TickType_t ) 0U )
    3fa6:	20 97       	sbiw	r28, 0x00	; 0
    3fa8:	69 f0       	breq	.+26     	; 0x3fc4 <xTaskResumeAll+0x19e>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    3faa:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    3fac:	0e 94 3c 19 	call	0x3278	; 0x3278 <xTaskIncrementTick>
    3fb0:	88 23       	and	r24, r24
    3fb2:	11 f0       	breq	.+4      	; 0x3fb8 <xTaskResumeAll+0x192>
                            {
                                xYieldPending = pdTRUE;
    3fb4:	10 93 c3 07 	sts	0x07C3, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    3fb8:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    3fba:	c1 f7       	brne	.-16     	; 0x3fac <xTaskResumeAll+0x186>

                        xPendedTicks = 0;
    3fbc:	10 92 ca 07 	sts	0x07CA, r1
    3fc0:	10 92 c9 07 	sts	0x07C9, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    3fc4:	80 91 c3 07 	lds	r24, 0x07C3
    3fc8:	88 23       	and	r24, r24
    3fca:	21 f0       	breq	.+8      	; 0x3fd4 <xTaskResumeAll+0x1ae>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    3fcc:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    3fd0:	81 e0       	ldi	r24, 0x01	; 1
    3fd2:	01 c0       	rjmp	.+2      	; 0x3fd6 <xTaskResumeAll+0x1b0>
    3fd4:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    3fd6:	0f 90       	pop	r0
    3fd8:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    3fda:	df 91       	pop	r29
    3fdc:	cf 91       	pop	r28
    3fde:	1f 91       	pop	r17
    3fe0:	08 95       	ret

00003fe2 <xTaskCatchUpTicks>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    3fe2:	20 91 c1 07 	lds	r18, 0x07C1
    3fe6:	2f 5f       	subi	r18, 0xFF	; 255
    3fe8:	20 93 c1 07 	sts	0x07C1, r18
    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    3fec:	0f b6       	in	r0, 0x3f	; 63
    3fee:	f8 94       	cli
    3ff0:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    3ff2:	20 91 c9 07 	lds	r18, 0x07C9
    3ff6:	30 91 ca 07 	lds	r19, 0x07CA
    3ffa:	28 0f       	add	r18, r24
    3ffc:	39 1f       	adc	r19, r25
    3ffe:	30 93 ca 07 	sts	0x07CA, r19
    4002:	20 93 c9 07 	sts	0x07C9, r18
    }
    taskEXIT_CRITICAL();
    4006:	0f 90       	pop	r0
    4008:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    400a:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

    return xYieldOccurred;
}
    400e:	08 95       	ret

00004010 <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    4010:	0f 93       	push	r16
    4012:	1f 93       	push	r17
    4014:	cf 93       	push	r28
    4016:	df 93       	push	r29
    4018:	ec 01       	movw	r28, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    401a:	00 91 c4 07 	lds	r16, 0x07C4
    401e:	10 91 c5 07 	lds	r17, 0x07C5
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4022:	80 91 bf 07 	lds	r24, 0x07BF
    4026:	90 91 c0 07 	lds	r25, 0x07C0
    402a:	02 96       	adiw	r24, 0x02	; 2
    402c:	0e 94 af 0c 	call	0x195e	; 0x195e <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    4030:	c0 0f       	add	r28, r16
    4032:	d1 1f       	adc	r29, r17

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4034:	e0 91 bf 07 	lds	r30, 0x07BF
    4038:	f0 91 c0 07 	lds	r31, 0x07C0
    403c:	d3 83       	std	Z+3, r29	; 0x03
    403e:	c2 83       	std	Z+2, r28	; 0x02

        if( xTimeToWake < xConstTickCount )
    4040:	c0 17       	cp	r28, r16
    4042:	d1 07       	cpc	r29, r17
    4044:	68 f4       	brcc	.+26     	; 0x4060 <prvAddCurrentTaskToDelayedList+0x50>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4046:	80 91 1b 08 	lds	r24, 0x081B
    404a:	90 91 1c 08 	lds	r25, 0x081C
    404e:	60 91 bf 07 	lds	r22, 0x07BF
    4052:	70 91 c0 07 	lds	r23, 0x07C0
    4056:	6e 5f       	subi	r22, 0xFE	; 254
    4058:	7f 4f       	sbci	r23, 0xFF	; 255
    405a:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <vListInsert>
    405e:	17 c0       	rjmp	.+46     	; 0x408e <prvAddCurrentTaskToDelayedList+0x7e>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4060:	80 91 19 08 	lds	r24, 0x0819
    4064:	90 91 1a 08 	lds	r25, 0x081A
    4068:	60 91 bf 07 	lds	r22, 0x07BF
    406c:	70 91 c0 07 	lds	r23, 0x07C0
    4070:	6e 5f       	subi	r22, 0xFE	; 254
    4072:	7f 4f       	sbci	r23, 0xFF	; 255
    4074:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    4078:	80 91 c6 07 	lds	r24, 0x07C6
    407c:	90 91 c7 07 	lds	r25, 0x07C7
    4080:	c8 17       	cp	r28, r24
    4082:	d9 07       	cpc	r29, r25
    4084:	20 f4       	brcc	.+8      	; 0x408e <prvAddCurrentTaskToDelayedList+0x7e>
            {
                xNextTaskUnblockTime = xTimeToWake;
    4086:	d0 93 c7 07 	sts	0x07C7, r29
    408a:	c0 93 c6 07 	sts	0x07C6, r28

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    408e:	df 91       	pop	r29
    4090:	cf 91       	pop	r28
    4092:	1f 91       	pop	r17
    4094:	0f 91       	pop	r16
    4096:	08 95       	ret

00004098 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    4098:	8f 92       	push	r8
    409a:	9f 92       	push	r9
    409c:	af 92       	push	r10
    409e:	bf 92       	push	r11
    40a0:	cf 92       	push	r12
    40a2:	df 92       	push	r13
    40a4:	ef 92       	push	r14
    40a6:	ff 92       	push	r15
    40a8:	0f 93       	push	r16
    40aa:	1f 93       	push	r17
    40ac:	cf 93       	push	r28
    40ae:	df 93       	push	r29
    40b0:	48 01       	movw	r8, r16
    40b2:	59 01       	movw	r10, r18
    40b4:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    40b6:	0f b6       	in	r0, 0x3f	; 63
    40b8:	f8 94       	cli
    40ba:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    40bc:	e0 91 bf 07 	lds	r30, 0x07BF
    40c0:	f0 91 c0 07 	lds	r31, 0x07C0
    40c4:	e8 2e       	mov	r14, r24
    40c6:	ff 24       	eor	r15, r15
    40c8:	ee 0d       	add	r30, r14
    40ca:	ff 1d       	adc	r31, r15
    40cc:	85 a1       	ldd	r24, Z+37	; 0x25
    40ce:	82 30       	cpi	r24, 0x02	; 2
    40d0:	61 f1       	breq	.+88     	; 0x412a <xTaskGenericNotifyWait+0x92>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    40d2:	e0 91 bf 07 	lds	r30, 0x07BF
    40d6:	f0 91 c0 07 	lds	r31, 0x07C0
    40da:	c7 01       	movw	r24, r14
    40dc:	88 0f       	add	r24, r24
    40de:	99 1f       	adc	r25, r25
    40e0:	88 0f       	add	r24, r24
    40e2:	99 1f       	adc	r25, r25
    40e4:	e8 0f       	add	r30, r24
    40e6:	f9 1f       	adc	r31, r25
    40e8:	81 a1       	ldd	r24, Z+33	; 0x21
    40ea:	92 a1       	ldd	r25, Z+34	; 0x22
    40ec:	a3 a1       	ldd	r26, Z+35	; 0x23
    40ee:	b4 a1       	ldd	r27, Z+36	; 0x24
    40f0:	40 95       	com	r20
    40f2:	50 95       	com	r21
    40f4:	60 95       	com	r22
    40f6:	70 95       	com	r23
    40f8:	84 23       	and	r24, r20
    40fa:	95 23       	and	r25, r21
    40fc:	a6 23       	and	r26, r22
    40fe:	b7 23       	and	r27, r23
    4100:	81 a3       	std	Z+33, r24	; 0x21
    4102:	92 a3       	std	Z+34, r25	; 0x22
    4104:	a3 a3       	std	Z+35, r26	; 0x23
    4106:	b4 a3       	std	Z+36, r27	; 0x24

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4108:	e0 91 bf 07 	lds	r30, 0x07BF
    410c:	f0 91 c0 07 	lds	r31, 0x07C0
    4110:	ee 0d       	add	r30, r14
    4112:	ff 1d       	adc	r31, r15
    4114:	81 e0       	ldi	r24, 0x01	; 1
    4116:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    4118:	c1 14       	cp	r12, r1
    411a:	d1 04       	cpc	r13, r1
    411c:	31 f0       	breq	.+12     	; 0x412a <xTaskGenericNotifyWait+0x92>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    411e:	c6 01       	movw	r24, r12
    4120:	61 e0       	ldi	r22, 0x01	; 1
    4122:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    4126:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    412a:	0f 90       	pop	r0
    412c:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	f8 94       	cli
    4132:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    4134:	20 97       	sbiw	r28, 0x00	; 0
    4136:	99 f0       	breq	.+38     	; 0x415e <xTaskGenericNotifyWait+0xc6>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    4138:	e0 91 bf 07 	lds	r30, 0x07BF
    413c:	f0 91 c0 07 	lds	r31, 0x07C0
    4140:	c7 01       	movw	r24, r14
    4142:	88 0f       	add	r24, r24
    4144:	99 1f       	adc	r25, r25
    4146:	88 0f       	add	r24, r24
    4148:	99 1f       	adc	r25, r25
    414a:	e8 0f       	add	r30, r24
    414c:	f9 1f       	adc	r31, r25
    414e:	81 a1       	ldd	r24, Z+33	; 0x21
    4150:	92 a1       	ldd	r25, Z+34	; 0x22
    4152:	a3 a1       	ldd	r26, Z+35	; 0x23
    4154:	b4 a1       	ldd	r27, Z+36	; 0x24
    4156:	88 83       	st	Y, r24
    4158:	99 83       	std	Y+1, r25	; 0x01
    415a:	aa 83       	std	Y+2, r26	; 0x02
    415c:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    415e:	e0 91 bf 07 	lds	r30, 0x07BF
    4162:	f0 91 c0 07 	lds	r31, 0x07C0
    4166:	ee 0d       	add	r30, r14
    4168:	ff 1d       	adc	r31, r15
    416a:	85 a1       	ldd	r24, Z+37	; 0x25
    416c:	82 30       	cpi	r24, 0x02	; 2
    416e:	11 f0       	breq	.+4      	; 0x4174 <xTaskGenericNotifyWait+0xdc>
    4170:	80 e0       	ldi	r24, 0x00	; 0
    4172:	1c c0       	rjmp	.+56     	; 0x41ac <xTaskGenericNotifyWait+0x114>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    4174:	e0 91 bf 07 	lds	r30, 0x07BF
    4178:	f0 91 c0 07 	lds	r31, 0x07C0
    417c:	c7 01       	movw	r24, r14
    417e:	88 0f       	add	r24, r24
    4180:	99 1f       	adc	r25, r25
    4182:	88 0f       	add	r24, r24
    4184:	99 1f       	adc	r25, r25
    4186:	e8 0f       	add	r30, r24
    4188:	f9 1f       	adc	r31, r25
    418a:	81 a1       	ldd	r24, Z+33	; 0x21
    418c:	92 a1       	ldd	r25, Z+34	; 0x22
    418e:	a3 a1       	ldd	r26, Z+35	; 0x23
    4190:	b4 a1       	ldd	r27, Z+36	; 0x24
    4192:	80 94       	com	r8
    4194:	90 94       	com	r9
    4196:	a0 94       	com	r10
    4198:	b0 94       	com	r11
    419a:	88 21       	and	r24, r8
    419c:	99 21       	and	r25, r9
    419e:	aa 21       	and	r26, r10
    41a0:	bb 21       	and	r27, r11
    41a2:	81 a3       	std	Z+33, r24	; 0x21
    41a4:	92 a3       	std	Z+34, r25	; 0x22
    41a6:	a3 a3       	std	Z+35, r26	; 0x23
    41a8:	b4 a3       	std	Z+36, r27	; 0x24
    41aa:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    41ac:	e0 91 bf 07 	lds	r30, 0x07BF
    41b0:	f0 91 c0 07 	lds	r31, 0x07C0
    41b4:	ee 0d       	add	r30, r14
    41b6:	ff 1d       	adc	r31, r15
    41b8:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    41ba:	0f 90       	pop	r0
    41bc:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    41be:	df 91       	pop	r29
    41c0:	cf 91       	pop	r28
    41c2:	1f 91       	pop	r17
    41c4:	0f 91       	pop	r16
    41c6:	ff 90       	pop	r15
    41c8:	ef 90       	pop	r14
    41ca:	df 90       	pop	r13
    41cc:	cf 90       	pop	r12
    41ce:	bf 90       	pop	r11
    41d0:	af 90       	pop	r10
    41d2:	9f 90       	pop	r9
    41d4:	8f 90       	pop	r8
    41d6:	08 95       	ret

000041d8 <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    41d8:	1f 93       	push	r17
    41da:	cf 93       	push	r28
    41dc:	df 93       	push	r29
    41de:	16 2f       	mov	r17, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    41e0:	0f b6       	in	r0, 0x3f	; 63
    41e2:	f8 94       	cli
    41e4:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    41e6:	e0 91 bf 07 	lds	r30, 0x07BF
    41ea:	f0 91 c0 07 	lds	r31, 0x07C0
    41ee:	c8 2f       	mov	r28, r24
    41f0:	d0 e0       	ldi	r29, 0x00	; 0
    41f2:	ce 01       	movw	r24, r28
    41f4:	88 0f       	add	r24, r24
    41f6:	99 1f       	adc	r25, r25
    41f8:	88 0f       	add	r24, r24
    41fa:	99 1f       	adc	r25, r25
    41fc:	e8 0f       	add	r30, r24
    41fe:	f9 1f       	adc	r31, r25
    4200:	81 a1       	ldd	r24, Z+33	; 0x21
    4202:	92 a1       	ldd	r25, Z+34	; 0x22
    4204:	a3 a1       	ldd	r26, Z+35	; 0x23
    4206:	b4 a1       	ldd	r27, Z+36	; 0x24
    4208:	00 97       	sbiw	r24, 0x00	; 0
    420a:	a1 05       	cpc	r26, r1
    420c:	b1 05       	cpc	r27, r1
    420e:	89 f4       	brne	.+34     	; 0x4232 <ulTaskGenericNotifyTake+0x5a>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    4210:	e0 91 bf 07 	lds	r30, 0x07BF
    4214:	f0 91 c0 07 	lds	r31, 0x07C0
    4218:	ec 0f       	add	r30, r28
    421a:	fd 1f       	adc	r31, r29
    421c:	81 e0       	ldi	r24, 0x01	; 1
    421e:	85 a3       	std	Z+37, r24	; 0x25

                if( xTicksToWait > ( TickType_t ) 0 )
    4220:	41 15       	cp	r20, r1
    4222:	51 05       	cpc	r21, r1
    4224:	31 f0       	breq	.+12     	; 0x4232 <ulTaskGenericNotifyTake+0x5a>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    4226:	ca 01       	movw	r24, r20
    4228:	61 e0       	ldi	r22, 0x01	; 1
    422a:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    422e:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4232:	0f 90       	pop	r0
    4234:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    4236:	0f b6       	in	r0, 0x3f	; 63
    4238:	f8 94       	cli
    423a:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    423c:	e0 91 bf 07 	lds	r30, 0x07BF
    4240:	f0 91 c0 07 	lds	r31, 0x07C0
    4244:	ce 01       	movw	r24, r28
    4246:	88 0f       	add	r24, r24
    4248:	99 1f       	adc	r25, r25
    424a:	88 0f       	add	r24, r24
    424c:	99 1f       	adc	r25, r25
    424e:	e8 0f       	add	r30, r24
    4250:	f9 1f       	adc	r31, r25
    4252:	21 a1       	ldd	r18, Z+33	; 0x21
    4254:	32 a1       	ldd	r19, Z+34	; 0x22
    4256:	43 a1       	ldd	r20, Z+35	; 0x23
    4258:	54 a1       	ldd	r21, Z+36	; 0x24

            if( ulReturn != 0UL )
    425a:	21 15       	cp	r18, r1
    425c:	31 05       	cpc	r19, r1
    425e:	41 05       	cpc	r20, r1
    4260:	51 05       	cpc	r21, r1
    4262:	f9 f0       	breq	.+62     	; 0x42a2 <ulTaskGenericNotifyTake+0xca>
            {
                if( xClearCountOnExit != pdFALSE )
    4264:	11 23       	and	r17, r17
    4266:	59 f0       	breq	.+22     	; 0x427e <ulTaskGenericNotifyTake+0xa6>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    4268:	e0 91 bf 07 	lds	r30, 0x07BF
    426c:	f0 91 c0 07 	lds	r31, 0x07C0
    4270:	e8 0f       	add	r30, r24
    4272:	f9 1f       	adc	r31, r25
    4274:	11 a2       	std	Z+33, r1	; 0x21
    4276:	12 a2       	std	Z+34, r1	; 0x22
    4278:	13 a2       	std	Z+35, r1	; 0x23
    427a:	14 a2       	std	Z+36, r1	; 0x24
    427c:	12 c0       	rjmp	.+36     	; 0x42a2 <ulTaskGenericNotifyTake+0xca>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    427e:	e0 91 bf 07 	lds	r30, 0x07BF
    4282:	f0 91 c0 07 	lds	r31, 0x07C0
    4286:	21 50       	subi	r18, 0x01	; 1
    4288:	30 40       	sbci	r19, 0x00	; 0
    428a:	40 40       	sbci	r20, 0x00	; 0
    428c:	50 40       	sbci	r21, 0x00	; 0
    428e:	e8 0f       	add	r30, r24
    4290:	f9 1f       	adc	r31, r25
    4292:	21 a3       	std	Z+33, r18	; 0x21
    4294:	32 a3       	std	Z+34, r19	; 0x22
    4296:	43 a3       	std	Z+35, r20	; 0x23
    4298:	54 a3       	std	Z+36, r21	; 0x24
    429a:	2f 5f       	subi	r18, 0xFF	; 255
    429c:	3f 4f       	sbci	r19, 0xFF	; 255
    429e:	4f 4f       	sbci	r20, 0xFF	; 255
    42a0:	5f 4f       	sbci	r21, 0xFF	; 255
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    42a2:	e0 91 bf 07 	lds	r30, 0x07BF
    42a6:	f0 91 c0 07 	lds	r31, 0x07C0
    42aa:	ec 0f       	add	r30, r28
    42ac:	fd 1f       	adc	r31, r29
    42ae:	15 a2       	std	Z+37, r1	; 0x25
        }
        taskEXIT_CRITICAL();
    42b0:	0f 90       	pop	r0
    42b2:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    42b4:	b9 01       	movw	r22, r18
    42b6:	ca 01       	movw	r24, r20
    42b8:	df 91       	pop	r29
    42ba:	cf 91       	pop	r28
    42bc:	1f 91       	pop	r17
    42be:	08 95       	ret

000042c0 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    42c0:	0f 93       	push	r16
    42c2:	1f 93       	push	r17
    42c4:	8c 01       	movw	r16, r24
    42c6:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    42c8:	e0 91 bf 07 	lds	r30, 0x07BF
    42cc:	f0 91 c0 07 	lds	r31, 0x07C0
    42d0:	70 68       	ori	r23, 0x80	; 128
    42d2:	75 87       	std	Z+13, r23	; 0x0d
    42d4:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    42d6:	f8 01       	movw	r30, r16
    42d8:	a1 81       	ldd	r26, Z+1	; 0x01
    42da:	b2 81       	ldd	r27, Z+2	; 0x02
    42dc:	e0 91 bf 07 	lds	r30, 0x07BF
    42e0:	f0 91 c0 07 	lds	r31, 0x07C0
    42e4:	b7 87       	std	Z+15, r27	; 0x0f
    42e6:	a6 87       	std	Z+14, r26	; 0x0e
    42e8:	e0 91 bf 07 	lds	r30, 0x07BF
    42ec:	f0 91 c0 07 	lds	r31, 0x07C0
    42f0:	14 96       	adiw	r26, 0x04	; 4
    42f2:	2d 91       	ld	r18, X+
    42f4:	3c 91       	ld	r19, X
    42f6:	15 97       	sbiw	r26, 0x05	; 5
    42f8:	31 8b       	std	Z+17, r19	; 0x11
    42fa:	20 8b       	std	Z+16, r18	; 0x10
    42fc:	20 91 bf 07 	lds	r18, 0x07BF
    4300:	30 91 c0 07 	lds	r19, 0x07C0
    4304:	14 96       	adiw	r26, 0x04	; 4
    4306:	ed 91       	ld	r30, X+
    4308:	fc 91       	ld	r31, X
    430a:	15 97       	sbiw	r26, 0x05	; 5
    430c:	24 5f       	subi	r18, 0xF4	; 244
    430e:	3f 4f       	sbci	r19, 0xFF	; 255
    4310:	33 83       	std	Z+3, r19	; 0x03
    4312:	22 83       	std	Z+2, r18	; 0x02
    4314:	20 91 bf 07 	lds	r18, 0x07BF
    4318:	30 91 c0 07 	lds	r19, 0x07C0
    431c:	24 5f       	subi	r18, 0xF4	; 244
    431e:	3f 4f       	sbci	r19, 0xFF	; 255
    4320:	15 96       	adiw	r26, 0x05	; 5
    4322:	3c 93       	st	X, r19
    4324:	2e 93       	st	-X, r18
    4326:	14 97       	sbiw	r26, 0x04	; 4
    4328:	e0 91 bf 07 	lds	r30, 0x07BF
    432c:	f0 91 c0 07 	lds	r31, 0x07C0
    4330:	15 8b       	std	Z+21, r17	; 0x15
    4332:	04 8b       	std	Z+20, r16	; 0x14
    4334:	f8 01       	movw	r30, r16
    4336:	20 81       	ld	r18, Z
    4338:	2f 5f       	subi	r18, 0xFF	; 255
    433a:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    433c:	61 e0       	ldi	r22, 0x01	; 1
    433e:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>
}
    4342:	1f 91       	pop	r17
    4344:	0f 91       	pop	r16
    4346:	08 95       	ret

00004348 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    4348:	9c 01       	movw	r18, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    434a:	00 97       	sbiw	r24, 0x00	; 0
    434c:	69 f0       	breq	.+26     	; 0x4368 <vTaskDelay+0x20>
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    434e:	80 91 c1 07 	lds	r24, 0x07C1
    4352:	8f 5f       	subi	r24, 0xFF	; 255
    4354:	80 93 c1 07 	sts	0x07C1, r24
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    4358:	c9 01       	movw	r24, r18
    435a:	60 e0       	ldi	r22, 0x00	; 0
    435c:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    4360:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    4364:	88 23       	and	r24, r24
    4366:	11 f4       	brne	.+4      	; 0x436c <vTaskDelay+0x24>
        {
            portYIELD_WITHIN_API();
    4368:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    436c:	08 95       	ret

0000436e <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    436e:	1f 93       	push	r17
    4370:	fc 01       	movw	r30, r24
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4372:	80 91 c1 07 	lds	r24, 0x07C1
    4376:	8f 5f       	subi	r24, 0xFF	; 255
    4378:	80 93 c1 07 	sts	0x07C1, r24

        vTaskSuspendAll();
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    437c:	80 91 c4 07 	lds	r24, 0x07C4
    4380:	90 91 c5 07 	lds	r25, 0x07C5

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4384:	20 81       	ld	r18, Z
    4386:	31 81       	ldd	r19, Z+1	; 0x01
    4388:	62 0f       	add	r22, r18
    438a:	73 1f       	adc	r23, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    438c:	82 17       	cp	r24, r18
    438e:	93 07       	cpc	r25, r19
    4390:	28 f4       	brcc	.+10     	; 0x439c <xTaskDelayUntil+0x2e>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    4392:	62 17       	cp	r22, r18
    4394:	73 07       	cpc	r23, r19
    4396:	28 f0       	brcs	.+10     	; 0x43a2 <xTaskDelayUntil+0x34>
    4398:	10 e0       	ldi	r17, 0x00	; 0
    439a:	08 c0       	rjmp	.+16     	; 0x43ac <xTaskDelayUntil+0x3e>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    439c:	62 17       	cp	r22, r18
    439e:	73 07       	cpc	r23, r19
    43a0:	20 f0       	brcs	.+8      	; 0x43aa <xTaskDelayUntil+0x3c>
    43a2:	10 e0       	ldi	r17, 0x00	; 0
    43a4:	86 17       	cp	r24, r22
    43a6:	97 07       	cpc	r25, r23
    43a8:	08 f4       	brcc	.+2      	; 0x43ac <xTaskDelayUntil+0x3e>
    43aa:	11 e0       	ldi	r17, 0x01	; 1
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    43ac:	71 83       	std	Z+1, r23	; 0x01
    43ae:	60 83       	st	Z, r22

            if( xShouldDelay != pdFALSE )
    43b0:	11 23       	and	r17, r17
    43b2:	39 f0       	breq	.+14     	; 0x43c2 <xTaskDelayUntil+0x54>
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    43b4:	9b 01       	movw	r18, r22
    43b6:	28 1b       	sub	r18, r24
    43b8:	39 0b       	sbc	r19, r25
    43ba:	c9 01       	movw	r24, r18
    43bc:	60 e0       	ldi	r22, 0x00	; 0
    43be:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    43c2:	0e 94 13 1f 	call	0x3e26	; 0x3e26 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    43c6:	88 23       	and	r24, r24
    43c8:	11 f4       	brne	.+4      	; 0x43ce <xTaskDelayUntil+0x60>
        {
            portYIELD_WITHIN_API();
    43ca:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    43ce:	81 2f       	mov	r24, r17
    43d0:	1f 91       	pop	r17
    43d2:	08 95       	ret

000043d4 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    43d4:	0f 93       	push	r16
    43d6:	1f 93       	push	r17
    43d8:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    43da:	60 91 bf 07 	lds	r22, 0x07BF
    43de:	70 91 c0 07 	lds	r23, 0x07C0
    43e2:	64 5f       	subi	r22, 0xF4	; 244
    43e4:	7f 4f       	sbci	r23, 0xFF	; 255
    43e6:	0e 94 7d 0c 	call	0x18fa	; 0x18fa <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    43ea:	c8 01       	movw	r24, r16
    43ec:	61 e0       	ldi	r22, 0x01	; 1
    43ee:	0e 94 08 20 	call	0x4010	; 0x4010 <prvAddCurrentTaskToDelayedList>
}
    43f2:	1f 91       	pop	r17
    43f4:	0f 91       	pop	r16
    43f6:	08 95       	ret

000043f8 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    43f8:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    43fa:	10 92 cc 07 	sts	0x07CC, r1
    vPortEndScheduler();
    43fe:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <vPortEndScheduler>
}
    4402:	08 95       	ret

00004404 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4404:	0f 93       	push	r16
    4406:	1f 93       	push	r17
    4408:	21 c0       	rjmp	.+66     	; 0x444c <prvIdleTask+0x48>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    440a:	0f b6       	in	r0, 0x3f	; 63
    440c:	f8 94       	cli
    440e:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4410:	e0 91 2b 08 	lds	r30, 0x082B
    4414:	f0 91 2c 08 	lds	r31, 0x082C
    4418:	06 81       	ldd	r16, Z+6	; 0x06
    441a:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    441c:	c8 01       	movw	r24, r16
    441e:	02 96       	adiw	r24, 0x02	; 2
    4420:	0e 94 af 0c 	call	0x195e	; 0x195e <uxListRemove>
                --uxCurrentNumberOfTasks;
    4424:	80 91 cb 07 	lds	r24, 0x07CB
    4428:	81 50       	subi	r24, 0x01	; 1
    442a:	80 93 cb 07 	sts	0x07CB, r24
                --uxDeletedTasksWaitingCleanUp;
    442e:	80 91 cf 07 	lds	r24, 0x07CF
    4432:	81 50       	subi	r24, 0x01	; 1
    4434:	80 93 cf 07 	sts	0x07CF, r24
            }
            taskEXIT_CRITICAL();
    4438:	0f 90       	pop	r0
    443a:	0f be       	out	0x3f, r0	; 63

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    443c:	f8 01       	movw	r30, r16
    443e:	87 89       	ldd	r24, Z+23	; 0x17
    4440:	90 8d       	ldd	r25, Z+24	; 0x18
    4442:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
            vPortFree( pxTCB );
    4446:	c8 01       	movw	r24, r16
    4448:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    444c:	80 91 cf 07 	lds	r24, 0x07CF
    4450:	88 23       	and	r24, r24
    4452:	d9 f6       	brne	.-74     	; 0x440a <prvIdleTask+0x6>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    4454:	80 91 d1 07 	lds	r24, 0x07D1
    4458:	82 30       	cpi	r24, 0x02	; 2
    445a:	c0 f3       	brcs	.-16     	; 0x444c <prvIdleTask+0x48>
            {
                taskYIELD();
    445c:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    4460:	f5 cf       	rjmp	.-22     	; 0x444c <prvIdleTask+0x48>

00004462 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    4462:	0f 93       	push	r16
    4464:	1f 93       	push	r17
    4466:	cf 93       	push	r28
    4468:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    446a:	0f b6       	in	r0, 0x3f	; 63
    446c:	f8 94       	cli
    446e:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4470:	00 97       	sbiw	r24, 0x00	; 0
    4472:	11 f0       	breq	.+4      	; 0x4478 <vTaskDelete+0x16>
    4474:	ec 01       	movw	r28, r24
    4476:	04 c0       	rjmp	.+8      	; 0x4480 <vTaskDelete+0x1e>
    4478:	c0 91 bf 07 	lds	r28, 0x07BF
    447c:	d0 91 c0 07 	lds	r29, 0x07C0

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4480:	8e 01       	movw	r16, r28
    4482:	0e 5f       	subi	r16, 0xFE	; 254
    4484:	1f 4f       	sbci	r17, 0xFF	; 255
    4486:	c8 01       	movw	r24, r16
    4488:	0e 94 af 0c 	call	0x195e	; 0x195e <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    448c:	8c 89       	ldd	r24, Y+20	; 0x14
    448e:	9d 89       	ldd	r25, Y+21	; 0x15
    4490:	89 2b       	or	r24, r25
    4492:	21 f0       	breq	.+8      	; 0x449c <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    4494:	ce 01       	movw	r24, r28
    4496:	0c 96       	adiw	r24, 0x0c	; 12
    4498:	0e 94 af 0c 	call	0x195e	; 0x195e <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    449c:	80 91 d0 07 	lds	r24, 0x07D0
    44a0:	8f 5f       	subi	r24, 0xFF	; 255
    44a2:	80 93 d0 07 	sts	0x07D0, r24

            if( pxTCB == pxCurrentTCB )
    44a6:	80 91 bf 07 	lds	r24, 0x07BF
    44aa:	90 91 c0 07 	lds	r25, 0x07C0
    44ae:	c8 17       	cp	r28, r24
    44b0:	d9 07       	cpc	r29, r25
    44b2:	59 f4       	brne	.+22     	; 0x44ca <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    44b4:	86 e2       	ldi	r24, 0x26	; 38
    44b6:	98 e0       	ldi	r25, 0x08	; 8
    44b8:	b8 01       	movw	r22, r16
    44ba:	0e 94 5e 0c 	call	0x18bc	; 0x18bc <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    44be:	80 91 cf 07 	lds	r24, 0x07CF
    44c2:	8f 5f       	subi	r24, 0xFF	; 255
    44c4:	80 93 cf 07 	sts	0x07CF, r24
    44c8:	1c c0       	rjmp	.+56     	; 0x4502 <vTaskDelete+0xa0>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    44ca:	80 91 cb 07 	lds	r24, 0x07CB
    44ce:	81 50       	subi	r24, 0x01	; 1
    44d0:	80 93 cb 07 	sts	0x07CB, r24
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    44d4:	e0 91 19 08 	lds	r30, 0x0819
    44d8:	f0 91 1a 08 	lds	r31, 0x081A
    44dc:	80 81       	ld	r24, Z
    44de:	88 23       	and	r24, r24
    44e0:	19 f4       	brne	.+6      	; 0x44e8 <vTaskDelete+0x86>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    44e2:	8f ef       	ldi	r24, 0xFF	; 255
    44e4:	9f ef       	ldi	r25, 0xFF	; 255
    44e6:	09 c0       	rjmp	.+18     	; 0x44fa <vTaskDelete+0x98>
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    44e8:	e0 91 19 08 	lds	r30, 0x0819
    44ec:	f0 91 1a 08 	lds	r31, 0x081A
    44f0:	05 80       	ldd	r0, Z+5	; 0x05
    44f2:	f6 81       	ldd	r31, Z+6	; 0x06
    44f4:	e0 2d       	mov	r30, r0
    44f6:	80 81       	ld	r24, Z
    44f8:	91 81       	ldd	r25, Z+1	; 0x01
    44fa:	90 93 c7 07 	sts	0x07C7, r25
    44fe:	80 93 c6 07 	sts	0x07C6, r24
                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
            }
        }
        taskEXIT_CRITICAL();
    4502:	0f 90       	pop	r0
    4504:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    4506:	80 91 bf 07 	lds	r24, 0x07BF
    450a:	90 91 c0 07 	lds	r25, 0x07C0
    450e:	c8 17       	cp	r28, r24
    4510:	d9 07       	cpc	r29, r25
    4512:	39 f0       	breq	.+14     	; 0x4522 <vTaskDelete+0xc0>

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    4514:	8f 89       	ldd	r24, Y+23	; 0x17
    4516:	98 8d       	ldd	r25, Y+24	; 0x18
    4518:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
            vPortFree( pxTCB );
    451c:	ce 01       	movw	r24, r28
    451e:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
            prvDeleteTCB( pxTCB );
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    4522:	80 91 cc 07 	lds	r24, 0x07CC
    4526:	88 23       	and	r24, r24
    4528:	49 f0       	breq	.+18     	; 0x453c <vTaskDelete+0xda>
        {
            if( pxTCB == pxCurrentTCB )
    452a:	80 91 bf 07 	lds	r24, 0x07BF
    452e:	90 91 c0 07 	lds	r25, 0x07C0
    4532:	c8 17       	cp	r28, r24
    4534:	d9 07       	cpc	r29, r25
    4536:	11 f4       	brne	.+4      	; 0x453c <vTaskDelete+0xda>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    4538:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    453c:	df 91       	pop	r29
    453e:	cf 91       	pop	r28
    4540:	1f 91       	pop	r17
    4542:	0f 91       	pop	r16
    4544:	08 95       	ret

00004546 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    4546:	4f 92       	push	r4
    4548:	5f 92       	push	r5
    454a:	6f 92       	push	r6
    454c:	7f 92       	push	r7
    454e:	8f 92       	push	r8
    4550:	9f 92       	push	r9
    4552:	af 92       	push	r10
    4554:	bf 92       	push	r11
    4556:	cf 92       	push	r12
    4558:	df 92       	push	r13
    455a:	ef 92       	push	r14
    455c:	ff 92       	push	r15
    455e:	0f 93       	push	r16
    4560:	1f 93       	push	r17
    4562:	cf 93       	push	r28
    4564:	df 93       	push	r29
    4566:	2c 01       	movw	r4, r24
    4568:	4b 01       	movw	r8, r22
    456a:	5a 01       	movw	r10, r20
    456c:	39 01       	movw	r6, r18
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    456e:	ca 01       	movw	r24, r20
    4570:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    4574:	ec 01       	movw	r28, r24

            if( pxStack != NULL )
    4576:	00 97       	sbiw	r24, 0x00	; 0
    4578:	b1 f0       	breq	.+44     	; 0x45a6 <xTaskCreate+0x60>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    457a:	86 e2       	ldi	r24, 0x26	; 38
    457c:	90 e0       	ldi	r25, 0x00	; 0
    457e:	0e 94 71 0b 	call	0x16e2	; 0x16e2 <pvPortMalloc>
    4582:	6c 01       	movw	r12, r24

                if( pxNewTCB != NULL )
    4584:	00 97       	sbiw	r24, 0x00	; 0
    4586:	61 f0       	breq	.+24     	; 0x45a0 <xTaskCreate+0x5a>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    4588:	86 e2       	ldi	r24, 0x26	; 38
    458a:	d6 01       	movw	r26, r12
    458c:	1d 92       	st	X+, r1
    458e:	8a 95       	dec	r24
    4590:	e9 f7       	brne	.-6      	; 0x458c <xTaskCreate+0x46>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    4592:	f6 01       	movw	r30, r12
    4594:	d0 8f       	std	Z+24, r29	; 0x18
    4596:	c7 8b       	std	Z+23, r28	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    4598:	81 14       	cp	r8, r1
    459a:	91 04       	cpc	r9, r1
    459c:	31 f4       	brne	.+12     	; 0x45aa <xTaskCreate+0x64>
    459e:	17 c0       	rjmp	.+46     	; 0x45ce <xTaskCreate+0x88>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    45a0:	ce 01       	movw	r24, r28
    45a2:	0e 94 36 0b 	call	0x166c	; 0x166c <vPortFree>
    45a6:	8f ef       	ldi	r24, 0xFF	; 255
    45a8:	e7 c0       	rjmp	.+462    	; 0x4778 <xTaskCreate+0x232>
    45aa:	f4 01       	movw	r30, r8
    45ac:	d6 01       	movw	r26, r12
    45ae:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    45b0:	80 81       	ld	r24, Z
    45b2:	59 96       	adiw	r26, 0x19	; 25
    45b4:	8c 93       	st	X, r24
    45b6:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    45b8:	80 81       	ld	r24, Z
    45ba:	88 23       	and	r24, r24
    45bc:	29 f0       	breq	.+10     	; 0x45c8 <xTaskCreate+0x82>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    45be:	9f 5f       	subi	r25, 0xFF	; 255
    45c0:	31 96       	adiw	r30, 0x01	; 1
    45c2:	11 96       	adiw	r26, 0x01	; 1
    45c4:	98 30       	cpi	r25, 0x08	; 8
    45c6:	a1 f7       	brne	.-24     	; 0x45b0 <xTaskCreate+0x6a>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    45c8:	d6 01       	movw	r26, r12
    45ca:	90 96       	adiw	r26, 0x20	; 32
    45cc:	1c 92       	st	X, r1
    45ce:	06 30       	cpi	r16, 0x06	; 6
    45d0:	08 f0       	brcs	.+2      	; 0x45d4 <xTaskCreate+0x8e>
    45d2:	05 e0       	ldi	r16, 0x05	; 5
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    45d4:	f6 01       	movw	r30, r12
    45d6:	06 8b       	std	Z+22, r16	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    45d8:	52 e0       	ldi	r21, 0x02	; 2
    45da:	85 2e       	mov	r8, r21
    45dc:	91 2c       	mov	r9, r1
    45de:	8c 0c       	add	r8, r12
    45e0:	9d 1c       	adc	r9, r13
    45e2:	c4 01       	movw	r24, r8
    45e4:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    45e8:	c6 01       	movw	r24, r12
    45ea:	0c 96       	adiw	r24, 0x0c	; 12
    45ec:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    45f0:	d6 01       	movw	r26, r12
    45f2:	19 96       	adiw	r26, 0x09	; 9
    45f4:	dc 92       	st	X, r13
    45f6:	ce 92       	st	-X, r12
    45f8:	18 97       	sbiw	r26, 0x08	; 8

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    45fa:	86 e0       	ldi	r24, 0x06	; 6
    45fc:	90 e0       	ldi	r25, 0x00	; 0
    45fe:	80 1b       	sub	r24, r16
    4600:	91 09       	sbc	r25, r1
    4602:	1d 96       	adiw	r26, 0x0d	; 13
    4604:	9c 93       	st	X, r25
    4606:	8e 93       	st	-X, r24
    4608:	1c 97       	sbiw	r26, 0x0c	; 12
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    460a:	53 96       	adiw	r26, 0x13	; 19
    460c:	dc 92       	st	X, r13
    460e:	ce 92       	st	-X, r12
    4610:	52 97       	sbiw	r26, 0x12	; 18
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4612:	08 94       	sec
    4614:	a1 08       	sbc	r10, r1
    4616:	b1 08       	sbc	r11, r1
    4618:	ce 01       	movw	r24, r28
    461a:	8a 0d       	add	r24, r10
    461c:	9b 1d       	adc	r25, r11
    461e:	b2 01       	movw	r22, r4
    4620:	a3 01       	movw	r20, r6
    4622:	0e 94 b2 0e 	call	0x1d64	; 0x1d64 <pxPortInitialiseStack>
    4626:	f6 01       	movw	r30, r12
    4628:	91 83       	std	Z+1, r25	; 0x01
    462a:	80 83       	st	Z, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    462c:	e1 14       	cp	r14, r1
    462e:	f1 04       	cpc	r15, r1
    4630:	19 f0       	breq	.+6      	; 0x4638 <xTaskCreate+0xf2>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    4632:	d7 01       	movw	r26, r14
    4634:	cd 92       	st	X+, r12
    4636:	dc 92       	st	X, r13

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    4638:	0f b6       	in	r0, 0x3f	; 63
    463a:	f8 94       	cli
    463c:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    463e:	80 91 cb 07 	lds	r24, 0x07CB
    4642:	8f 5f       	subi	r24, 0xFF	; 255
    4644:	80 93 cb 07 	sts	0x07CB, r24

        if( pxCurrentTCB == NULL )
    4648:	80 91 bf 07 	lds	r24, 0x07BF
    464c:	90 91 c0 07 	lds	r25, 0x07C0
    4650:	89 2b       	or	r24, r25
    4652:	79 f5       	brne	.+94     	; 0x46b2 <xTaskCreate+0x16c>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    4654:	d0 92 c0 07 	sts	0x07C0, r13
    4658:	c0 92 bf 07 	sts	0x07BF, r12

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    465c:	80 91 cb 07 	lds	r24, 0x07CB
    4660:	81 30       	cpi	r24, 0x01	; 1
    4662:	c1 f5       	brne	.+112    	; 0x46d4 <xTaskCreate+0x18e>
    4664:	c1 ed       	ldi	r28, 0xD1	; 209
    4666:	d7 e0       	ldi	r29, 0x07	; 7
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    4668:	ce 01       	movw	r24, r28
    466a:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
    466e:	29 96       	adiw	r28, 0x09	; 9

static void prvInitialiseTaskLists( void )
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    4670:	b8 e0       	ldi	r27, 0x08	; 8
    4672:	c7 30       	cpi	r28, 0x07	; 7
    4674:	db 07       	cpc	r29, r27
    4676:	c1 f7       	brne	.-16     	; 0x4668 <xTaskCreate+0x122>
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    }

    vListInitialise( &xDelayedTaskList1 );
    4678:	47 e0       	ldi	r20, 0x07	; 7
    467a:	e4 2e       	mov	r14, r20
    467c:	48 e0       	ldi	r20, 0x08	; 8
    467e:	f4 2e       	mov	r15, r20
    4680:	c7 01       	movw	r24, r14
    4682:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    4686:	00 e1       	ldi	r16, 0x10	; 16
    4688:	18 e0       	ldi	r17, 0x08	; 8
    468a:	c8 01       	movw	r24, r16
    468c:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    4690:	8d e1       	ldi	r24, 0x1D	; 29
    4692:	98 e0       	ldi	r25, 0x08	; 8
    4694:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    4698:	86 e2       	ldi	r24, 0x26	; 38
    469a:	98 e0       	ldi	r25, 0x08	; 8
    469c:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    46a0:	f0 92 1a 08 	sts	0x081A, r15
    46a4:	e0 92 19 08 	sts	0x0819, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    46a8:	10 93 1c 08 	sts	0x081C, r17
    46ac:	00 93 1b 08 	sts	0x081B, r16
    46b0:	11 c0       	rjmp	.+34     	; 0x46d4 <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    46b2:	80 91 cc 07 	lds	r24, 0x07CC
    46b6:	88 23       	and	r24, r24
    46b8:	69 f4       	brne	.+26     	; 0x46d4 <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    46ba:	e0 91 bf 07 	lds	r30, 0x07BF
    46be:	f0 91 c0 07 	lds	r31, 0x07C0
    46c2:	96 89       	ldd	r25, Z+22	; 0x16
    46c4:	f6 01       	movw	r30, r12
    46c6:	86 89       	ldd	r24, Z+22	; 0x16
    46c8:	89 17       	cp	r24, r25
    46ca:	20 f0       	brcs	.+8      	; 0x46d4 <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    46cc:	d0 92 c0 07 	sts	0x07C0, r13
    46d0:	c0 92 bf 07 	sts	0x07BF, r12
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    46d4:	80 91 d0 07 	lds	r24, 0x07D0
    46d8:	8f 5f       	subi	r24, 0xFF	; 255
    46da:	80 93 d0 07 	sts	0x07D0, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    46de:	d6 01       	movw	r26, r12
    46e0:	56 96       	adiw	r26, 0x16	; 22
    46e2:	9c 91       	ld	r25, X
    46e4:	80 91 c2 07 	lds	r24, 0x07C2
    46e8:	89 17       	cp	r24, r25
    46ea:	10 f4       	brcc	.+4      	; 0x46f0 <xTaskCreate+0x1aa>
    46ec:	90 93 c2 07 	sts	0x07C2, r25
    46f0:	89 2f       	mov	r24, r25
    46f2:	90 e0       	ldi	r25, 0x00	; 0
    46f4:	fc 01       	movw	r30, r24
    46f6:	33 e0       	ldi	r19, 0x03	; 3
    46f8:	ee 0f       	add	r30, r30
    46fa:	ff 1f       	adc	r31, r31
    46fc:	3a 95       	dec	r19
    46fe:	e1 f7       	brne	.-8      	; 0x46f8 <xTaskCreate+0x1b2>
    4700:	e8 0f       	add	r30, r24
    4702:	f9 1f       	adc	r31, r25
    4704:	ef 52       	subi	r30, 0x2F	; 47
    4706:	f8 4f       	sbci	r31, 0xF8	; 248
    4708:	a1 81       	ldd	r26, Z+1	; 0x01
    470a:	b2 81       	ldd	r27, Z+2	; 0x02
    470c:	f6 01       	movw	r30, r12
    470e:	b5 83       	std	Z+5, r27	; 0x05
    4710:	a4 83       	std	Z+4, r26	; 0x04
    4712:	14 96       	adiw	r26, 0x04	; 4
    4714:	8d 91       	ld	r24, X+
    4716:	9c 91       	ld	r25, X
    4718:	15 97       	sbiw	r26, 0x05	; 5
    471a:	97 83       	std	Z+7, r25	; 0x07
    471c:	86 83       	std	Z+6, r24	; 0x06
    471e:	14 96       	adiw	r26, 0x04	; 4
    4720:	ed 91       	ld	r30, X+
    4722:	fc 91       	ld	r31, X
    4724:	15 97       	sbiw	r26, 0x05	; 5
    4726:	93 82       	std	Z+3, r9	; 0x03
    4728:	82 82       	std	Z+2, r8	; 0x02
    472a:	15 96       	adiw	r26, 0x05	; 5
    472c:	9c 92       	st	X, r9
    472e:	8e 92       	st	-X, r8
    4730:	14 97       	sbiw	r26, 0x04	; 4
    4732:	d6 01       	movw	r26, r12
    4734:	56 96       	adiw	r26, 0x16	; 22
    4736:	ec 91       	ld	r30, X
    4738:	56 97       	sbiw	r26, 0x16	; 22
    473a:	89 e0       	ldi	r24, 0x09	; 9
    473c:	e8 9f       	mul	r30, r24
    473e:	f0 01       	movw	r30, r0
    4740:	11 24       	eor	r1, r1
    4742:	ef 52       	subi	r30, 0x2F	; 47
    4744:	f8 4f       	sbci	r31, 0xF8	; 248
    4746:	1b 96       	adiw	r26, 0x0b	; 11
    4748:	fc 93       	st	X, r31
    474a:	ee 93       	st	-X, r30
    474c:	1a 97       	sbiw	r26, 0x0a	; 10
    474e:	80 81       	ld	r24, Z
    4750:	8f 5f       	subi	r24, 0xFF	; 255
    4752:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    4754:	0f 90       	pop	r0
    4756:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    4758:	80 91 cc 07 	lds	r24, 0x07CC
    475c:	88 23       	and	r24, r24
    475e:	59 f0       	breq	.+22     	; 0x4776 <xTaskCreate+0x230>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    4760:	e0 91 bf 07 	lds	r30, 0x07BF
    4764:	f0 91 c0 07 	lds	r31, 0x07C0
    4768:	96 89       	ldd	r25, Z+22	; 0x16
    476a:	f6 01       	movw	r30, r12
    476c:	86 89       	ldd	r24, Z+22	; 0x16
    476e:	98 17       	cp	r25, r24
    4770:	10 f4       	brcc	.+4      	; 0x4776 <xTaskCreate+0x230>
        {
            taskYIELD_IF_USING_PREEMPTION();
    4772:	0e 94 90 0f 	call	0x1f20	; 0x1f20 <vPortYield>
    4776:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    4778:	df 91       	pop	r29
    477a:	cf 91       	pop	r28
    477c:	1f 91       	pop	r17
    477e:	0f 91       	pop	r16
    4780:	ff 90       	pop	r15
    4782:	ef 90       	pop	r14
    4784:	df 90       	pop	r13
    4786:	cf 90       	pop	r12
    4788:	bf 90       	pop	r11
    478a:	af 90       	pop	r10
    478c:	9f 90       	pop	r9
    478e:	8f 90       	pop	r8
    4790:	7f 90       	pop	r7
    4792:	6f 90       	pop	r6
    4794:	5f 90       	pop	r5
    4796:	4f 90       	pop	r4
    4798:	08 95       	ret

0000479a <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    479a:	ef 92       	push	r14
    479c:	ff 92       	push	r15
    479e:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    47a0:	82 e0       	ldi	r24, 0x02	; 2
    47a2:	92 e2       	ldi	r25, 0x22	; 34
    47a4:	67 ec       	ldi	r22, 0xC7	; 199
    47a6:	70 e0       	ldi	r23, 0x00	; 0
    47a8:	4a ef       	ldi	r20, 0xFA	; 250
    47aa:	50 e0       	ldi	r21, 0x00	; 0
    47ac:	20 e0       	ldi	r18, 0x00	; 0
    47ae:	30 e0       	ldi	r19, 0x00	; 0
    47b0:	00 e0       	ldi	r16, 0x00	; 0
    47b2:	ed ec       	ldi	r30, 0xCD	; 205
    47b4:	ee 2e       	mov	r14, r30
    47b6:	e7 e0       	ldi	r30, 0x07	; 7
    47b8:	fe 2e       	mov	r15, r30
    47ba:	0e 94 a3 22 	call	0x4546	; 0x4546 <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    47be:	81 30       	cpi	r24, 0x01	; 1
    47c0:	81 f4       	brne	.+32     	; 0x47e2 <vTaskStartScheduler+0x48>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    47c2:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    47c4:	8f ef       	ldi	r24, 0xFF	; 255
    47c6:	9f ef       	ldi	r25, 0xFF	; 255
    47c8:	90 93 c7 07 	sts	0x07C7, r25
    47cc:	80 93 c6 07 	sts	0x07C6, r24
        xSchedulerRunning = pdTRUE;
    47d0:	81 e0       	ldi	r24, 0x01	; 1
    47d2:	80 93 cc 07 	sts	0x07CC, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    47d6:	10 92 c5 07 	sts	0x07C5, r1
    47da:	10 92 c4 07 	sts	0x07C4, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    47de:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    47e2:	80 91 d6 01 	lds	r24, 0x01D6
}
    47e6:	0f 91       	pop	r16
    47e8:	ff 90       	pop	r15
    47ea:	ef 90       	pop	r14
    47ec:	08 95       	ret

000047ee <__udivmodhi4>:
    47ee:	aa 1b       	sub	r26, r26
    47f0:	bb 1b       	sub	r27, r27
    47f2:	51 e1       	ldi	r21, 0x11	; 17
    47f4:	07 c0       	rjmp	.+14     	; 0x4804 <__udivmodhi4_ep>

000047f6 <__udivmodhi4_loop>:
    47f6:	aa 1f       	adc	r26, r26
    47f8:	bb 1f       	adc	r27, r27
    47fa:	a6 17       	cp	r26, r22
    47fc:	b7 07       	cpc	r27, r23
    47fe:	10 f0       	brcs	.+4      	; 0x4804 <__udivmodhi4_ep>
    4800:	a6 1b       	sub	r26, r22
    4802:	b7 0b       	sbc	r27, r23

00004804 <__udivmodhi4_ep>:
    4804:	88 1f       	adc	r24, r24
    4806:	99 1f       	adc	r25, r25
    4808:	5a 95       	dec	r21
    480a:	a9 f7       	brne	.-22     	; 0x47f6 <__udivmodhi4_loop>
    480c:	80 95       	com	r24
    480e:	90 95       	com	r25
    4810:	bc 01       	movw	r22, r24
    4812:	cd 01       	movw	r24, r26
    4814:	08 95       	ret

00004816 <__udivmodsi4>:
    4816:	a1 e2       	ldi	r26, 0x21	; 33
    4818:	1a 2e       	mov	r1, r26
    481a:	aa 1b       	sub	r26, r26
    481c:	bb 1b       	sub	r27, r27
    481e:	fd 01       	movw	r30, r26
    4820:	0d c0       	rjmp	.+26     	; 0x483c <__udivmodsi4_ep>

00004822 <__udivmodsi4_loop>:
    4822:	aa 1f       	adc	r26, r26
    4824:	bb 1f       	adc	r27, r27
    4826:	ee 1f       	adc	r30, r30
    4828:	ff 1f       	adc	r31, r31
    482a:	a2 17       	cp	r26, r18
    482c:	b3 07       	cpc	r27, r19
    482e:	e4 07       	cpc	r30, r20
    4830:	f5 07       	cpc	r31, r21
    4832:	20 f0       	brcs	.+8      	; 0x483c <__udivmodsi4_ep>
    4834:	a2 1b       	sub	r26, r18
    4836:	b3 0b       	sbc	r27, r19
    4838:	e4 0b       	sbc	r30, r20
    483a:	f5 0b       	sbc	r31, r21

0000483c <__udivmodsi4_ep>:
    483c:	66 1f       	adc	r22, r22
    483e:	77 1f       	adc	r23, r23
    4840:	88 1f       	adc	r24, r24
    4842:	99 1f       	adc	r25, r25
    4844:	1a 94       	dec	r1
    4846:	69 f7       	brne	.-38     	; 0x4822 <__udivmodsi4_loop>
    4848:	60 95       	com	r22
    484a:	70 95       	com	r23
    484c:	80 95       	com	r24
    484e:	90 95       	com	r25
    4850:	9b 01       	movw	r18, r22
    4852:	ac 01       	movw	r20, r24
    4854:	bd 01       	movw	r22, r26
    4856:	cf 01       	movw	r24, r30
    4858:	08 95       	ret

0000485a <__prologue_saves__>:
    485a:	2f 92       	push	r2
    485c:	3f 92       	push	r3
    485e:	4f 92       	push	r4
    4860:	5f 92       	push	r5
    4862:	6f 92       	push	r6
    4864:	7f 92       	push	r7
    4866:	8f 92       	push	r8
    4868:	9f 92       	push	r9
    486a:	af 92       	push	r10
    486c:	bf 92       	push	r11
    486e:	cf 92       	push	r12
    4870:	df 92       	push	r13
    4872:	ef 92       	push	r14
    4874:	ff 92       	push	r15
    4876:	0f 93       	push	r16
    4878:	1f 93       	push	r17
    487a:	cf 93       	push	r28
    487c:	df 93       	push	r29
    487e:	cd b7       	in	r28, 0x3d	; 61
    4880:	de b7       	in	r29, 0x3e	; 62
    4882:	ca 1b       	sub	r28, r26
    4884:	db 0b       	sbc	r29, r27
    4886:	0f b6       	in	r0, 0x3f	; 63
    4888:	f8 94       	cli
    488a:	de bf       	out	0x3e, r29	; 62
    488c:	0f be       	out	0x3f, r0	; 63
    488e:	cd bf       	out	0x3d, r28	; 61
    4890:	09 94       	ijmp

00004892 <__epilogue_restores__>:
    4892:	2a 88       	ldd	r2, Y+18	; 0x12
    4894:	39 88       	ldd	r3, Y+17	; 0x11
    4896:	48 88       	ldd	r4, Y+16	; 0x10
    4898:	5f 84       	ldd	r5, Y+15	; 0x0f
    489a:	6e 84       	ldd	r6, Y+14	; 0x0e
    489c:	7d 84       	ldd	r7, Y+13	; 0x0d
    489e:	8c 84       	ldd	r8, Y+12	; 0x0c
    48a0:	9b 84       	ldd	r9, Y+11	; 0x0b
    48a2:	aa 84       	ldd	r10, Y+10	; 0x0a
    48a4:	b9 84       	ldd	r11, Y+9	; 0x09
    48a6:	c8 84       	ldd	r12, Y+8	; 0x08
    48a8:	df 80       	ldd	r13, Y+7	; 0x07
    48aa:	ee 80       	ldd	r14, Y+6	; 0x06
    48ac:	fd 80       	ldd	r15, Y+5	; 0x05
    48ae:	0c 81       	ldd	r16, Y+4	; 0x04
    48b0:	1b 81       	ldd	r17, Y+3	; 0x03
    48b2:	aa 81       	ldd	r26, Y+2	; 0x02
    48b4:	b9 81       	ldd	r27, Y+1	; 0x01
    48b6:	ce 0f       	add	r28, r30
    48b8:	d1 1d       	adc	r29, r1
    48ba:	0f b6       	in	r0, 0x3f	; 63
    48bc:	f8 94       	cli
    48be:	de bf       	out	0x3e, r29	; 62
    48c0:	0f be       	out	0x3f, r0	; 63
    48c2:	cd bf       	out	0x3d, r28	; 61
    48c4:	ed 01       	movw	r28, r26
    48c6:	08 95       	ret

000048c8 <memcpy>:
    48c8:	fb 01       	movw	r30, r22
    48ca:	dc 01       	movw	r26, r24
    48cc:	02 c0       	rjmp	.+4      	; 0x48d2 <memcpy+0xa>
    48ce:	01 90       	ld	r0, Z+
    48d0:	0d 92       	st	X+, r0
    48d2:	41 50       	subi	r20, 0x01	; 1
    48d4:	50 40       	sbci	r21, 0x00	; 0
    48d6:	d8 f7       	brcc	.-10     	; 0x48ce <memcpy+0x6>
    48d8:	08 95       	ret

000048da <memset>:
    48da:	dc 01       	movw	r26, r24
    48dc:	01 c0       	rjmp	.+2      	; 0x48e0 <memset+0x6>
    48de:	6d 93       	st	X+, r22
    48e0:	41 50       	subi	r20, 0x01	; 1
    48e2:	50 40       	sbci	r21, 0x00	; 0
    48e4:	e0 f7       	brcc	.-8      	; 0x48de <memset+0x4>
    48e6:	08 95       	ret

000048e8 <_exit>:
    48e8:	f8 94       	cli

000048ea <__stop_program>:
    48ea:	ff cf       	rjmp	.-2      	; 0x48ea <__stop_program>
